This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
commands/
  clothing_commands.py
  command.py
  crafting_commands.py
  default_cmdsets.py
  README.md
  resource_commands.py
  search_commands.py
  survival_commands.py
  time_commands.py
server/
  conf/
    __init__.py
    at_initial_setup.py
    at_search.py
    at_server_startstop.py
    cmdparser.py
    connection_screens.py
    inlinefuncs.py
    inputfuncs.py
    lockfuncs.py
    mssp.py
    portal_services_plugins.py
    server_services_plugins.py
    serversession.py
    settings.py
    web_plugins.py
  logs/
    README.md
  __init__.py
  README.md
typeclasses/
  accounts.py
  channels.py
  characters.py
  exits.py
  objects.py
  README.md
  rooms.py
  scripts.py
web/
  admin/
    README.md
    urls.py
  static/
    rest_framework/
      css/
        README.md
      images/
        README.md
    webclient/
      css/
        README.md
      js/
        README.md
    website/
      css/
        README.md
      images/
        README.md
    README.md
  templates/
    rest_framework/
      README.md
    webclient/
      README.md
    website/
      flatpages/
        README.md
      registration/
        README.md
      README.md
    README.md
  webclient/
    README.md
    urls.py
  website/
    README.md
    urls.py
  README.md
  urls.py
world/
  recipes/
    base_recipes.py
    clothing_recipes.py
    steampunk_recipes.py
    survival_recipes.py
    tool_recipes.py
  tests/
    __init__.py
    test_characters.py
    test_clothing.py
    test_cooldowns.py
    test_crafting.py
    test_gametime.py
    test_rooms.py
  batch_cmds.ev
  gametime_utils.py
  help_entries.py
  prototypes.py
  README.md
.gitattributes
.gitignore
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(evennia test:*)"
    ],
    "deny": []
  }
}
</file>

<file path="commands/clothing_commands.py">
# commands/clothing_commands.py
"""
Enhanced clothing commands for the survival game.

These extend the basic clothing commands to show
protection values and condition.
"""

from evennia.contrib.game_systems.clothing.clothing import CmdWear as BaseCmdWear
from evennia.contrib.game_systems.clothing.clothing import CmdRemove as BaseCmdRemove
from evennia.contrib.game_systems.clothing.clothing import CmdInventory as BaseCmdInventory
from evennia import Command
from evennia.utils import evtable


class CmdWear(BaseCmdWear):
    """
    Puts on an item of clothing you are holding.

    Usage:
      wear <obj> [=] [wear style]

    Examples:
      wear red shirt
      wear scarf wrapped loosely about the shoulders
      wear blue hat = at a jaunty angle

    Wearing clothing provides various benefits:
    - Protection from weather conditions
    - Warmth in cold environments
    - Stat bonuses
    - Special crafting or skill bonuses

    The benefits are shown when you look at the item.
    """
    
    def func(self):
        """Execute the wear command with benefit notifications."""
        # First do the normal wear operation
        super().func()
        
        # If wear was successful, show benefits
        if self.rhs or not hasattr(self, 'clothing'):
            # Get the clothing item we just wore
            if hasattr(self, 'lhs'):
                clothing = self.caller.search(
                    self.lhs, 
                    candidates=self.caller.contents,
                    quiet=True
                )
                if clothing and clothing.db.worn:
                    # Show what benefits this provides
                    self.show_clothing_benefits(clothing)
    
    def show_clothing_benefits(self, clothing):
        """Display the benefits of wearing this clothing."""
        benefits = []
        
        if clothing.db.warmth_value and clothing.db.warmth_value > 0:
            benefits.append(f"|wWarmth:|n +{clothing.db.warmth_value}")
            
        if clothing.db.weather_protection:
            protections = ", ".join(clothing.db.weather_protection)
            benefits.append(f"|wWeather Protection:|n {protections}")
            
        if clothing.db.stat_modifiers:
            for stat, mod in clothing.db.stat_modifiers.items():
                sign = "+" if mod > 0 else ""
                benefits.append(f"|w{stat.title()}:|n {sign}{mod}")
                
        if hasattr(clothing.db, 'crafting_bonus') and clothing.db.crafting_bonus:
            benefits.append(f"|wCrafting:|n +{clothing.db.crafting_bonus}%")
            
        if hasattr(clothing.db, 'engineering_bonus') and clothing.db.engineering_bonus:
            benefits.append(f"|wEngineering:|n +{clothing.db.engineering_bonus}%")
            
        if benefits:
            self.caller.msg(f"\n|yBenefits:|n {', '.join(benefits)}")


class CmdClothingStatus(Command):
    """
    Check your clothing and environmental protection.
    
    Usage:
        clothing status
        clothes
        
    Shows what you're wearing, your total protection values,
    and what weather conditions you're protected against.
    """
    
    key = "clothing status"
    aliases = ["clothes", "clothing"]
    locks = "cmd:all()"
    help_category = "Survival"
    
    def func(self):
        """Display comprehensive clothing status."""
        caller = self.caller
        
        # Get worn items
        worn_items = caller.get_worn_clothes(exclude_covered=True)
        
        if not worn_items:
            caller.msg("You are not wearing any clothing.")
            return
        
        # Create output table
        table = evtable.EvTable(
            "|wItem|n",
            "|wType|n", 
            "|wCondition|n",
            "|wBenefits|n",
            border="header"
        )
        
        # Track totals
        total_warmth = 0
        total_protection = 0
        weather_protections = set()
        stat_totals = {}
        
        # Add each worn item
        for item in worn_items:
            # Get condition
            if hasattr(item, 'get_condition_string'):
                condition = item.get_condition_string()
            else:
                condition = "|gunknown|n"
                
            # Build benefits string
            benefits = []
            
            warmth = item.db.warmth_value or 0
            if warmth > 0:
                benefits.append(f"warmth:{warmth}")
                total_warmth += warmth
                
            protection = item.db.protection_value or 0
            if protection > 0:
                benefits.append(f"armor:{protection}")
                total_protection += protection
                
            if item.db.weather_protection:
                weather_protections.update(item.db.weather_protection)
                
            if item.db.stat_modifiers:
                for stat, mod in item.db.stat_modifiers.items():
                    if stat in stat_totals:
                        stat_totals[stat] += mod
                    else:
                        stat_totals[stat] = mod
            
            benefit_str = ", ".join(benefits) if benefits else "none"
            
            table.add_row(
                item.get_display_name(caller),
                item.db.clothing_type or "untyped",
                condition,
                benefit_str
            )
        
        # Display table
        caller.msg("|wWorn Clothing:|n")
        caller.msg(str(table))
        
        # Display totals
        caller.msg("\n|wTotal Protection:|n")
        
        # Warmth level
        warmth_desc = self.get_warmth_description(total_warmth)
        caller.msg(f"  |wWarmth:|n {total_warmth} ({warmth_desc})")
        
        # Armor
        if total_protection > 0:
            caller.msg(f"  |wArmor:|n {total_protection}")
            
        # Weather
        if weather_protections:
            caller.msg(f"  |wWeather Protection:|n {', '.join(sorted(weather_protections))}")
        else:
            caller.msg("  |wWeather Protection:|n none")
            
        # Stats
        if stat_totals:
            stat_strings = []
            for stat, total in sorted(stat_totals.items()):
                sign = "+" if total > 0 else ""
                stat_strings.append(f"{stat}: {sign}{total}")
            caller.msg(f"  |wStat Modifiers:|n {', '.join(stat_strings)}")
            
        # Environmental assessment
        self.show_environmental_readiness(caller, total_warmth, weather_protections)
    
    def get_warmth_description(self, warmth):
        """Get descriptive text for warmth level."""
        if warmth >= 60:
            return "|rsweltering|n"
        elif warmth >= 40:
            return "|yvery warm|n"
        elif warmth >= 25:
            return "|gwarm|n"
        elif warmth >= 15:
            return "|gcomfortable|n"
        elif warmth >= 8:
            return "|ycool|n"
        elif warmth >= 3:
            return "|ychilly|n"
        else:
            return "|bcold|n"
    
    def show_environmental_readiness(self, caller, warmth, weather_protections):
        """Show how ready the character is for current conditions."""
        if not caller.location:
            return
            
        # Get current conditions
        season = caller.location.get_season()
        weather = caller.location.get_current_weather()
        time_of_day = caller.location.get_time_of_day()
        
        caller.msg(f"\n|wEnvironmental Readiness:|n")
        caller.msg(f"  Current: {season} {time_of_day}, weather: {', '.join(weather)}")
        
        warnings = []
        
        # Check warmth for season
        if season == "winter":
            if warmth < 20:
                warnings.append("|rYou need more warm clothing for winter!|n")
            elif warmth < 30:
                warnings.append("|yYou could use more warmth for winter.|n")
        elif season == "summer" and warmth > 30:
            warnings.append("|yYou're overdressed for summer heat.|n")
            
        # Check weather protection
        for condition in weather:
            if condition in ["rain", "storm"] and "rain" not in weather_protections:
                warnings.append("|yYou lack rain protection.|n")
            elif condition == "snow" and "snow" not in weather_protections:
                warnings.append("|yYou lack snow protection.|n")
                
        if warnings:
            for warning in warnings:
                caller.msg(f"  {warning}")
        else:
            caller.msg("  |gYou are well-equipped for current conditions.|n")


class CmdRepair(Command):
    """
    Repair damaged clothing using materials.
    
    Usage:
        repair <clothing>
        
    Repairing clothing requires the appropriate materials
    and crafting skill. The materials needed depend on
    the type of clothing.
    """
    
    key = "repair"
    aliases = ["mend", "fix"]
    locks = "cmd:all()"
    help_category = "Crafting"
    
    def func(self):
        """Execute repair command."""
        if not self.args:
            self.caller.msg("Usage: repair <clothing item>")
            return
            
        # Find the item
        clothing = self.caller.search(self.args, candidates=self.caller.contents)
        if not clothing:
            return
            
        # Check if it's clothing
        if not hasattr(clothing, 'db') or not hasattr(clothing.db, 'durability'):
            self.caller.msg(f"{clothing.get_display_name(self.caller)} cannot be repaired.")
            return
            
        # Check condition
        if clothing.db.durability >= clothing.db.max_durability:
            self.caller.msg(f"{clothing.get_display_name(self.caller)} doesn't need repairs.")
            return
            
        # Check materials
        required_materials = clothing.db.repair_materials or ["cloth"]
        available_materials = []
        
        for mat_type in required_materials:
            # Look for material in inventory
            material = self.caller.search(
                mat_type, 
                candidates=self.caller.contents,
                quiet=True
            )
            if material:
                available_materials.append(material)
            else:
                self.caller.msg(f"You need {mat_type} to repair this.")
                return
                
        # Check skill
        skill_level = self.caller.get_skill_level("crafting")[0] or 0
        repair_difficulty = 30  # Base difficulty
        
        # Adjust difficulty based on damage
        damage_percent = 100 - ((clothing.db.durability / clothing.db.max_durability) * 100)
        if damage_percent > 70:
            repair_difficulty += 20
        elif damage_percent > 50:
            repair_difficulty += 10
            
        if skill_level < repair_difficulty:
            self.caller.msg(
                f"You need at least {repair_difficulty} crafting skill to repair this "
                f"(you have {skill_level})."
            )
            return
            
        # Perform repair
        # TODO: This will consume materials when crafting system is implemented
        repair_amount = min(20 + (skill_level // 10), clothing.db.max_durability - clothing.db.durability)
        clothing.db.durability += repair_amount
        
        self.caller.msg(
            f"You repair {clothing.get_display_name(self.caller)}. "
            f"It is now at {clothing.db.durability}/{clothing.db.max_durability} durability."
        )
        
        # Improve skill slightly
        if skill_level < 100:
            self.caller.improve_skill("crafting", 1)
</file>

<file path="commands/command.py">
"""
Commands

Commands describe the input the account can do to the game.

"""

from evennia.commands.command import Command as BaseCommand

# from evennia import default_cmds


class Command(BaseCommand):
    """
    Base command (you may see this if a child command had no help text defined)

    Note that the class's `__doc__` string is used by Evennia to create the
    automatic help entry for the command, so make sure to document consistently
    here. Without setting one, the parent's docstring will show (like now).

    """

    # Each Command class implements the following methods, called in this order
    # (only func() is actually required):
    #
    #     - at_pre_cmd(): If this returns anything truthy, execution is aborted.
    #     - parse(): Should perform any extra parsing needed on self.args
    #         and store the result on self.
    #     - func(): Performs the actual work.
    #     - at_post_cmd(): Extra actions, often things done after
    #         every command, like prompts.
    #
    pass


# -------------------------------------------------------------
#
# The default commands inherit from
#
#   evennia.commands.default.muxcommand.MuxCommand.
#
# If you want to make sweeping changes to default commands you can
# uncomment this copy of the MuxCommand parent and add
#
#   COMMAND_DEFAULT_CLASS = "commands.command.MuxCommand"
#
# to your settings file. Be warned that the default commands expect
# the functionality implemented in the parse() method, so be
# careful with what you change.
#
# -------------------------------------------------------------

# from evennia.utils import utils
#
#
# class MuxCommand(Command):
#     """
#     This sets up the basis for a MUX command. The idea
#     is that most other Mux-related commands should just
#     inherit from this and don't have to implement much
#     parsing of their own unless they do something particularly
#     advanced.
#
#     Note that the class's __doc__ string (this text) is
#     used by Evennia to create the automatic help entry for
#     the command, so make sure to document consistently here.
#     """
#     def has_perm(self, srcobj):
#         """
#         This is called by the cmdhandler to determine
#         if srcobj is allowed to execute this command.
#         We just show it here for completeness - we
#         are satisfied using the default check in Command.
#         """
#         return super().has_perm(srcobj)
#
#     def at_pre_cmd(self):
#         """
#         This hook is called before self.parse() on all commands
#         """
#         pass
#
#     def at_post_cmd(self):
#         """
#         This hook is called after the command has finished executing
#         (after self.func()).
#         """
#         pass
#
#     def parse(self):
#         """
#         This method is called by the cmdhandler once the command name
#         has been identified. It creates a new set of member variables
#         that can be later accessed from self.func() (see below)
#
#         The following variables are available for our use when entering this
#         method (from the command definition, and assigned on the fly by the
#         cmdhandler):
#            self.key - the name of this command ('look')
#            self.aliases - the aliases of this cmd ('l')
#            self.permissions - permission string for this command
#            self.help_category - overall category of command
#
#            self.caller - the object calling this command
#            self.cmdstring - the actual command name used to call this
#                             (this allows you to know which alias was used,
#                              for example)
#            self.args - the raw input; everything following self.cmdstring.
#            self.cmdset - the cmdset from which this command was picked. Not
#                          often used (useful for commands like 'help' or to
#                          list all available commands etc)
#            self.obj - the object on which this command was defined. It is often
#                          the same as self.caller.
#
#         A MUX command has the following possible syntax:
#
#           name[ with several words][/switch[/switch..]] arg1[,arg2,...] [[=|,] arg[,..]]
#
#         The 'name[ with several words]' part is already dealt with by the
#         cmdhandler at this point, and stored in self.cmdname (we don't use
#         it here). The rest of the command is stored in self.args, which can
#         start with the switch indicator /.
#
#         This parser breaks self.args into its constituents and stores them in the
#         following variables:
#           self.switches = [list of /switches (without the /)]
#           self.raw = This is the raw argument input, including switches
#           self.args = This is re-defined to be everything *except* the switches
#           self.lhs = Everything to the left of = (lhs:'left-hand side'). If
#                      no = is found, this is identical to self.args.
#           self.rhs: Everything to the right of = (rhs:'right-hand side').
#                     If no '=' is found, this is None.
#           self.lhslist - [self.lhs split into a list by comma]
#           self.rhslist - [list of self.rhs split into a list by comma]
#           self.arglist = [list of space-separated args (stripped, including '=' if it exists)]
#
#           All args and list members are stripped of excess whitespace around the
#           strings, but case is preserved.
#         """
#         raw = self.args
#         args = raw.strip()
#
#         # split out switches
#         switches = []
#         if args and len(args) > 1 and args[0] == "/":
#             # we have a switch, or a set of switches. These end with a space.
#             switches = args[1:].split(None, 1)
#             if len(switches) > 1:
#                 switches, args = switches
#                 switches = switches.split('/')
#             else:
#                 args = ""
#                 switches = switches[0].split('/')
#         arglist = [arg.strip() for arg in args.split()]
#
#         # check for arg1, arg2, ... = argA, argB, ... constructs
#         lhs, rhs = args, None
#         lhslist, rhslist = [arg.strip() for arg in args.split(',')], []
#         if args and '=' in args:
#             lhs, rhs = [arg.strip() for arg in args.split('=', 1)]
#             lhslist = [arg.strip() for arg in lhs.split(',')]
#             rhslist = [arg.strip() for arg in rhs.split(',')]
#
#         # save to object properties:
#         self.raw = raw
#         self.switches = switches
#         self.args = args.strip()
#         self.arglist = arglist
#         self.lhs = lhs
#         self.lhslist = lhslist
#         self.rhs = rhs
#         self.rhslist = rhslist
#
#         # if the class has the account_caller property set on itself, we make
#         # sure that self.caller is always the account if possible. We also create
#         # a special property "character" for the puppeted object, if any. This
#         # is convenient for commands defined on the Account only.
#         if hasattr(self, "account_caller") and self.account_caller:
#             if utils.inherits_from(self.caller, "evennia.objects.objects.DefaultObject"):
#                 # caller is an Object/Character
#                 self.character = self.caller
#                 self.caller = self.caller.account
#             elif utils.inherits_from(self.caller, "evennia.accounts.accounts.DefaultAccount"):
#                 # caller was already an Account
#                 self.character = self.caller.get_puppet(self.session)
#             else:
#                 self.character = None
</file>

<file path="commands/crafting_commands.py">
# commands/crafting_commands.py
"""
Crafting-related commands for the survival game.

Extends the basic crafting command with additional features
like recipe browsing and skill integration.
"""

from evennia.contrib.game_systems.crafting.crafting import CmdCraft as BaseCmdCraft
from evennia.contrib.game_systems.crafting.crafting import craft
from evennia import Command
from evennia.utils import list_to_string, evtable
from django.conf import settings


class CmdCraft(BaseCmdCraft):
    """
    Craft items from recipes using tools and materials.
    
    Usage:
        craft <recipe> [from <ingredients>] [using <tools>]
        craft list [category]
        craft info <recipe>
        
    Examples:
        craft bread from flour, water, yeast using oven
        craft pickaxe from iron, wood using forge, hammer
        craft list survival
        craft info "steam engine"
        
    The crafting system uses your skills and the quality of your
    tools to determine the outcome. Higher skill levels result in
    better quality items with improved stats.
    
    Categories:
        survival - Food, water, basic necessities
        tools - Tools and equipment
        clothing - Armor and weather protection
        steampunk - Advanced machinery and devices
        
    Your current crafting-related skills affect success rates:
        - crafting: General crafting ability
        - engineering: For complex mechanical items
        - survival: For wilderness and food crafts
    """
    
    key = "craft"
    aliases = ["create", "make", "build"]
    help_category = "Crafting"
    
    def func(self):
        """Execute the craft command."""
        if not self.args:
            self.caller.msg("Usage: craft <recipe> [from <ingredient>,...] [using <tool>,...]")
            self.caller.msg("       craft list [category]")
            self.caller.msg("       craft info <recipe>")
            return
        
        # Check for subcommands
        if self.args.startswith("list"):
            self.list_recipes()
            return
        elif self.args.startswith("info"):
            self.show_recipe_info()
            return
        
        # Otherwise, do normal crafting
        super().func()
    
    def list_recipes(self):
        """List available recipes, optionally filtered by category."""
        from evennia.contrib.game_systems.crafting.crafting import _load_recipes, _RECIPE_CLASSES
        
        _load_recipes()
        
        # Parse category filter
        args = self.args.split(None, 1)
        category = args[1].lower() if len(args) > 1 else None
        
        # Get character's skills for display
        crafting_skill = self.caller.skills.crafting.value
        engineering_skill = self.caller.skills.engineering.value
        survival_skill = self.caller.skills.survival.value
        
        # Build recipe list
        recipes_by_category = {
            "survival": [],
            "tools": [],
            "clothing": [],
            "steampunk": [],
            "other": []
        }
        
        for recipe_name, recipe_class in _RECIPE_CLASSES.items():
            # Categorize based on module or recipe properties
            if hasattr(recipe_class, 'craft_category'):
                if 'steampunk' in recipe_class.__module__:
                    cat = "steampunk"
                elif 'clothing' in recipe_class.__module__:
                    cat = "clothing"
                elif 'tool' in recipe_class.__module__:
                    cat = "tools"
                elif 'survival' in recipe_class.__module__:
                    cat = "survival"
                else:
                    cat = "other"
            else:
                cat = "other"
            
            # Get skill info
            skill_req = getattr(recipe_class, 'skill_requirement', 'crafting')
            difficulty = getattr(recipe_class, 'difficulty', 0)
            
            # Check if player can attempt this
            if skill_req == "engineering":
                current_skill = engineering_skill
            elif skill_req == "survival":
                current_skill = survival_skill
            else:
                current_skill = crafting_skill
            
            can_attempt = current_skill >= difficulty
            
            # Format entry
            if can_attempt:
                status = "|g✓|n"
            else:
                status = "|r✗|n"
            
            entry = f"{status} {recipe_name:<20} ({skill_req} {difficulty}+)"
            
            recipes_by_category[cat].append((difficulty, entry))
        
        # Display results
        if category and category in recipes_by_category:
            # Show single category
            self.caller.msg(f"\n|wCrafting Recipes - {category.title()}:|n")
            recipes = sorted(recipes_by_category[category], key=lambda x: x[0])
            for _, entry in recipes:
                self.caller.msg(f"  {entry}")
        else:
            # Show all categories
            self.caller.msg("\n|wCrafting Recipes:|n")
            self.caller.msg("|xUse 'craft list <category>' to filter|n")
            
            for cat in ["survival", "tools", "clothing", "steampunk", "other"]:
                if recipes_by_category[cat]:
                    self.caller.msg(f"\n|w{cat.title()}:|n")
                    recipes = sorted(recipes_by_category[cat], key=lambda x: x[0])
                    for _, entry in recipes[:10]:  # Show first 10
                        self.caller.msg(f"  {entry}")
                    if len(recipes) > 10:
                        self.caller.msg(f"  |x... and {len(recipes) - 10} more|n")
        
        # Show skill summary
        self.caller.msg(f"\n|wYour Skills:|n")
        self.caller.msg(f"  Crafting: {crafting_skill}")
        self.caller.msg(f"  Engineering: {engineering_skill}")
        self.caller.msg(f"  Survival: {survival_skill}")
    
    def show_recipe_info(self):
        """Show detailed info about a specific recipe."""
        from evennia.contrib.game_systems.crafting.crafting import _load_recipes, _RECIPE_CLASSES
        
        _load_recipes()
        
        # Get recipe name
        args = self.args.split(None, 1)
        if len(args) < 2:
            self.caller.msg("Usage: craft info <recipe name>")
            return
        
        recipe_name = args[1].lower()
        
        # Find recipe
        recipe_class = None
        for rname, rclass in _RECIPE_CLASSES.items():
            if rname.lower() == recipe_name or recipe_name in rname.lower():
                recipe_class = rclass
                recipe_name = rname
                break
        
        if not recipe_class:
            self.caller.msg(f"No recipe found matching '{recipe_name}'.")
            return
        
        # Display recipe info
        self.caller.msg(f"\n|w{recipe_name.title()}|n")
        if hasattr(recipe_class, '__doc__') and recipe_class.__doc__:
            self.caller.msg(f"|x{recipe_class.__doc__.strip()}|n")
        
        # Requirements
        skill_req = getattr(recipe_class, 'skill_requirement', 'crafting')
        difficulty = getattr(recipe_class, 'difficulty', 0)
        
        self.caller.msg(f"\n|wRequirements:|n")
        self.caller.msg(f"  Skill: {skill_req} {difficulty}+")
        
        # Tools
        if recipe_class.tool_tags:
            self.caller.msg(f"\n|wTools needed:|n")
            for tool in recipe_class.tool_tags:
                self.caller.msg(f"  - {tool}")
        
        # Ingredients
        if recipe_class.consumable_tags:
            self.caller.msg(f"\n|wIngredients:|n")
            # Count duplicates
            ing_counts = {}
            for ing in recipe_class.consumable_tags:
                ing_counts[ing] = ing_counts.get(ing, 0) + 1
            
            for ing, count in ing_counts.items():
                if count > 1:
                    self.caller.msg(f"  - {ing} x{count}")
                else:
                    self.caller.msg(f"  - {ing}")
        
        # Output
        self.caller.msg(f"\n|wCreates:|n")
        for proto in recipe_class.output_prototypes:
            key = proto.get('key', 'unknown item')
            self.caller.msg(f"  - {key}")
        
        # Craft time
        craft_time = getattr(recipe_class, 'craft_time', 300)
        minutes = craft_time // 60
        seconds = craft_time % 60
        if minutes:
            time_str = f"{minutes}m {seconds}s" if seconds else f"{minutes}m"
        else:
            time_str = f"{seconds}s"
        self.caller.msg(f"\n|wCraft time:|n {time_str}")
        
        # Check if player can attempt
        current_skill = 0
        if skill_req == "engineering":
            current_skill = self.caller.skills.engineering.value
        elif skill_req == "survival":
            current_skill = self.caller.skills.survival.value
        else:
            current_skill = self.caller.skills.crafting.value
        
        if current_skill >= difficulty:
            self.caller.msg(f"\n|gYou have the skill to attempt this recipe.|n")
        else:
            needed = difficulty - current_skill
            self.caller.msg(f"\n|rYou need {needed} more {skill_req} skill to attempt this.|n")


class CmdRecipes(Command):
    """
    View your known recipes and crafting statistics.
    
    Usage:
        recipes
        recipes stats
        
    Shows all recipes you've successfully crafted before,
    along with your crafting statistics and achievements.
    """
    
    key = "recipes"
    aliases = ["known_recipes"]
    locks = "cmd:all()"
    help_category = "Crafting"
    
    def func(self):
        """Display known recipes or stats."""
        if self.args.strip() == "stats":
            self.show_crafting_stats()
        else:
            self.show_known_recipes()
    
    def show_known_recipes(self):
        """Display recipes the player has successfully crafted."""
        known_recipes = self.caller.db.known_recipes or []
        
        if not known_recipes:
            self.caller.msg("You haven't successfully crafted any recipes yet.")
            self.caller.msg("Use |wcraft list|n to see available recipes.")
            return
        
        self.caller.msg("|wYour Known Recipes:|n")
        
        # Group by category
        by_category = {}
        for recipe_name in known_recipes:
            # Simple categorization
            if any(word in recipe_name for word in ["bread", "stew", "tea", "preserved"]):
                cat = "Food & Drink"
            elif any(word in recipe_name for word in ["armor", "cloak", "goggles", "coat"]):
                cat = "Clothing"
            elif any(word in recipe_name for word in ["pickaxe", "tools", "forge", "workbench"]):
                cat = "Tools"
            elif any(word in recipe_name for word in ["steam", "clockwork", "automaton", "pressure"]):
                cat = "Steampunk"
            else:
                cat = "Other"
            
            by_category.setdefault(cat, []).append(recipe_name)
        
        # Display by category
        for cat, recipes in sorted(by_category.items()):
            self.caller.msg(f"\n|w{cat}:|n")
            for recipe in sorted(recipes):
                count = self.caller.db.craft_counts.get(recipe, 0)
                quality = self.caller.db.best_quality.get(recipe, "average")
                self.caller.msg(f"  {recipe:<25} (crafted {count}x, best: {quality})")
    
    def show_crafting_stats(self):
        """Display crafting statistics."""
        stats = self.caller.db.crafting_stats or {}
        
        self.caller.msg("|wCrafting Statistics:|n")
        
        total_crafted = stats.get('total_crafted', 0)
        total_failed = stats.get('total_failed', 0)
        total_attempts = total_crafted + total_failed
        
        if total_attempts > 0:
            success_rate = (total_crafted / total_attempts) * 100
        else:
            success_rate = 0
        
        self.caller.msg(f"\nTotal items crafted: {total_crafted}")
        self.caller.msg(f"Failed attempts: {total_failed}")
        self.caller.msg(f"Success rate: {success_rate:.1f}%")
        
        # Quality breakdown
        quality_counts = stats.get('quality_counts', {})
        if quality_counts:
            self.caller.msg("\n|wQuality Distribution:|n")
            for quality in ["poor", "average", "good", "fine", "excellent", "masterwork"]:
                count = quality_counts.get(quality, 0)
                if count > 0:
                    percent = (count / total_crafted) * 100
                    self.caller.msg(f"  {quality:<12} {count:>4} ({percent:>5.1f}%)")
        
        # Most crafted
        craft_counts = self.caller.db.craft_counts or {}
        if craft_counts:
            self.caller.msg("\n|wMost Crafted Items:|n")
            sorted_items = sorted(craft_counts.items(), key=lambda x: x[1], reverse=True)
            for recipe, count in sorted_items[:5]:
                self.caller.msg(f"  {recipe:<25} {count}x")
        
        # Skill levels
        self.caller.msg("\n|wCrafting Skills:|n")
        self.caller.msg(f"  Crafting: {self.caller.skills.crafting.value}")
        self.caller.msg(f"  Engineering: {self.caller.skills.engineering.value}")
        self.caller.msg(f"  Survival: {self.caller.skills.survival.value}")
</file>

<file path="commands/README.md">
# commands/

This folder holds modules for implementing one's own commands and
command sets. All the modules' classes are essentially empty and just
imports the default implementations from Evennia; so adding anything
to them will start overloading the defaults. 

You can change the organisation of this directory as you see fit, just
remember that if you change any of the default command set classes'
locations, you need to add the appropriate paths to
`server/conf/settings.py` so that Evennia knows where to find them.
Also remember that if you create new sub directories you must put
(optionally empty) `__init__.py` files in there so that Python can
find your modules.
</file>

<file path="commands/search_commands.py">
# commands/search_commands.py
"""
Search commands for finding hidden objects and resources.

These commands work with the Extended Room's visibility system
to allow players to actively search for hidden items.
"""

from evennia import Command
from evennia.utils import list_to_string
import random


class CmdSearch(Command):
    """
    Search the room for hidden objects or resources.
    
    Usage:
        search
        search <target>
        search for <resource>
        
    Examples:
        search                    - General search of the room
        search bushes            - Search a specific detail  
        search for plants        - Search for forgeable plants
        
    This command allows you to find hidden objects that aren't
    immediately visible. Your success depends on:
    - The visibility conditions (light, weather)
    - Your relevant skills (foraging, survival)
    - The hidden object's concealment level
    
    Some objects can only be found through searching.
    """
    
    key = "search"
    locks = "cmd:all()"
    help_category = "General"
    
    def parse(self):
        """Parse the command input."""
        self.raw = self.raw_string.strip()
        
        # Check for "search for <resource>" pattern
        if " for " in self.args:
            parts = self.args.split(" for ", 1)
            self.search_target = None
            self.resource_type = parts[1].strip()
        else:
            self.search_target = self.args.strip() if self.args else None
            self.resource_type = None
    
    def func(self):
        """Perform the search."""
        caller = self.caller
        location = caller.location
        
        if not location:
            caller.msg("You have nowhere to search.")
            return
        
        # Check if still on cooldown
        if not caller.cooldowns.ready("search"):
            time_left = caller.cooldowns.time_left("search", use_int=True)
            caller.msg(f"You are still recovering from your last search. "
                      f"Wait {time_left} more seconds.")
            return
        
        # Different search types
        if self.resource_type:
            self.search_for_resources()
        elif self.search_target:
            self.search_specific_target()
        else:
            self.search_general()
        
        # Set cooldown (30 seconds base)
        caller.cooldowns.add("search", 30)
    
    def search_general(self):
        """Perform a general search of the room."""
        caller = self.caller
        location = caller.location
        
        # Announce the search
        caller.msg("You carefully search the area...")
        location.msg_contents(
            f"{caller.name} carefully searches the area.",
            exclude=caller
        )
        
        # Get all hidden objects in the room
        hidden_objects = [
            obj for obj in location.contents
            if obj.db.hidden and not obj.has_account
        ]
        
        if not hidden_objects:
            caller.msg("Your search reveals nothing special.")
            return
        
        # Calculate search success for each hidden object
        found_objects = []
        search_skill = caller.skills.foraging.value
        survival_skill = caller.skills.survival.value
        
        # Better skills improve search chances
        base_chance = 0.3 + (search_skill / 200) + (survival_skill / 400)
        
        # Environmental modifiers
        visibility_range = location.get_visibility_range(caller)
        if visibility_range < 3:
            base_chance *= 0.5  # Hard to search in poor visibility
        
        # Check each hidden object
        for obj in hidden_objects:
            # Adjust chance based on object properties
            chance = base_chance
            
            # Tiny objects are harder to find
            if obj.db.visibility_size == "tiny":
                chance *= 0.5
            elif obj.db.visibility_size == "small":
                chance *= 0.7
            
            # Camouflaged objects are harder
            if obj.db.contrast == "camouflaged":
                chance *= 0.5
            
            # Roll for discovery
            if random.random() < chance:
                found_objects.append(obj)
                obj.db.hidden = False  # No longer hidden once found
        
        # Report findings
        if found_objects:
            caller.msg(f"Your search reveals: {list_to_string(found_objects)}!")
            
            # Skill improvement
            if search_skill < 100:
                if caller.improve_skill("foraging", 2):
                    caller.msg("Your foraging skill improves from the careful search.")
        else:
            caller.msg("Your search reveals nothing special.")
    
    def search_specific_target(self):
        """Search a specific target or detail."""
        caller = self.caller
        location = caller.location
        
        # First check if it's a room detail
        if hasattr(location, 'get_detail'):
            detail = location.get_detail(self.search_target)
            if detail:
                caller.msg(f"You carefully examine the {self.search_target}...")
                location.msg_contents(
                    f"{caller.name} carefully examines the {self.search_target}.",
                    exclude=caller
                )
                
                # Details might hide objects
                # For now, just show the detail with search flavor
                caller.msg(f"Your careful examination reveals:\n{detail}")
                return
        
        # Search for a specific visible object
        obj = caller.search(self.search_target, location=location)
        if not obj:
            return
        
        caller.msg(f"You carefully search around {obj.get_display_name(caller)}...")
        location.msg_contents(
            f"{caller.name} searches around {obj.get_display_name(caller)}.",
            exclude=caller
        )
        
        # For now, just give more detailed description
        # Could later hide things "under" or "inside" objects
        desc = obj.db.desc
        if desc:
            caller.msg(f"Your thorough examination reveals: {desc}")
        else:
            caller.msg("Your search reveals nothing special about it.")
    
    def search_for_resources(self):
        """Search specifically for gatherable resources."""
        caller = self.caller
        location = caller.location
        
        # Check if the resource type exists in this room
        resources = location.db.resources or {}
        if self.resource_type not in resources:
            caller.msg(f"You don't think you can find {self.resource_type} here.")
            return
        
        resource = resources[self.resource_type]
        current = resource.get("current", 0)
        
        # Check if any available
        if current == 0:
            caller.msg(f"You search carefully but find no {self.resource_type} available.")
            return
        
        # Calculate how much they can detect
        skill_required = resource.get("skill_required", "foraging")
        skill_level = 0
        if skill_required:
            skill_level = caller.skills.get(skill_required).value
        
        # Better skill reveals more accurate counts
        availability = location.get_resource_availability(self.resource_type)
        effective_amount = int(current * availability)
        
        if skill_level < 20:
            # Vague description
            if effective_amount == 0:
                amount_desc = "no"
            elif effective_amount < 3:
                amount_desc = "very little"
            elif effective_amount < 6:
                amount_desc = "some"
            else:
                amount_desc = "plenty of"
        else:
            # More precise with better skill
            amount_desc = f"about {effective_amount} units of"
        
        caller.msg(f"Your search reveals {amount_desc} {self.resource_type} available here.")
        
        # Small skill gain for searching
        if skill_required and skill_level < 100:
            if random.random() < 0.3:  # 30% chance
                caller.improve_skill(skill_required, 1)


class CmdLight(Command):
    """
    Light or extinguish a light source.
    
    Usage:
        light <object>
        extinguish <object>
        
    Examples:
        light torch
        extinguish lantern
        
    Light sources help you see better in dark conditions.
    They reveal more objects and increase visibility range.
    """
    
    key = "light"
    aliases = ["extinguish", "douse", "ignite"]
    locks = "cmd:all()"
    help_category = "General"
    
    def func(self):
        """Execute the light command."""
        caller = self.caller
        
        if not self.args:
            caller.msg(f"What do you want to {self.cmdstring}?")
            return
        
        # Find the target
        target = caller.search(self.args, location=caller)
        if not target:
            return
        
        # Check if it's a light source
        if not target.db.is_light_source:
            caller.msg(f"{target.get_display_name(caller)} is not a light source.")
            return
        
        # Determine action
        if self.cmdstring in ["light", "ignite"]:
            # Try to light it
            if hasattr(target, 'do_light'):
                target.do_light(caller)
            else:
                # Generic lighting
                if target.db.light_active:
                    caller.msg(f"{target.get_display_name(caller)} is already lit.")
                else:
                    target.toggle_light()
                    caller.msg(f"You light {target.get_display_name(caller)}.")
                    caller.location.msg_contents(
                        f"{caller.name} lights {target.get_display_name(caller)}.",
                        exclude=caller
                    )
        else:
            # Try to extinguish it
            if hasattr(target, 'do_extinguish'):
                target.do_extinguish(caller)
            else:
                # Generic extinguishing
                if not target.db.light_active:
                    caller.msg(f"{target.get_display_name(caller)} is not lit.")
                else:
                    target.toggle_light()
                    caller.msg(f"You extinguish {target.get_display_name(caller)}.")
                    caller.location.msg_contents(
                        f"{caller.name} extinguishes {target.get_display_name(caller)}.",
                        exclude=caller
                    )
</file>

<file path="commands/survival_commands.py">
# commands/survival_commands.py
"""
Survival-related commands for managing character needs.

These commands allow players to manage their survival traits
like hunger, thirst, and fatigue, with cooldown integration.
"""

from evennia import Command
from evennia.utils import delay
import random


class CmdRest(Command):
    """
    Rest to recover fatigue.
    
    Usage:
        rest
        rest <duration>
        
    Examples:
        rest           - Rest for a standard period
        rest long      - Take an extended rest
        rest short     - Take a quick power nap
        
    Resting helps recover fatigue but makes you vulnerable.
    You cannot perform other actions while resting.
    
    The effectiveness of rest depends on:
    - Your current shelter (indoor vs outdoor)
    - Weather conditions
    - Your survival skill
    - Whether you have proper bedding
    
    There is a cooldown between rest sessions to prevent
    abuse of the system.
    """
    
    key = "rest"
    aliases = ["sleep", "nap", "recover"]
    locks = "cmd:all()"
    help_category = "Survival"
    
    def parse(self):
        """Parse rest duration."""
        self.duration = self.args.strip().lower() if self.args else "normal"
    
    def func(self):
        """Execute the rest command."""
        caller = self.caller
        location = caller.location
        
        # Check if already resting
        if caller.db.is_resting:
            caller.msg("You are already resting.")
            return
        
        # Check cooldown
        if not caller.cooldowns.ready("rest"):
            time_left = caller.cooldowns.time_left("rest", use_int=True)
            caller.msg(f"|yYou are not tired enough to rest again. "
                      f"Wait {time_left} more seconds.|n")
            return
        
        # Check current fatigue
        fatigue_value, fatigue_desc = caller.get_trait_status("fatigue")
        if fatigue_value >= 95:
            caller.msg("You are already fully rested.")
            return
        
        # Determine rest duration and recovery
        duration_map = {
            "short": {"time": 30, "recovery": 15, "desc": "a quick nap"},
            "normal": {"time": 60, "recovery": 30, "desc": "a good rest"},
            "long": {"time": 120, "recovery": 50, "desc": "a long sleep"}
        }
        
        rest_info = duration_map.get(self.duration, duration_map["normal"])
        rest_time = rest_info["time"]
        base_recovery = rest_info["recovery"]
        
        # Calculate recovery bonuses
        recovery_bonus = 0
        
        # Indoor bonus
        if location.db.indoor:
            recovery_bonus += 10
            bonus_msg = "The shelter helps you rest better."
        else:
            bonus_msg = ""
        
        # Weather penalties
        weather = location.get_current_weather()
        if "storm" in weather:
            recovery_bonus -= 20
            bonus_msg = "The storm makes it hard to rest properly."
        elif "rain" in weather:
            recovery_bonus -= 10
            bonus_msg = "The rain disturbs your rest."
        
        # Survival skill bonus
        survival_skill = caller.skills.survival.value
        skill_bonus = survival_skill // 4  # Up to +25 at max skill
        recovery_bonus += skill_bonus
        
        # Total recovery
        total_recovery = max(5, base_recovery + recovery_bonus)
        
        # Set resting state
        caller.db.is_resting = True
        
        # Messages
        caller.msg(f"|cYou settle down for {rest_info['desc']}.|n")
        if bonus_msg:
            caller.msg(f"|x{bonus_msg}|n")
            
        location.msg_contents(
            f"{caller.name} settles down to rest.",
            exclude=caller
        )
        
        # Delayed recovery
        def finish_rest():
            if caller.db.is_resting:
                caller.db.is_resting = False
                caller.modify_trait("fatigue", total_recovery)
                new_fatigue, new_desc = caller.get_trait_status("fatigue")
                
                caller.msg(f"|gYou finish resting and feel {new_desc}.|n")
                caller.msg(f"|xFatigue recovered: +{total_recovery}|n")
                
                location.msg_contents(
                    f"{caller.name} gets up from resting.",
                    exclude=caller
                )
                
                # Apply cooldown
                base_cooldown = 180  # 3 minutes base
                actual_cooldown = caller.apply_cooldown("rest", base_cooldown, "survival")
                
                if skill_bonus > 0:
                    caller.msg("|xYour survival skills help you rest more efficiently.|n")
        
        # Use delay to simulate rest time
        delay(rest_time, finish_rest)
        
        # Inform about duration
        caller.msg(f"|xYou will rest for {rest_time} seconds...|n")


class CmdEat(Command):
    """
    Eat food to reduce hunger.
    
    Usage:
        eat <food>
        
    Examples:
        eat bread
        eat berries
        
    Eating food restores your hunger level. Different foods
    provide different amounts of nutrition. Cooked food is
    generally more nutritious than raw ingredients.
    
    You can only eat when you're actually hungry to prevent
    food waste.
    """
    
    key = "eat"
    aliases = ["consume"]
    locks = "cmd:all()"
    help_category = "Survival"
    
    def func(self):
        """Execute the eat command."""
        caller = self.caller
        
        if not self.args:
            caller.msg("Eat what?")
            return
        
        # Find the food item
        food = caller.search(self.args, location=caller)
        if not food:
            return
        
        # Check if it's edible
        if not food.tags.has("food", category="item_type"):
            caller.msg(f"You can't eat {food.get_display_name(caller)}.")
            return
        
        # Check hunger level
        hunger_value, hunger_desc = caller.get_trait_status("hunger")
        if hunger_value >= 90:
            caller.msg("You're too full to eat anything right now.")
            return
        
        # Get nutrition value
        nutrition = food.db.nutrition or 10
        
        # Apply to hunger
        caller.modify_trait("hunger", nutrition)
        new_hunger, new_desc = caller.get_trait_status("hunger")
        
        # Message
        caller.msg(f"|gYou eat {food.get_display_name(caller)}.|n")
        caller.msg(f"|xYou feel {new_desc}. (Hunger +{nutrition})|n")
        
        caller.location.msg_contents(
            f"{caller.name} eats {food.get_display_name(caller)}.",
            exclude=caller
        )
        
        # Consume the food
        food.delete()
        
        # No cooldown on eating, but limited by hunger level


class CmdDrink(Command):
    """
    Drink water to reduce thirst.
    
    Usage:
        drink <liquid>
        drink from <source>
        
    Examples:
        drink water
        drink from stream
        
    Drinking restores your thirst level. Clean water is more
    effective than other liquids. Some water sources may
    require purification.
    """
    
    key = "drink"
    locks = "cmd:all()"
    help_category = "Survival"
    
    def func(self):
        """Execute the drink command."""
        caller = self.caller
        
        if not self.args:
            caller.msg("Drink what?")
            return
        
        # Parse "from" syntax
        args = self.args.strip()
        if " from " in args:
            _, source = args.split(" from ", 1)
            # Look for water source in room
            water_source = caller.search(source, location=caller.location)
            if water_source and water_source.tags.has("water_source"):
                self.drink_from_source(water_source)
                return
        
        # Otherwise look for water item
        water = caller.search(args, location=caller)
        if not water:
            return
        
        # Check if it's drinkable
        if not water.tags.has("drink", category="item_type"):
            caller.msg(f"You can't drink {water.get_display_name(caller)}.")
            return
        
        # Check thirst level
        thirst_value, thirst_desc = caller.get_trait_status("thirst")
        if thirst_value >= 90:
            caller.msg("You're not thirsty right now.")
            return
        
        # Get thirst value
        thirst_restore = water.db.thirst_value or 20
        
        # Apply to thirst
        caller.modify_trait("thirst", thirst_restore)
        new_thirst, new_desc = caller.get_trait_status("thirst")
        
        # Message
        caller.msg(f"|gYou drink {water.get_display_name(caller)}.|n")
        caller.msg(f"|xYou feel {new_desc}. (Thirst +{thirst_restore})|n")
        
        caller.location.msg_contents(
            f"{caller.name} drinks {water.get_display_name(caller)}.",
            exclude=caller
        )
        
        # Consume the water
        water.delete()
    
    def drink_from_source(self, source):
        """Drink directly from a water source."""
        caller = self.caller
        
        # Check thirst
        thirst_value, thirst_desc = caller.get_trait_status("thirst")
        if thirst_value >= 90:
            caller.msg("You're not thirsty right now.")
            return
        
        # Direct drinking is less effective than purified water
        thirst_restore = 15
        
        # Risk of illness without purification
        if random.random() < 0.1:  # 10% chance
            caller.msg("|yThe water tastes a bit off...|n")
            # Future: Apply illness effect
        
        # Apply thirst restoration
        caller.modify_trait("thirst", thirst_restore)
        new_thirst, new_desc = caller.get_trait_status("thirst")
        
        caller.msg(f"|gYou drink from {source.get_display_name(caller)}.|n")
        caller.msg(f"|xYou feel {new_desc}. (Thirst +{thirst_restore})|n")
        
        caller.location.msg_contents(
            f"{caller.name} drinks from {source.get_display_name(caller)}.",
            exclude=caller
        )


class CmdStatus(Command):
    """
    Check your survival status and cooldowns.
    
    Usage:
        status
        status full
        
    This command shows your current survival traits (hunger,
    thirst, fatigue, health) as well as any active cooldowns.
    
    Use 'status full' to see all your stats and skills as well.
    """
    
    key = "status"
    aliases = ["stats", "condition"]
    locks = "cmd:all()"
    help_category = "Survival"
    
    def func(self):
        """Display character status."""
        caller = self.caller
        show_full = self.args.strip().lower() == "full"
        
        # Header
        caller.msg("|w===== Character Status =====|n")
        
        # Survival traits
        caller.msg("\n|wSurvival Needs:|n")
        caller.msg(caller.get_survival_summary())
        
        # Active cooldowns
        cooldowns = []
        for cd_name in ["gather", "forage", "rest", "craft", "trade"]:
            if not caller.cooldowns.ready(cd_name):
                time_left = caller.cooldowns.time_left(cd_name, use_int=True)
                cooldowns.append(f"{cd_name}: {time_left}s")
        
        if cooldowns:
            caller.msg("\n|wActive Cooldowns:|n")
            for cd in cooldowns:
                caller.msg(f"  |y{cd}|n")
        else:
            caller.msg("\n|wActive Cooldowns:|n None")
        
        # Environmental conditions
        if caller.location:
            caller.msg("\n|wEnvironmental Conditions:|n")
            
            # Temperature/warmth
            warmth = caller.get_total_warmth()
            season = caller.location.get_season()
            if season == "winter" and warmth < 20:
                caller.msg("  |rYou are cold! (Warmth: {warmth})|n")
            elif season == "summer" and warmth > 30:
                caller.msg("  |yYou are too warm. (Warmth: {warmth})|n")
            else:
                caller.msg(f"  |gTemperature is comfortable. (Warmth: {warmth})|n")
            
            # Weather protection
            weather = caller.location.get_current_weather()
            if "rain" in weather:
                if caller.has_weather_protection("rain"):
                    caller.msg("  |gYou are protected from the rain.|n")
                else:
                    caller.msg("  |yYou are getting wet from the rain.|n")
        
        # Full status includes stats and skills
        if show_full:
            # Stats
            caller.msg("\n|wAttributes:|n")
            for stat_name in ["strength", "dexterity", "constitution",
                            "intelligence", "wisdom", "charisma"]:
                value = caller.get_stat(stat_name)
                caller.msg(f"  {stat_name.title()}: {value}")
            
            # Skills
            caller.msg("\n|wSkills:|n")
            caller.msg(caller.get_skill_summary())
</file>

<file path="commands/time_commands.py">
# commands/time_commands.py
"""
Time-related commands for the Fantasy Steampunk MUD.

This module contains commands that interact with the custom gametime system,
allowing players to check the current time, date, and season.
"""

from evennia import Command
from evennia.contrib.base_systems import custom_gametime
from django.conf import settings


class CmdTime(Command):
    """
    Display the current game time and date.
    
    Usage:
        time
        
    This command shows:
    - Current time of day
    - Day of the month
    - Current month and season
    - Current year
    - Real time to game time conversion info
    
    Example output:
        It is evening on the 15th day of Bloomheart, in the year 850.
        The season is spring, and the air carries the scent of new growth.
        
        (OOC: Game time moves at 4x speed. 1 real hour = 4 game hours)
    """
    
    key = "time"
    aliases = ["date", "calendar"]
    locks = "cmd:all()"
    help_category = "General"
    
    def func(self):
        """Execute the time command."""
        # Get the current game time as a tuple
        year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
        
        # Calculate derived values
        month_name = self._get_month_name(month)
        season = self._get_season(month)
        time_of_day = self._get_time_of_day(hour)
        day_suffix = self._get_day_suffix(day + 1)  # Days start from 0 internally
        
        # Build the main time message
        time_msg = (
            f"|yIt is {time_of_day} on the {day + 1}{day_suffix} day of "
            f"{month_name}, in the year {year}.|n"
        )
        
        # Add seasonal flavor text
        season_msg = self._get_season_description(season)
        
        # Add OOC information about time conversion
        ooc_msg = (
            f"\n|w(OOC: Game time moves at {settings.TIME_FACTOR}x speed. "
            f"1 real hour = {settings.TIME_FACTOR} game hours)|n"
        )
        
        # Send the complete message
        self.caller.msg(time_msg + "\n" + season_msg + ooc_msg)
        
        # Optionally show exact time for those who want it
        if "exact" in self.switches:
            exact_msg = f"\n|wExact time: {hour:02d}:{minute:02d}:{second:02d}|n"
            self.caller.msg(exact_msg)
    
    def _get_month_name(self, month_index):
        """Get the fantasy name for a month."""
        try:
            return settings.MONTH_NAMES[month_index]
        except (AttributeError, IndexError):
            return f"Month {month_index + 1}"
    
    def _get_season(self, month_index):
        """Determine the current season based on month."""
        for season, months in settings.SEASONS.items():
            if month_index in months:
                return season
        return "unknown"
    
    def _get_time_of_day(self, hour):
        """Get a descriptive name for the time of day."""
        for time_name, (start, end) in settings.TIME_OF_DAY.items():
            if time_name == "night":
                # Special handling for night (crosses midnight)
                if hour >= start or hour < end:
                    return time_name
            else:
                if start <= hour < end:
                    return time_name
        return f"{hour:02d}:00"
    
    def _get_day_suffix(self, day):
        """Get the appropriate suffix for a day number (1st, 2nd, 3rd, etc)."""
        if 10 <= day % 100 <= 20:
            suffix = 'th'
        else:
            suffix = {1: 'st', 2: 'nd', 3: 'rd'}.get(day % 10, 'th')
        return suffix
    
    def _get_season_description(self, season):
        """Return flavor text based on the current season."""
        descriptions = {
            "winter": "|CThe season is winter, and frost covers the land in a crystalline blanket.|n",
            "spring": "|GThe season is spring, and the air carries the scent of new growth.|n",
            "summer": "|YThe season is summer, with warm winds carrying the buzz of industry.|n",
            "autumn": "|rThe season is autumn, as leaves turn to copper and gold.|n",
            "unknown": "|xThe season turns, marking the passage of time.|n"
        }
        return descriptions.get(season, descriptions["unknown"])


class CmdUptime(Command):
    """
    Show how long the game has been running.
    
    Usage:
        uptime
        
    This shows both real time and game time that has passed since
    the server started.
    """
    
    key = "uptime"
    locks = "cmd:all()"
    help_category = "General"
    
    def func(self):
        """Execute the uptime command."""
        from evennia.utils import gametime
        
        # Get the real uptime in seconds
        real_uptime_secs = gametime.uptime()
        game_uptime_secs = real_uptime_secs * settings.TIME_FACTOR
        
        # Convert to readable format
        real_time_str = self._format_time(real_uptime_secs)
        game_time_str = self._format_time(game_uptime_secs)
        
        msg = (
            f"|yServer Uptime:|n\n"
            f"Real time: {real_time_str}\n"
            f"Game time: {game_time_str} (at {settings.TIME_FACTOR}x speed)"
        )
        
        self.caller.msg(msg)
    
    def _format_time(self, seconds):
        """Format seconds into a readable string."""
        days = int(seconds // 86400)
        hours = int((seconds % 86400) // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        
        parts = []
        if days > 0:
            parts.append(f"{days} day{'s' if days != 1 else ''}")
        if hours > 0:
            parts.append(f"{hours} hour{'s' if hours != 1 else ''}")
        if minutes > 0:
            parts.append(f"{minutes} minute{'s' if minutes != 1 else ''}")
        if secs > 0 or not parts:
            parts.append(f"{secs} second{'s' if secs != 1 else ''}")
        
        return ", ".join(parts)
</file>

<file path="server/conf/__init__.py">
# -*- coding: utf-8 -*-
</file>

<file path="server/conf/at_initial_setup.py">
"""
At_initial_setup module template

Custom at_initial_setup method. This allows you to hook special
modifications to the initial server startup process. Note that this
will only be run once - when the server starts up for the very first
time! It is called last in the startup process and can thus be used to
overload things that happened before it.

The module must contain a global function at_initial_setup().  This
will be called without arguments. Note that tracebacks in this module
will be QUIETLY ignored, so make sure to check it well to make sure it
does what you expect it to.

"""


def at_initial_setup():
    pass
</file>

<file path="server/conf/at_search.py">
"""
Search and multimatch handling

This module allows for overloading two functions used by Evennia's
search functionality:

    at_search_result:
        This is called whenever a result is returned from an object
        search (a common operation in commands).  It should (together
        with at_multimatch_input below) define some way to present and
        differentiate between multiple matches (by default these are
        presented as 1-ball, 2-ball etc)
    at_multimatch_input:
        This is called with a search term and should be able to
        identify if the user wants to separate a multimatch-result
        (such as that from a previous search). By default, this
        function understands input on the form 1-ball, 2-ball etc as
        indicating that the 1st or 2nd match for "ball" should be
        used.

This module is not called by default, to use it, add the following
line to your settings file:

    SEARCH_AT_RESULT = "server.conf.at_search.at_search_result"

"""


def at_search_result(matches, caller, query="", quiet=False, **kwargs):
    """
    This is a generic hook for handling all processing of a search
    result, including error reporting.

    Args:
        matches (list): This is a list of 0, 1 or more typeclass instances,
            the matched result of the search. If 0, a nomatch error should
            be echoed, and if >1, multimatch errors should be given. Only
            if a single match should the result pass through.
        caller (Object): The object performing the search and/or which should
        receive error messages.
    query (str, optional): The search query used to produce `matches`.
        quiet (bool, optional): If `True`, no messages will be echoed to caller
            on errors.

    Keyword Args:
        nofound_string (str): Replacement string to echo on a notfound error.
        multimatch_string (str): Replacement string to echo on a multimatch error.

    Returns:
        processed_result (Object or None): This is always a single result
            or `None`. If `None`, any error reporting/handling should
            already have happened.

    """
</file>

<file path="server/conf/at_server_startstop.py">
"""
Server startstop hooks

This module contains functions called by Evennia at various
points during its startup, reload and shutdown sequence. It
allows for customizing the server operation as desired.

This module must contain at least these global functions:

at_server_init()
at_server_start()
at_server_stop()
at_server_reload_start()
at_server_reload_stop()
at_server_cold_start()
at_server_cold_stop()

"""


def at_server_init():
    """
    This is called first as the server is starting up, regardless of how.
    """
    pass


def at_server_start():
    """
    This is called every time the server starts up, regardless of
    how it was shut down.
    """
    pass


def at_server_stop():
    """
    This is called just before the server is shut down, regardless
    of it is for a reload, reset or shutdown.
    """
    pass


def at_server_reload_start():
    """
    This is called only when server starts back up after a reload.
    """
    pass


def at_server_reload_stop():
    """
    This is called only time the server stops before a reload.
    """
    pass


def at_server_cold_start():
    """
    This is called only when the server starts "cold", i.e. after a
    shutdown or a reset.
    """
    pass


def at_server_cold_stop():
    """
    This is called only when the server goes down due to a shutdown or
    reset.
    """
    pass
</file>

<file path="server/conf/cmdparser.py">
"""
Changing the default command parser

The cmdparser is responsible for parsing the raw text inserted by the
user, identifying which command/commands match and return one or more
matching command objects. It is called by Evennia's cmdhandler and
must accept input and return results on the same form. The default
handler is very generic so you usually don't need to overload this
unless you have very exotic parsing needs; advanced parsing is best
done at the Command.parse level.

The default cmdparser understands the following command combinations
(where [] marks optional parts.)

[cmdname[ cmdname2 cmdname3 ...] [the rest]

A command may consist of any number of space-separated words of any
length, and contain any character. It may also be empty.

The parser makes use of the cmdset to find command candidates. The
parser return a list of matches. Each match is a tuple with its first
three elements being the parsed cmdname (lower case), the remaining
arguments, and the matched cmdobject from the cmdset.


This module is not accessed by default. To tell Evennia to use it
instead of the default command parser, add the following line to
your settings file:

    COMMAND_PARSER = "server.conf.cmdparser.cmdparser"

"""


def cmdparser(raw_string, cmdset, caller, match_index=None):
    """
    This function is called by the cmdhandler once it has
    gathered and merged all valid cmdsets valid for this particular parsing.

    raw_string - the unparsed text entered by the caller.
    cmdset - the merged, currently valid cmdset
    caller - the caller triggering this parsing
    match_index - an optional integer index to pick a given match in a
                  list of same-named command matches.

    Returns:
     list of tuples: [(cmdname, args, cmdobj, cmdlen, mratio), ...]
            where cmdname is the matching command name and args is
            everything not included in the cmdname. Cmdobj is the actual
            command instance taken from the cmdset, cmdlen is the length
            of the command name and the mratio is some quality value to
            (possibly) separate multiple matches.

    """
    # Your implementation here
</file>

<file path="server/conf/connection_screens.py">
# -*- coding: utf-8 -*-
"""
Connection screen

This is the text to show the user when they first connect to the game (before
they log in).

To change the login screen in this module, do one of the following:

- Define a function `connection_screen()`, taking no arguments. This will be
  called first and must return the full string to act as the connection screen.
  This can be used to produce more dynamic screens.
- Alternatively, define a string variable in the outermost scope of this module
  with the connection string that should be displayed. If more than one such
  variable is given, Evennia will pick one of them at random.

The commands available to the user when the connection screen is shown
are defined in evennia.default_cmds.UnloggedinCmdSet. The parsing and display
of the screen is done by the unlogged-in "look" command.

"""

from django.conf import settings

from evennia import utils

CONNECTION_SCREEN = """
|b==============================================================|n
 Welcome to |g{}|n, version {}!

 If you have an existing account, connect to it by typing:
      |wconnect <username> <password>|n
 If you need to create an account, type (without the <>'s):
      |wcreate <username> <password>|n

 If you have spaces in your username, enclose it in quotes.
 Enter |whelp|n for more info. |wlook|n will re-show this screen.
|b==============================================================|n""".format(
    settings.SERVERNAME, utils.get_evennia_version("short")
)
</file>

<file path="server/conf/inlinefuncs.py">
"""
Outgoing callables to apply with the FuncParser on outgoing messages.

The functions in this module will become available as $funcname(args, kwargs)
in all outgoing strings if you add

    FUNCPARSER_PARSE_OUTGOING_MESSAGES_ENABLED = True

to your settings file. The default inlinefuncs are found at the bottom of
`evennia.utils.funcparser`.

In text, usage is straightforward:

$funcname(arg1, arg2, ..., key=val, key2=val2, ...)

Example 1 (using the "pad" inlinefunc):
    say This is $pad("a center-padded text", 50,c,-) of width 50.
    ->
    John says, "This is -------------- a center-padded text--------------- of width 50."

Example 2 (using nested "pad" and "time" inlinefuncs):
    say The time is $pad($time(), 30)right now.
    ->
    John says, "The time is         Oct 25, 11:09         right now."

To add more inline functions, add them to this module, using
the following call signature:

    def funcname(*args, **kwargs)
        ...

"""

# def capitalize(*args, **kwargs):
#    "Silly capitalize example. Used as  $capitalize
#    if not args:
#        return ''
#    session = kwargs.get("session")
#    return args[0].capitalize()
</file>

<file path="server/conf/inputfuncs.py">
"""
Input functions

Input functions are always called from the client (they handle server
input, hence the name).

This module is loaded by being included in the
`settings.INPUT_FUNC_MODULES` tuple.

All *global functions* included in this module are considered
input-handler functions and can be called by the client to handle
input.

An input function must have the following call signature:

    cmdname(session, *args, **kwargs)

Where session will be the active session and *args, **kwargs are extra
incoming arguments and keyword properties.

A special command is the "default" command, which is will be called
when no other cmdname matches. It also receives the non-found cmdname
as argument.

    default(session, cmdname, *args, **kwargs)

"""

# def oob_echo(session, *args, **kwargs):
#     """
#     Example echo function. Echoes args, kwargs sent to it.
#
#     Args:
#         session (Session): The Session to receive the echo.
#         args (list of str): Echo text.
#         kwargs (dict of str, optional): Keyed echo text
#
#     """
#     session.msg(oob=("echo", args, kwargs))
#
#
# def default(session, cmdname, *args, **kwargs):
#     """
#     Handles commands without a matching inputhandler func.
#
#     Args:
#         session (Session): The active Session.
#         cmdname (str): The (unmatched) command name
#         args, kwargs (any): Arguments to function.
#
#     """
#     pass
</file>

<file path="server/conf/lockfuncs.py">
"""

Lockfuncs

Lock functions are functions available when defining lock strings,
which in turn limits access to various game systems.

All functions defined globally in this module are assumed to be
available for use in lockstrings to determine access. See the
Evennia documentation for more info on locks.

A lock function is always called with two arguments, accessing_obj and
accessed_obj, followed by any number of arguments. All possible
arguments should be handled with *args, **kwargs. The lock function
should handle all eventual tracebacks by logging the error and
returning False.

Lock functions in this module extend (and will overload same-named)
lock functions from evennia.locks.lockfuncs.

"""

# def myfalse(accessing_obj, accessed_obj, *args, **kwargs):
#    """
#    called in lockstring with myfalse().
#    A simple logger that always returns false. Prints to stdout
#    for simplicity, should use utils.logger for real operation.
#    """
#    print "%s tried to access %s. Access denied." % (accessing_obj, accessed_obj)
#    return False
</file>

<file path="server/conf/mssp.py">
"""

MSSP (Mud Server Status Protocol) meta information

Modify this file to specify what MUD listing sites will report about your game.
All fields are static. The number of currently active players and your game's
current uptime will be added automatically by Evennia.

You don't have to fill in everything (and most fields are not shown/used by all
crawlers anyway); leave the default if so needed. You need to reload the server
before the updated information is made available to crawlers (reloading does
not affect uptime).

After changing the values in this file, you must register your game with the
MUD website list you want to track you. The listing crawler will then regularly
connect to your server to get the latest info. No further configuration is
needed on the Evennia side.

"""

MSSPTable = {
    # Required fields
    "NAME": "Mygame",  # usually the same as SERVERNAME
    # Generic
    "CRAWL DELAY": "-1",  # limit how often crawler may update the listing. -1 for no limit
    "HOSTNAME": "",  # telnet hostname
    "PORT": ["4000"],  # telnet port - most important port should be *last* in list!
    "CODEBASE": "Evennia",
    "CONTACT": "",  # email for contacting the mud
    "CREATED": "",  # year MUD was created
    "ICON": "",  # url to icon 32x32 or larger; <32kb.
    "IP": "",  # current or new IP address
    "LANGUAGE": "",  # name of language used, e.g. English
    "LOCATION": "",  # full English name of server country
    "MINIMUM AGE": "0",  # set to 0 if not applicable
    "WEBSITE": "",  # http:// address to your game website
    # Categorisation
    "FAMILY": "Evennia",
    "GENRE": "None",  # Adult, Fantasy, Historical, Horror, Modern, None, or Science Fiction
    # Gameplay: Adventure, Educational, Hack and Slash, None,
    # Player versus Player, Player versus Environment,
    # Roleplaying, Simulation, Social or Strategy
    "GAMEPLAY": "",
    "STATUS": "Open Beta",  # Allowed: Alpha, Closed Beta, Open Beta, Live
    "GAMESYSTEM": "Custom",  # D&D, d20 System, World of Darkness, etc. Use Custom if homebrew
    # Subgenre: LASG, Medieval Fantasy, World War II, Frankenstein,
    # Cyberpunk, Dragonlance, etc. Or None if not applicable.
    "SUBGENRE": "None",
    # World
    "AREAS": "0",
    "HELPFILES": "0",
    "MOBILES": "0",
    "OBJECTS": "0",
    "ROOMS": "0",  # use 0 if room-less
    "CLASSES": "0",  # use 0 if class-less
    "LEVELS": "0",  # use 0 if level-less
    "RACES": "0",  # use 0 if race-less
    "SKILLS": "0",  # use 0 if skill-less
    # Protocols set to 1 or 0; should usually not be changed)
    "ANSI": "1",
    "GMCP": "1",
    "MSDP": "1",
    "MXP": "1",
    "SSL": "1",
    "UTF-8": "1",
    "MCCP": "1",
    "XTERM 256 COLORS": "1",
    "XTERM TRUE COLORS": "0",
    "ATCP": "0",
    "MCP": "0",
    "MSP": "0",
    "VT100": "0",
    "PUEBLO": "0",
    "ZMP": "0",
    # Commercial set to 1 or 0)
    "PAY TO PLAY": "0",
    "PAY FOR PERKS": "0",
    # Hiring  set to 1 or 0)
    "HIRING BUILDERS": "0",
    "HIRING CODERS": "0",
    # Extended variables
    # World
    "DBSIZE": "0",
    "EXITS": "0",
    "EXTRA DESCRIPTIONS": "0",
    "MUDPROGS": "0",
    "MUDTRIGS": "0",
    "RESETS": "0",
    # Game  (set to 1 or 0, or one of the given alternatives)
    "ADULT MATERIAL": "0",
    "MULTICLASSING": "0",
    "NEWBIE FRIENDLY": "0",
    "PLAYER CITIES": "0",
    "PLAYER CLANS": "0",
    "PLAYER CRAFTING": "0",
    "PLAYER GUILDS": "0",
    "EQUIPMENT SYSTEM": "None",  # "None", "Level", "Skill", "Both"
    "MULTIPLAYING": "None",  # "None", "Restricted", "Full"
    "PLAYERKILLING": "None",  # "None", "Restricted", "Full"
    "QUEST SYSTEM": "None",  # "None", "Immortal Run", "Automated", "Integrated"
    "ROLEPLAYING": "None",  # "None", "Accepted", "Encouraged", "Enforced"
    "TRAINING SYSTEM": "None",  # "None", "Level", "Skill", "Both"
    # World originality: "All Stock", "Mostly Stock", "Mostly Original", "All Original"
    "WORLD ORIGINALITY": "All Original",
}
</file>

<file path="server/conf/portal_services_plugins.py">
"""
Start plugin services

This plugin module can define user-created services for the Portal to
start.

This module must handle all imports and setups required to start
twisted services (see examples in evennia.server.portal.portal). It
must also contain a function start_plugin_services(application).
Evennia will call this function with the main Portal application (so
your services can be added to it). The function should not return
anything. Plugin services are started last in the Portal startup
process.

"""


def start_plugin_services(portal):
    """
    This hook is called by Evennia, last in the Portal startup process.

    portal - a reference to the main portal application.
    """
    pass
</file>

<file path="server/conf/server_services_plugins.py">
"""

Server plugin services

This plugin module can define user-created services for the Server to
start.

This module must handle all imports and setups required to start a
twisted service (see examples in evennia.server.server). It must also
contain a function start_plugin_services(application). Evennia will
call this function with the main Server application (so your services
can be added to it). The function should not return anything. Plugin
services are started last in the Server startup process.

"""


def start_plugin_services(server):
    """
    This hook is called by Evennia, last in the Server startup process.

    server - a reference to the main server application.
    """
    pass
</file>

<file path="server/conf/serversession.py">
"""
ServerSession

The serversession is the Server-side in-memory representation of a
user connecting to the game.  Evennia manages one Session per
connection to the game. So a user logged into the game with multiple
clients (if Evennia is configured to allow that) will have multiple
sessions tied to one Account object. All communication between Evennia
and the real-world user goes through the Session(s) associated with that user.

It should be noted that modifying the Session object is not usually
necessary except for the most custom and exotic designs - and even
then it might be enough to just add custom session-level commands to
the SessionCmdSet instead.

This module is not normally called. To tell Evennia to use the class
in this module instead of the default one, add the following to your
settings file:

    SERVER_SESSION_CLASS = "server.conf.serversession.ServerSession"

"""

from evennia.server.serversession import ServerSession as BaseServerSession


class ServerSession(BaseServerSession):
    """
    This class represents a player's session and is a template for
    individual protocols to communicate with Evennia.

    Each account gets one or more sessions assigned to them whenever they connect
    to the game server. All communication between game and account goes
    through their session(s).
    """

    pass
</file>

<file path="server/conf/web_plugins.py">
"""
Web plugin hooks.
"""


def at_webserver_root_creation(web_root):
    """
    This is called as the web server has finished building its default
    path tree. At this point, the media/ and static/ URIs have already
    been added to the web root.

    Args:
        web_root (twisted.web.resource.Resource): The root
            resource of the URI tree. Use .putChild() to
            add new subdomains to the tree.

    Returns:
        web_root (twisted.web.resource.Resource): The potentially
            modified root structure.

    Example:
        from twisted.web import static
        my_page = static.File("web/mypage/")
        my_page.indexNames = ["index.html"]
        web_root.putChild("mypage", my_page)

    """
    return web_root


def at_webproxy_root_creation(web_root):
    """
    This function can modify the portal proxy service.
    Args:
        web_root (evennia.server.webserver.Website): The Evennia
            Website application. Use .putChild() to add new
            subdomains that are Portal-accessible over TCP;
            primarily for new protocol development, but suitable
            for other shenanigans.
    """
    return web_root
</file>

<file path="server/logs/README.md">
This directory contains Evennia's log files. The existence of this README.md file is also necessary
to correctly include the log directory in git (since log files are ignored by git and you can't
commit an empty directory).

`server.log` - log file from the game Server.
`portal.log` - log file from Portal proxy (internet facing)

Usually these logs are viewed together with `evennia -l`. They are also rotated every week so as not
to be too big. Older log names will have a name appended by `_month_date`.

`lockwarnings.log` - warnings from the lock system.
`http_requests.log` - this will generally be empty unless turning on debugging inside the server.

`channel_<channelname>.log` - these are channel logs for the in-game channels They are also used
by the `/history` flag in-game to get the latest message history.
</file>

<file path="server/__init__.py">
# -*- coding: utf-8 -*-
</file>

<file path="server/README.md">
# server/ 

This directory holds files used by and configuring the Evennia server 
itself.

Out of all the subdirectories in the game directory, Evennia does
expect this directory to exist, so you should normally not delete,
rename or change its folder structure.

When running you will find four new files appear in this directory: 

 - `server.pid` and `portal.pid`: These hold the process IDs of the
   Portal and Server, so that they can be managed by the launcher. If
   Evennia is shut down uncleanly (e.g. by a crash or via a kill
   signal), these files might erroneously remain behind. If so Evennia
   will tell you they are "stale" and they can be deleted manually.
 - `server.restart` and `portal.restart`: These hold flags to tell the
   server processes if it should die or start again. You never need to
   modify those files.
 - `evennia.db3`: This will only appear if you are using the default
   SQLite3 database; it a binary file that holds the entire game
   database; deleting this file will effectively reset the game for
   you and you can start fresh with `evennia migrate` (useful during
   development).  

## server/conf/

This subdirectory holds the configuration modules for the server. With
them you can change how Evennia operates and also plug in your own
functionality to replace the default. You usually need to restart the
server to apply changes done here. The most important file is the file
`settings.py` which is the main configuration file of Evennia. 

## server/logs/

This subdirectory holds various log files created by the running
Evennia server. It is also the default location for storing any custom
log files you might want to output using Evennia's logging mechanisms.
</file>

<file path="typeclasses/accounts.py">
"""
Account

The Account represents the game "account" and each login has only one
Account object. An Account is what chats on default channels but has no
other in-game-world existence. Rather the Account puppets Objects (such
as Characters) in order to actually participate in the game world.


Guest

Guest accounts are simple low-level accounts that are created/deleted
on the fly and allows users to test the game without the commitment
of a full registration. Guest accounts are deactivated by default; to
activate them, add the following line to your settings file:

    GUEST_ENABLED = True

You will also need to modify the connection screen to reflect the
possibility to connect with a guest account. The setting file accepts
several more options for customizing the Guest account system.

"""

from evennia.accounts.accounts import DefaultAccount, DefaultGuest


class Account(DefaultAccount):
    """
    An Account is the actual OOC player entity. It doesn't exist in the game,
    but puppets characters.

    This is the base Typeclass for all Accounts. Accounts represent
    the person playing the game and tracks account info, password
    etc. They are OOC entities without presence in-game. An Account
    can connect to a Character Object in order to "enter" the
    game.

    Account Typeclass API:

    * Available properties (only available on initiated typeclass objects)

     - key (string) - name of account
     - name (string)- wrapper for user.username
     - aliases (list of strings) - aliases to the object. Will be saved to
            database as AliasDB entries but returned as strings.
     - dbref (int, read-only) - unique #id-number. Also "id" can be used.
     - date_created (string) - time stamp of object creation
     - permissions (list of strings) - list of permission strings
     - user (User, read-only) - django User authorization object
     - obj (Object) - game object controlled by account. 'character' can also
                     be used.
     - is_superuser (bool, read-only) - if the connected user is a superuser

    * Handlers

     - locks - lock-handler: use locks.add() to add new lock strings
     - db - attribute-handler: store/retrieve database attributes on this
                              self.db.myattr=val, val=self.db.myattr
     - ndb - non-persistent attribute handler: same as db but does not
                                  create a database entry when storing data
     - scripts - script-handler. Add new scripts to object with scripts.add()
     - cmdset - cmdset-handler. Use cmdset.add() to add new cmdsets to object
     - nicks - nick-handler. New nicks with nicks.add().
     - sessions - session-handler. Use session.get() to see all sessions connected, if any
     - options - option-handler. Defaults are taken from settings.OPTIONS_ACCOUNT_DEFAULT
     - characters - handler for listing the account's playable characters

    * Helper methods (check autodocs for full updated listing)

     - msg(text=None, from_obj=None, session=None, options=None, **kwargs)
     - execute_cmd(raw_string)
     - search(searchdata, return_puppet=False, search_object=False, typeclass=None,
                      nofound_string=None, multimatch_string=None, use_nicks=True,
                      quiet=False, **kwargs)
     - is_typeclass(typeclass, exact=False)
     - swap_typeclass(new_typeclass, clean_attributes=False, no_default=True)
     - access(accessing_obj, access_type='read', default=False, no_superuser_bypass=False, **kwargs)
     - check_permstring(permstring)
     - get_cmdsets(caller, current, **kwargs)
     - get_cmdset_providers()
     - uses_screenreader(session=None)
     - get_display_name(looker, **kwargs)
     - get_extra_display_name_info(looker, **kwargs)
     - disconnect_session_from_account()
     - puppet_object(session, obj)
     - unpuppet_object(session)
     - unpuppet_all()
     - get_puppet(session)
     - get_all_puppets()
     - is_banned(**kwargs)
     - get_username_validators(validator_config=settings.AUTH_USERNAME_VALIDATORS)
     - authenticate(username, password, ip="", **kwargs)
     - normalize_username(username)
     - validate_username(username)
     - validate_password(password, account=None)
     - set_password(password, **kwargs)
     - get_character_slots()
     - get_available_character_slots()
     - create_character(*args, **kwargs)
     - create(*args, **kwargs)
     - delete(*args, **kwargs)
     - channel_msg(message, channel, senders=None, **kwargs)
     - idle_time()
     - connection_time()

    * Hook methods

     basetype_setup()
     at_account_creation()

     > note that the following hooks are also found on Objects and are
       usually handled on the character level:

     - at_init()
     - at_first_save()
     - at_access()
     - at_cmdset_get(**kwargs)
     - at_password_change(**kwargs)
     - at_first_login()
     - at_pre_login()
     - at_post_login(session=None)
     - at_failed_login(session, **kwargs)
     - at_disconnect(reason=None, **kwargs)
     - at_post_disconnect(**kwargs)
     - at_message_receive()
     - at_message_send()
     - at_server_reload()
     - at_server_shutdown()
     - at_look(target=None, session=None, **kwargs)
     - at_post_create_character(character, **kwargs)
     - at_post_add_character(char)
     - at_post_remove_character(char)
     - at_pre_channel_msg(message, channel, senders=None, **kwargs)
     - at_post_chnnel_msg(message, channel, senders=None, **kwargs)

    """

    pass


class Guest(DefaultGuest):
    """
    This class is used for guest logins. Unlike Accounts, Guests and their
    characters are deleted after disconnection.
    """

    pass
</file>

<file path="typeclasses/channels.py">
"""
Channel

The channel class represents the out-of-character chat-room usable by
Accounts in-game. It is mostly overloaded to change its appearance, but
channels can be used to implement many different forms of message
distribution systems.

Note that sending data to channels are handled via the CMD_CHANNEL
syscommand (see evennia.syscmds). The sending should normally not need
to be modified.

"""

from evennia.comms.comms import DefaultChannel


class Channel(DefaultChannel):
    r"""
    This is the base class for all Channel Comms. Inherit from this to
    create different types of communication channels.

    Class-level variables:
    - `send_to_online_only` (bool, default True) - if set, will only try to
      send to subscribers that are actually active. This is a useful optimization.
    - `log_file` (str, default `"channel_{channelname}.log"`). This is the
      log file to which the channel history will be saved. The `{channelname}` tag
      will be replaced by the key of the Channel. If an Attribute 'log_file'
      is set, this will be used instead. If this is None and no Attribute is found,
      no history will be saved.
    - `channel_prefix_string` (str, default `"[{channelname} ]"`) - this is used
      as a simple template to get the channel prefix with `.channel_prefix()`. It is used
      in front of every channel message; use `{channelmessage}` token to insert the
      name of the current channel. Set to `None` if you want no prefix (or want to
      handle it in a hook during message generation instead.
    - `channel_msg_nick_pattern`(str, default `"{alias}\s*?|{alias}\s+?(?P<arg1>.+?)") -
      this is what used when a channel subscriber gets a channel nick assigned to this
      channel. The nickhandler uses the pattern to pick out this channel's name from user
      input. The `{alias}` token will get both the channel's key and any set/custom aliases
      per subscriber. You need to allow for an `<arg1>` regex group to catch any message
      that should be send to the  channel. You usually don't need to change this pattern
      unless you are changing channel command-style entirely.
    - `channel_msg_nick_replacement` (str, default `"channel {channelname} = $1"` - this
      is used by the nickhandler to generate a replacement string once the nickhandler (using
      the `channel_msg_nick_pattern`) identifies that the channel should be addressed
      to send a message to it. The `<arg1>` regex pattern match from `channel_msg_nick_pattern`
      will end up at the `$1` position in the replacement. Together, this allows you do e.g.
      'public Hello' and have that become a mapping to `channel public = Hello`. By default,
      the account-level `channel` command is used. If you were to rename that command you must
      tweak the output to something like `yourchannelcommandname {channelname} = $1`.

    * Properties:
        mutelist
        banlist
        wholist

    * Working methods:
        get_log_filename()
        set_log_filename(filename)
        has_connection(account) - check if the given account listens to this channel
        connect(account) - connect account to this channel
        disconnect(account) - disconnect account from channel
        access(access_obj, access_type='listen', default=False) - check the
                    access on this channel (default access_type is listen)
        create(key, creator=None, *args, **kwargs)
        delete() - delete this channel
        message_transform(msg, emit=False, prefix=True,
                          sender_strings=None, external=False) - called by
                          the comm system and triggers the hooks below
        msg(msgobj, header=None, senders=None, sender_strings=None,
            persistent=None, online=False, emit=False, external=False) - main
                send method, builds and sends a new message to channel.
        tempmsg(msg, header=None, senders=None) - wrapper for sending non-persistent
                messages.
        distribute_message(msg, online=False) - send a message to all
                connected accounts on channel, optionally sending only
                to accounts that are currently online (optimized for very large sends)
        mute(subscriber, **kwargs)
        unmute(subscriber, **kwargs)
        ban(target, **kwargs)
        unban(target, **kwargs)
        add_user_channel_alias(user, alias, **kwargs)
        remove_user_channel_alias(user, alias, **kwargs)


    Useful hooks:
        at_channel_creation() - called once, when the channel is created
        basetype_setup()
        at_init()
        at_first_save()
        channel_prefix() - how the channel should be
                  prefixed when returning to user. Returns a string
        format_senders(senders) - should return how to display multiple
                senders to a channel
        pose_transform(msg, sender_string) - should detect if the
                sender is posing, and if so, modify the string
        format_external(msg, senders, emit=False) - format messages sent
                from outside the game, like from IRC
        format_message(msg, emit=False) - format the message body before
                displaying it to the user. 'emit' generally means that the
                message should not be displayed with the sender's name.
        channel_prefix()

        pre_join_channel(joiner) - if returning False, abort join
        post_join_channel(joiner) - called right after successful join
        pre_leave_channel(leaver) - if returning False, abort leave
        post_leave_channel(leaver) - called right after successful leave
        at_pre_msg(message, **kwargs)
        at_post_msg(message, **kwargs)
        web_get_admin_url()
        web_get_create_url()
        web_get_detail_url()
        web_get_update_url()
        web_get_delete_url()

    """

    pass
</file>

<file path="typeclasses/exits.py">
"""
Exits

Exits are connectors between Rooms. An exit always has a destination property
set and has a single command defined on itself with the same name as its key,
for allowing Characters to traverse the exit to its destination.

"""

from evennia.objects.objects import DefaultExit

from .objects import ObjectParent


class Exit(ObjectParent, DefaultExit):
    """
    Exits are connectors between rooms. Exits are normal Objects except
    they defines the `destination` property and overrides some hooks
    and methods to represent the exits.

    See mygame/typeclasses/objects.py for a list of
    properties and methods available on all Objects child classes like this.

    """

    pass
</file>

<file path="typeclasses/README.md">
# typeclasses/

This directory holds the modules for overloading all the typeclasses
representing the game entities and many systems of the game. Other
server functionality not covered here is usually modified by the
modules in `server/conf/`.

Each module holds empty classes that just imports Evennia's defaults.
Any modifications done to these classes will overload the defaults.

You can change the structure of this directory (even rename the
directory itself) as you please, but if you do you must add the
appropriate new paths to your settings.py file so Evennia knows where
to look. Also remember that for Python to find your modules, it
requires you to add an empty `__init__.py` file in any new sub
directories you create.
</file>

<file path="typeclasses/scripts.py">
"""
Scripts

Scripts are powerful jacks-of-all-trades. They have no in-game
existence and can be used to represent persistent game systems in some
circumstances. Scripts can also have a time component that allows them
to "fire" regularly or a limited number of times.

There is generally no "tree" of Scripts inheriting from each other.
Rather, each script tends to inherit from the base Script class and
just overloads its hooks to have it perform its function.

"""

from evennia.scripts.scripts import DefaultScript


class Script(DefaultScript):
    """
    This is the base TypeClass for all Scripts. Scripts describe
    all entities/systems without a physical existence in the game world
    that require database storage (like an economic system or
    combat tracker). They
    can also have a timer/ticker component.

    A script type is customized by redefining some or all of its hook
    methods and variables.

    * available properties (check docs for full listing, this could be
      outdated).

     key (string) - name of object
     name (string)- same as key
     aliases (list of strings) - aliases to the object. Will be saved
              to database as AliasDB entries but returned as strings.
     dbref (int, read-only) - unique #id-number. Also "id" can be used.
     date_created (string) - time stamp of object creation
     permissions (list of strings) - list of permission strings

     desc (string)      - optional description of script, shown in listings
     obj (Object)       - optional object that this script is connected to
                          and acts on (set automatically by obj.scripts.add())
     interval (int)     - how often script should run, in seconds. <0 turns
                          off ticker
     start_delay (bool) - if the script should start repeating right away or
                          wait self.interval seconds
     repeats (int)      - how many times the script should repeat before
                          stopping. 0 means infinite repeats
     persistent (bool)  - if script should survive a server shutdown or not
     is_active (bool)   - if script is currently running

    * Handlers

     locks - lock-handler: use locks.add() to add new lock strings
     db - attribute-handler: store/retrieve database attributes on this
                        self.db.myattr=val, val=self.db.myattr
     ndb - non-persistent attribute handler: same as db but does not
                        create a database entry when storing data

    * Helper methods

     create(key, **kwargs)
     start() - start script (this usually happens automatically at creation
               and obj.script.add() etc)
     stop()  - stop script, and delete it
     pause() - put the script on hold, until unpause() is called. If script
               is persistent, the pause state will survive a shutdown.
     unpause() - restart a previously paused script. The script will continue
                 from the paused timer (but at_start() will be called).
     time_until_next_repeat() - if a timed script (interval>0), returns time
                 until next tick

    * Hook methods (should also include self as the first argument):

     at_script_creation() - called only once, when an object of this
                            class is first created.
     is_valid() - is called to check if the script is valid to be running
                  at the current time. If is_valid() returns False, the running
                  script is stopped and removed from the game. You can use this
                  to check state changes (i.e. an script tracking some combat
                  stats at regular intervals is only valid to run while there is
                  actual combat going on).
      at_start() - Called every time the script is started, which for persistent
                  scripts is at least once every server start. Note that this is
                  unaffected by self.delay_start, which only delays the first
                  call to at_repeat().
      at_repeat() - Called every self.interval seconds. It will be called
                  immediately upon launch unless self.delay_start is True, which
                  will delay the first call of this method by self.interval
                  seconds. If self.interval==0, this method will never
                  be called.
      at_pause()
      at_stop() - Called as the script object is stopped and is about to be
                  removed from the game, e.g. because is_valid() returned False.
      at_script_delete()
      at_server_reload() - Called when server reloads. Can be used to
                  save temporary variables you want should survive a reload.
      at_server_shutdown() - called at a full server shutdown.
      at_server_start()

    """

    pass
</file>

<file path="web/admin/README.md">
# Admin views

Evennia makes several customizations to the Django web admin, but you can make
further changes here. Customizing the admin is a big topic and
you are best off reading more about it in the [Django admin site documentation](https://docs.djangoproject.com/en/4.1/ref/contrib/admin/).
</file>

<file path="web/admin/urls.py">
"""
This reroutes from an URL to a python view-function/class.

The main web/urls.py includes these routes for all urls starting with `admin/`
(the `admin/` part should not be included again here).

"""

from django.urls import path

from evennia.web.admin.urls import urlpatterns as evennia_admin_urlpatterns

# add patterns here
urlpatterns = [
    # path("url-pattern", imported_python_view),
    # path("url-pattern", imported_python_view),
]

# read by Django
urlpatterns = urlpatterns + evennia_admin_urlpatterns
</file>

<file path="web/static/rest_framework/css/README.md">
# Evennia API static files

Overrides for API files.
</file>

<file path="web/static/rest_framework/images/README.md">
# Static files for API 

Override images here.
</file>

<file path="web/static/webclient/css/README.md">
You can replace the CSS files for Evennia's webclient here.

You can find the original files in `evennia/web/static/webclient/css/`
</file>

<file path="web/static/webclient/js/README.md">
You can replace the javascript files for Evennia's webclient page here.

You can find the original files in `evennia/web/static/webclient/js/`
</file>

<file path="web/static/website/css/README.md">
You can replace the CSS files for Evennia's homepage here.

You can find the original files in `evennia/web/static/website/css/`
</file>

<file path="web/static/website/images/README.md">
You can replace the image files for Evennia's home page here.

You can find the original files in `evennia/web/static/website/images/`
</file>

<file path="web/static/README.md">
## Static files

This is the place to put static resources you want to serve from the 
Evennia server. This is usually CSS and Javascript files but you _could_ also
serve other media like images, videos and music files from here.

> If you serve a lot of large files (especially videos) you will see a lot
> better performance doing so from a separate dedicated media host.

You can also override default Evennia files from here. The original files are
found in `evennia/web/static/`. Copy the original file into the same
corresponding location/sublocation in this folder (such as website CSS files
into `mygame/static/website/css/`) and modify it, then reload the server.

Note that all static resources will be collected from all over Evennia into
`mygame/server/.static` for serving by the webserver. That folder should not be
modified manually.
</file>

<file path="web/templates/rest_framework/README.md">
# Templates for the Evennia API

Override templates here.
</file>

<file path="web/templates/webclient/README.md">
Replace Evennia's webclient django template with your own here.

You can find the original files in `evennia/web/templates/webclient/`. Just copy
the original here and modify - after a reload the new template will be used.
</file>

<file path="web/templates/website/flatpages/README.md">
Flatpages require a default.html template, which can be overwritten by placing it in this folder.

You can find the original files in `evennia/web/website/templates/website/flatpages/`
</file>

<file path="web/templates/website/registration/README.md">
The templates involving login/logout can be overwritten here.

You can find the original files in `evennia/web/website/templates/website/registration/`
</file>

<file path="web/templates/website/README.md">
You can replace the django templates (html files) for the website
here. 

You can find the original files under `evennia/web/templates/website/`. Just 
copy a template here and modify to have it override the default.
</file>

<file path="web/templates/README.md">
# HTML templates

Templates are HTML files that (usually) have special `{{ ... }}` template
markers in them to allow Evennia/Django to insert dynamic content in a web
page. An example is listing how many users are currently online in the game.

Templates are referenced by _views_ - Python functions or callable classes that
prepare the data needed by the template and 'renders' them into a finished 
HTML page to return to the user.

You can replace Evennia's default templates by overriding them in this folder.
The originals are in `evennia/web/templates/` - just copy the template into the
corresponding location here (so the website's `index.html` should be copied to
`website/index.html` where it can be modified). Reload the server to see your changes.
</file>

<file path="web/webclient/README.md">
# Webclient Views

The webclient is mainly controlled by Javascript directly in the browser, so
you usually customize it via `mygame/web/static/webclient/js/` - files instead.

There is very little you can change from here, unless you want to implement
your very own client from scratch.

## On views

A 'view' is python code (a function or callable class) responsible for
producing a HTML page for a user to view in response for going to a given URL
in their browser. In Evennia lingo, it's similar in function to a Command, with
the input/args being the URL/request and the output being a new web-page.

The urls.py file contains regular expressions that are run against the provided
URL - when a match is found, the execution is passed to a view which is then
responsible (usually) for producing the web page by filling in a _template_ - a
HTML document that can have special tags in it that are replaced for dynamic
content. It then returns the finished HTML page for the user to view.

See the [Django docs on Views](https://docs.djangoproject.com/en/4.1/topics/http/views/) for
more information.
</file>

<file path="web/webclient/urls.py">
"""
This reroutes from an URL to a python view-function/class.

The main web/urls.py includes these routes for all urls starting with `webclient/`
(the `webclient/` part should not be included again here).

"""

from django.urls import path

from evennia.web.webclient.urls import urlpatterns as evennia_webclient_urlpatterns

# add patterns here
urlpatterns = [
    # path("url-pattern", imported_python_view),
    # path("url-pattern", imported_python_view),
]

# read by Django
urlpatterns = urlpatterns + evennia_webclient_urlpatterns
</file>

<file path="web/website/README.md">
# Website views and other code

A 'view' is python code (a function or callable class) responsible for
producing a HTML page for a user to view in response for going to a given URL
in their browser. In Evennia lingo, it's similar in function to a Command, with
the input/args being the URL/request and the output being a new web-page.

The urls.py file contains regular expressions that are run against the provided
URL - when a match is found, the execution is passed to a view which is then
responsible (usually) for producing the web page by filling in a _template_ - a
HTML document that can have special tags in it that are replaced for dynamic
content. It then returns the finished HTML page for the user to view.

See the [Django docs on Views](https://docs.djangoproject.com/en/4.1/topics/http/views/) for
more information.

## Overriding a view

1. Copy the original code you want to change from `evennia/web/website/views/` into
`mygame/web/website/views/` and edit it as you like.
2. Look at `evennia/web/website/urls.py` and find the regex pointing to the view. Add this regex
to your own `mygam/website/urls.pye` but change it to import and point to your
changed version instead.
3. Reload the server and the page now uses your version of the view.
</file>

<file path="web/website/urls.py">
"""
This reroutes from an URL to a python view-function/class.

The main web/urls.py includes these routes for all urls (the root of the url)
so it can reroute to all website pages.

"""

from django.urls import path

from evennia.web.website.urls import urlpatterns as evennia_website_urlpatterns

# add patterns here
urlpatterns = [
    # path("url-pattern", imported_python_view),
    # path("url-pattern", imported_python_view),
]

# read by Django
urlpatterns = urlpatterns + evennia_website_urlpatterns
</file>

<file path="web/README.md">
# Web 

This folder contains overriding of web assets - the website and webclient
coming with the game.

This is the process for serving a new web site (see also the Django docs for
more details):

1. A user enters an url in their browser (or clicks a button). This leads to
   the browser sending a _HTTP request_ to the server, with a specific type
   (GET,POST etc) and url-path (like for `https://localhost:4001/`, the part of
   the url we need to consider is `/`).
2. Evennia (through Django) will make use of the regular expressions registered
   in the `urls.py` file.  This acts as a rerouter to _views_, which are
   regular Python functions able to process the incoming request (think of
   these as similar to the right Evennia Command being selected to handle your
   input - views are like Commands in this sense). In the case of `/` we
   reroute to a view handling the main index-page of the website.  The view is
   either a function or a callable class (Evennia tends to have them as
   functions).
3. The view-function will prepare all the data needed by the web page. For the default 
   index page, this means gather the game statistics so you can see how many
   are currently connected to the game etc. 
4. The view will next fetch a _template_. A template is a HTML-document with special
   'placeholder' tags (written as `{{...}}` or `{% ... %}` usually). These
   placeholders allow the view to inject dynamic content into the HTML and make
   the page customized to the current situation. For the index page, it means
   injecting the current player-count in the right places of the html page. This
   is called 'rendering' the template. The result is a complete HTML page.
5. (The view can also pull in a _form_ to customize user-input in a similar way.)
6. The finished HTML page is packed in a _HTTP response_ and is returned to the
   web browser, which can now display the page! 

## A note on the webclient

The web browser can also execute code directly without talking to the Server.
This code must be written/loaded into the web page and is written using the
Javascript programming language (there is no way around this, it is what web
browsers understand). Executing Javascript is something the web browser does,
it operates independently from Evennia. Small snippets of javascript can be
used on a page to have buttons react, make small animations etc that doesn't
require the server.

In the case of the Webclient, Evennia will load the Webclient page as above,
but the page then contains Javascript code responsible for actually displaying
the client GUI, allows you to resize windows etc. 

After it starts, the webclient 'calls home' and spins up a websocket link to
the Evennia Portal - this is how all data is then exchanged. So after the
initial loading of the webclient page, the above sequence doesn't happen again
until close the tab and come back or you reload it manually in your browser.
</file>

<file path="web/urls.py">
"""
This is the starting point when a user enters a url in their web browser.

The urls is matched (by regex) and mapped to a 'view' - a Python function or
callable class that in turn (usually) makes use of a 'template' (a html file
with slots that can be replaced by dynamic content) in order to render a HTML
page to show the user.

This file includes the urls in website, webclient and admin. To override you
should modify urls.py in those sub directories.

Search the Django documentation for "URL dispatcher" for more help.

"""

from django.urls import include, path

# default evennia patterns
from evennia.web.urls import urlpatterns as evennia_default_urlpatterns

# add patterns
urlpatterns = [
    # website
    path("", include("web.website.urls")),
    # webclient
    path("webclient/", include("web.webclient.urls")),
    # web admin
    path("admin/", include("web.admin.urls")),
    # add any extra urls here:
    # path("mypath/", include("path.to.my.urls.file")),
]

# 'urlpatterns' must be named such for Django to find it.
urlpatterns = urlpatterns + evennia_default_urlpatterns
</file>

<file path="world/recipes/base_recipes.py">
# world/recipes/base_recipes.py
"""
Base recipe classes for the crafting system.

This module provides base classes that integrate crafting with
our skill system and quality mechanics.
"""

from evennia.contrib.game_systems.crafting.crafting import CraftingRecipe, CraftingValidationError
from evennia.utils import gametime, iter_to_str
from random import random, randint
from django.conf import settings


class SkillBasedRecipe(CraftingRecipe):
    """
    Base recipe class that integrates with our skill system.
    
    This adds:
    - Skill requirements and checks
    - Quality variations based on crafter skill
    - Tool quality considerations  
    - Integration with cooldown system
    
    Additional properties:
        skill_requirement (str): Primary skill needed
        difficulty (int): Minimum skill level (0-100)
        quality_levels (dict): Maps skill ranges to quality outputs
        craft_time (int): Base crafting time in seconds
        craft_category (str): Category for cooldowns ("craft_basic", "craft_advanced", etc)
    """
    
    # Base properties
    skill_requirement = "crafting"
    difficulty = 0
    craft_time = 300  # 5 minutes base
    craft_category = "craft_basic"
    
    # Quality mapping based on skill vs difficulty
    quality_levels = {
        -20: "poor",      # 20+ below difficulty
        -10: "average",   # 10-19 below
        0: "good",        # At difficulty
        10: "fine",       # 10+ above
        20: "excellent",  # 20+ above
        30: "masterwork"  # 30+ above (requires master skill)
    }
    
    # Messages
    error_skill_too_low = "You need at least {difficulty} {skill_name} to craft {outputs}."
    error_on_cooldown = "You are too tired to craft. Wait {time_left} seconds."
    
    # I world/recipes/base_recipes.py

    def pre_craft(self, **kwargs):
        """
        Validate inputs and check skill requirements.
        """
        # Do normal validation first
        super().pre_craft(**kwargs)
    
        # Check if crafter is on cooldown
        if hasattr(self.crafter, 'cooldowns') and not self.crafter.cooldowns.ready(self.craft_category):
            time_left = self.crafter.cooldowns.time_left(self.craft_category, use_int=True)
            err = self.error_on_cooldown.format(time_left=time_left)
            self.msg(err)
            raise CraftingValidationError(err)
    
        # Check skill requirement
        if hasattr(self.crafter, 'skills'):
            # ÄNDRING: Använd skills direkt istället för get_skill_level
            skill = getattr(self.crafter.skills, self.skill_requirement, None)
            if skill:
                skill_level = skill.value
                skill_desc = skill.desc() if hasattr(skill, 'desc') else "unknown"
            else:
                skill_level = 0
                skill_desc = "untrained"
        else:
            # Fallback for testing or NPCs
            skill_level = 0
            skill_desc = "untrained"
        
        if skill_level < self.difficulty:
            err = self.error_skill_too_low.format(
                difficulty=self.difficulty,
                skill_name=self.skill_requirement,
                outputs=iter_to_str([proto.get('key', 'item') for proto in self.output_prototypes])
            )
            self.msg(err)
            raise CraftingValidationError(err)
    
        # Store skill level for use in do_craft
        self.crafter_skill = skill_level

    def calculate_quality(self):
        """
        Calculate output quality based on skill and other factors.
    
        Returns:
            tuple: (quality_name, quality_modifier)
        """
        # Base quality from skill vs difficulty
        skill_diff = self.crafter_skill - self.difficulty
    
        # Find appropriate quality level
        quality_name = "average"
        for threshold in sorted(self.quality_levels.keys(), reverse=True):
            if skill_diff >= threshold:
                quality_name = self.quality_levels[threshold]
                break
    
        # Calculate quality modifier for item stats
        base_modifier = 1.0 + (skill_diff / 100.0)  # +1% per skill point above difficulty
    
        # Tool quality bonus (if applicable)
        tool_bonus = 0
        for tool in self.validated_tools:
            # FIXA: Kontrollera att quality finns och har ett värde
            if hasattr(tool, 'db') and hasattr(tool.db, 'quality') and tool.db.quality is not None:
                tool_bonus += (tool.db.quality - 50) / 200.0  # -25% to +25% based on tool quality
            # Om inget quality är satt, anta standard quality (50)
            else:
                tool_bonus += 0  # Ingen bonus/penalty för verktyg utan quality
    
        if self.validated_tools:
            tool_bonus /= len(self.validated_tools)
    
        total_modifier = base_modifier + tool_bonus
    
        # Add some randomness (±10%)
        total_modifier *= (0.9 + random() * 0.2)
    
        # Clamp between 0.5 and 2.0
        total_modifier = max(0.5, min(2.0, total_modifier))
    
        return quality_name, total_modifier

    def do_craft(self, **kwargs):
        """
        Perform the crafting with quality variations.
        """
        # Calculate quality
        quality_name, quality_modifier = self.calculate_quality()
        
        # Success chance based on skill
        success_chance = 0.5 + (self.crafter_skill / 200.0)  # 50-100% based on skill
        
        if random() > success_chance:
            self.msg("|rYour crafting attempt fails! The materials are ruined.|n")
            return []
        
        # Create items with quality modifications
        created_items = []
        for prototype in self.output_prototypes:
            # Copy prototype to avoid modifying original
            modified_proto = prototype.copy()
            
            # Add quality to key
            if quality_name != "average":
                modified_proto["key"] = f"{quality_name} {modified_proto['key']}"
            
            # Apply quality modifier to relevant attributes
            if "attrs" not in modified_proto:
                modified_proto["attrs"] = []
            
            # Add quality-related attributes
            modified_proto["attrs"].extend([
                ("quality", quality_name),
                ("quality_modifier", quality_modifier),
                ("crafted_by", self.crafter.key),
                ("craft_date", gametime.gametime())
            ])
            
            # Spawn the item
            from evennia.prototypes.spawner import spawn
            items = spawn(modified_proto)
            created_items.extend(items)
        
        # Apply crafting skill improvement
        if self.crafter_skill < 100 and hasattr(self.crafter, 'improve_skill'):
            # More skill gain for harder recipes
            skill_gain = max(1, (self.difficulty // 20))
            if self.crafter.improve_skill(self.skill_requirement, skill_gain):
                self.msg(f"|gYour {self.skill_requirement} skill improves!|n")
        
        return created_items
    
    # I world/recipes/base_recipes.py (i SkillBasedRecipe)

    def post_craft(self, craft_result, **kwargs):
        """
        Handle post-crafting cleanup and cooldowns.
        """
        # Call parent to handle consumables and messages
        result = super().post_craft(craft_result, **kwargs)
    
        if craft_result:
            # Track successful craft
            if hasattr(self.crafter, 'db'):
                # Add to known recipes
                if not hasattr(self.crafter.db, 'known_recipes'):
                    self.crafter.db.known_recipes = []
                if self.name not in self.crafter.db.known_recipes:
                    self.crafter.db.known_recipes.append(self.name)
            
                # Update craft count
                if not hasattr(self.crafter.db, 'craft_counts'):
                    self.crafter.db.craft_counts = {}
                self.crafter.db.craft_counts[self.name] = self.crafter.db.craft_counts.get(self.name, 0) + 1
            
                # Track quality
                for item in craft_result:
                    if hasattr(item.db, 'quality'):
                        quality = item.db.quality
                        if not hasattr(self.crafter.db, 'best_quality'):
                            self.crafter.db.best_quality = {}
                        current_best = self.crafter.db.best_quality.get(self.name, "poor")
                        quality_order = ["poor", "average", "good", "fine", "excellent", "masterwork"]
                        if quality in quality_order and current_best in quality_order:
                            if quality_order.index(quality) > quality_order.index(current_best):
                                self.crafter.db.best_quality[self.name] = quality
                    
                        # Update stats
                        if not hasattr(self.crafter.db, 'crafting_stats'):
                            self.crafter.db.crafting_stats = {'total_crafted': 0, 'total_failed': 0, 'quality_counts': {}}
                        self.crafter.db.crafting_stats['total_crafted'] += 1
                        quality_counts = self.crafter.db.crafting_stats.get('quality_counts', {})
                        quality_counts[quality] = quality_counts.get(quality, 0) + 1
                        self.crafter.db.crafting_stats['quality_counts'] = quality_counts
        
            # Apply cooldown
            if hasattr(self.crafter, 'apply_cooldown'):
                actual_cooldown = self.crafter.apply_cooldown(
                    self.craft_category, 
                    self.craft_time,
                    self.skill_requirement
                )
            
                # Show quality message
                for item in craft_result:
                    if hasattr(item, 'db') and hasattr(item.db, 'quality'):
                        quality = item.db.quality
                        if quality != "average":
                            self.msg(f"|yYou created a {quality} quality item!|n")
    
        return result


class SkillAndStatRecipe(SkillBasedRecipe):
    """
    Advanced recipe that also considers character stats.
    
    Some recipes benefit from specific stats:
    - STR for heavy work (smithing)
    - DEX for precision work (clockwork)
    - INT for complex recipes (engineering)
    """
    
    # Additional properties
    stat_requirement = None  # e.g., "strength"
    stat_weight = 0.3  # How much the stat affects outcome (0-1)
    
    def calculate_quality(self):
        """Override to include stat bonuses."""
        quality_name, quality_modifier = super().calculate_quality()
        
        # Add stat bonus if applicable
        if self.stat_requirement and hasattr(self.crafter, 'get_stat'):
            stat_value = self.crafter.get_stat(self.stat_requirement)
            if stat_value:
                # Each point above 10 gives a small bonus
                stat_bonus = (stat_value - 10) * 0.02 * self.stat_weight
                quality_modifier += stat_bonus
        
        # Re-clamp after stat bonus
        quality_modifier = max(0.5, min(2.0, quality_modifier))
        
        return quality_name, quality_modifier
</file>

<file path="world/recipes/clothing_recipes.py">
# world/recipes/clothing_recipes.py
"""
Clothing and armor crafting recipes.

These recipes create various clothing items that provide
protection from weather and combat.
"""

from world.recipes.base_recipes import SkillBasedRecipe, SkillAndStatRecipe


class LeatherArmorRecipe(SkillAndStatRecipe):
    """Craft leather armor for protection."""
    
    name = "leather armor"
    skill_requirement = "crafting"
    difficulty = 30
    craft_time = 1800  # 30 minutes
    craft_category = "craft_basic"
    
    # Strength helps with working thick leather
    stat_requirement = "strength"
    stat_weight = 0.3
    
    tool_tags = ["leather_tools", "workbench"]
    consumable_tags = ["leather", "leather", "leather", "leather_strips", "buckles"]
    
    output_prototypes = [{
        "key": "leather armor",
        "typeclass": "typeclasses.objects.LeatherArmor",
        "desc": "A sturdy set of leather armor with reinforced panels.",
        "tags": [
            ("armor", "item_type"),
            ("leather_armor", "item_type")
        ],
        "attrs": [
            ("clothing_type", "outerwear"),
            ("protection_value", 5),  # Base armor
            ("warmth_value", 10),
            ("weather_protection", ["wind"]),
            ("durability", 100),
            ("max_durability", 100),
            ("repair_materials", ["leather"]),
            ("weight", 5)
        ]
    }]


class WinterCloakRecipe(SkillBasedRecipe):
    """Craft a warm winter cloak."""
    
    name = "winter cloak"
    skill_requirement = "crafting"
    difficulty = 25
    craft_time = 1200  # 20 minutes
    craft_category = "craft_basic"
    
    tool_tags = ["sewing_kit", "scissors"]
    consumable_tags = ["wool_cloth", "wool_cloth", "fur_lining", "thread", "clasp"]
    
    output_prototypes = [{
        "key": "winter cloak",
        "typeclass": "typeclasses.objects.WinterCloak",
        "desc": "A heavy woolen cloak lined with warm fur.",
        "tags": [
            ("cloak", "item_type"),
            ("winter_gear", "item_type")
        ],
        "attrs": [
            ("clothing_type", "cloak"),
            ("warmth_value", 25),
            ("weather_protection", ["snow", "wind", "rain"]),
            ("stat_modifiers", {"constitution": 1}),
            ("durability", 80),
            ("max_durability", 80),
            ("repair_materials", ["wool_cloth", "fur"]),
            ("weight", 3)
        ]
    }]


class EngineerGogglesRecipe(SkillBasedRecipe):
    """Craft specialized engineering goggles."""
    
    name = "engineer goggles"
    skill_requirement = "engineering"  # Requires engineering to make properly
    difficulty = 40
    craft_time = 1500  # 25 minutes
    craft_category = "craft_basic"
    
    tool_tags = ["precision_tools", "lens_grinder"]
    consumable_tags = ["brass_frame", "glass_lens", "glass_lens", "leather_strap", "tiny_gears"]
    
    output_prototypes = [{
        "key": "engineering goggles",
        "typeclass": "typeclasses.objects.EngineeringGoggles",
        "desc": "Brass-framed goggles with multiple adjustable lenses.",
        "tags": [
            ("goggles", "item_type"),
            ("engineering_gear", "item_type")
        ],
        "attrs": [
            ("clothing_type", "goggles"),
            ("stat_modifiers", {"intelligence": 2}),
            ("engineering_bonus", 10),
            ("magnification", 3),
            ("durability", 60),
            ("max_durability", 60),
            ("repair_materials", ["brass", "glass"]),
            ("weight", 0.5)
        ]
    }]


class RaincoatRecipe(SkillBasedRecipe):
    """Craft a waterproof raincoat."""
    
    name = "raincoat"
    skill_requirement = "crafting"
    difficulty = 20
    craft_time = 900  # 15 minutes
    craft_category = "craft_basic"
    
    tool_tags = ["sewing_kit", "waterproofing_kit"]
    consumable_tags = ["canvas_cloth", "canvas_cloth", "oil_treatment", "buttons"]
    
    output_prototypes = [{
        "key": "waterproof raincoat",
        "typeclass": "typeclasses.objects.RainCoat",
        "desc": "A long coat treated with oils to repel water.",
        "tags": [
            ("raincoat", "item_type"),
            ("weather_gear", "item_type")
        ],
        "attrs": [
            ("clothing_type", "outerwear"),
            ("warmth_value", 10),
            ("weather_protection", ["rain", "wind"]),
            ("durability", 70),
            ("max_durability", 70),
            ("repair_materials", ["canvas_cloth", "oil"]),
            ("weight", 2)
        ]
    }]
</file>

<file path="world/recipes/steampunk_recipes.py">
# world/recipes/steampunk_recipes.py
"""
Steampunk-themed recipes for advanced technology.

These recipes create steam-powered devices, clockwork mechanisms,
and other technological marvels of the steampunk world.
"""

from world.recipes.base_recipes import SkillBasedRecipe, SkillAndStatRecipe
from evennia.contrib.game_systems.crafting.crafting import CraftingValidationError


class SteamEngineRecipe(SkillAndStatRecipe):
    """Build a basic steam engine - the heart of many devices."""
    
    name = "steam engine"
    skill_requirement = "engineering"
    difficulty = 50
    craft_time = 3600  # 1 hour
    craft_category = "craft_advanced"
    
    # Requires both skill and intelligence
    stat_requirement = "intelligence"
    stat_weight = 0.4
    
    tool_tags = ["forge", "precision_tools", "workbench"]
    consumable_tags = ["iron_ingot", "iron_ingot", "copper_pipe", "brass_fitting", 
                      "brass_fitting", "rubber_seal", "coal"]
    
    output_prototypes = [{
        "key": "steam engine",
        "typeclass": "typeclasses.objects.SteamEngine",
        "desc": "A compact steam engine with gleaming brass fittings and copper pipes.",
        "tags": [
            ("steam_engine", "item_type"),
            ("machine_part", "item_type"),
            ("power_source", "crafting_material")
        ],
        "attrs": [
            ("power_output", 100),  # Base power units
            ("fuel_efficiency", 0.7),  # 70% efficient
            ("max_pressure", 150),
            ("weight", 25),
            ("requires_water", True),
            ("requires_coal", True),
            ("maintenance_interval", 7200)  # Needs maintenance every 2 hours of use
        ]
    }]
    
    success_message = "The engine hums to life with a satisfying hiss of steam!"
    failure_message = "The engine sputters and fails. The pressure seals weren't quite right."


class ClockworkMechanismRecipe(SkillAndStatRecipe):
    """Create a precise clockwork mechanism."""
    
    name = "clockwork mechanism"
    skill_requirement = "engineering"
    difficulty = 40
    craft_time = 2400  # 40 minutes
    craft_category = "craft_advanced"
    
    # Dexterity for precision work
    stat_requirement = "dexterity"
    stat_weight = 0.5
    
    tool_tags = ["precision_tools", "magnifying_glass", "workbench"]
    consumable_tags = ["brass_gear", "brass_gear", "brass_gear", "steel_spring", 
                      "steel_spring", "tiny_screws"]
    
    output_prototypes = [{
        "key": "clockwork mechanism",
        "typeclass": "typeclasses.objects.ClockworkDevice",
        "desc": "An intricate assembly of gears and springs that tick with mechanical precision.",
        "tags": [
            ("clockwork", "item_type"),
            ("mechanism", "crafting_material")
        ],
        "attrs": [
            ("precision", 0.95),  # 95% timing accuracy
            ("complexity", 3),  # Complexity level
            ("tick_rate", 60),  # Ticks per minute
            ("wound", False),
            ("max_tension", 1000),
            ("current_tension", 0)
        ]
    }]


class SteamPistolRecipe(SkillBasedRecipe):
    """Craft a steam-powered pistol."""
    
    name = "steam pistol"
    skill_requirement = "engineering"
    difficulty = 60
    craft_time = 2700  # 45 minutes
    craft_category = "craft_advanced"
    
    tool_tags = ["forge", "precision_tools", "weapon_molds"]
    consumable_tags = ["steel_ingot", "brass_fitting", "pressure_chamber", 
                      "wooden_grip", "trigger_mechanism"]
    
    output_prototypes = [{
        "key": "steam pistol",
        "typeclass": "typeclasses.objects.SteamWeapon",
        "desc": "A brass and steel pistol with a small pressure chamber and steam vents.",
        "tags": [
            ("steam_pistol", "item_type"),
            ("weapon", "item_type"),
            ("ranged", "weapon_type")
        ],
        "attrs": [
            ("damage", 15),  # Base damage
            ("range", 10),  # 10 room range
            ("accuracy", 0.7),  # 70% base accuracy
            ("pressure_per_shot", 20),
            ("max_pressure", 100),
            ("current_pressure", 0),
            ("reload_time", 5),  # 5 seconds between shots
            ("weight", 3),
            ("requires_steam_canister", True)
        ]
    }]


class AutomatonCoreRecipe(SkillAndStatRecipe):
    """Create the core for a mechanical automaton."""
    
    name = "automaton core"
    skill_requirement = "engineering"
    difficulty = 80
    craft_time = 7200  # 2 hours
    craft_category = "craft_advanced"
    
    stat_requirement = "intelligence"
    stat_weight = 0.6  # Very INT dependent
    
    tool_tags = ["advanced_workbench", "precision_tools", "arcane_calibrator"]
    consumable_tags = ["clockwork_mechanism", "steam_engine", "brass_chassis",
                      "control_rods", "control_rods", "memory_gears", "soul_gem"]
    
    output_prototypes = [{
        "key": "automaton core",
        "typeclass": "typeclasses.objects.AutomatonCore",
        "desc": "A complex fusion of clockwork and steam technology, pulsing with potential.",
        "tags": [
            ("automaton_core", "item_type"),
            ("advanced_component", "crafting_material")
        ],
        "attrs": [
            ("core_type", "basic"),
            ("power_capacity", 1000),
            ("instruction_set", "simple"),  # Can follow simple commands
            ("sentience_level", 0.1),  # Barely sentient
            ("activation_phrase", ""),  # Set when activated
            ("owner", ""),
            ("maintenance_log", [])
        ]
    }]
    
    def do_craft(self, **kwargs):
        """Special handling for soul gem consumption."""
        # Check for soul gem quality
        soul_gem = None
        for cons in self.validated_consumables:
            if "soul_gem" in cons.tags.get(category="item_type", return_list=True):
                soul_gem = cons
                break
        
        if soul_gem and hasattr(soul_gem.db, 'soul_quality'):
            # Better soul = better automaton
            quality_bonus = soul_gem.db.soul_quality / 100.0
            for proto in self.output_prototypes:
                for i, (attr_name, attr_val) in enumerate(proto.get("attrs", [])):
                    if attr_name == "sentience_level":
                        new_sentience = attr_val + (quality_bonus * 0.5)
                        proto["attrs"][i] = ("sentience_level", new_sentience)
                        break
        
        return super().do_craft(**kwargs)


class PressureGaugeRecipe(SkillBasedRecipe):
    """A pressure gauge for monitoring steam devices."""
    
    name = "pressure gauge"
    skill_requirement = "engineering"
    difficulty = 30
    craft_time = 900  # 15 minutes
    craft_category = "craft_basic"
    
    tool_tags = ["precision_tools", "workbench"]
    consumable_tags = ["brass_casing", "glass_face", "pressure_spring", "tiny_screws"]
    
    output_prototypes = [{
        "key": "pressure gauge",
        "typeclass": "typeclasses.objects.SteamComponent",
        "desc": "A brass gauge with a glass face showing pressure readings.",
        "tags": [
            ("pressure_gauge", "item_type"),
            ("steam_component", "crafting_material"),
            ("monitoring_device", "item_type")
        ],
        "attrs": [
            ("max_reading", 200),  # PSI
            ("accuracy", 0.95),
            ("warning_threshold", 150),
            ("critical_threshold", 180),
            ("weight", 0.5)
        ]
    }]


class SteamJetpackRecipe(SkillAndStatRecipe):
    """An advanced personal flight device."""
    
    name = "steam jetpack"
    skill_requirement = "engineering"
    difficulty = 90  # Master-level recipe
    craft_time = 10800  # 3 hours
    craft_category = "craft_advanced"
    
    stat_requirement = "intelligence"
    stat_weight = 0.4
    
    tool_tags = ["advanced_forge", "precision_tools", "pressure_testing_rig"]
    consumable_tags = ["steam_engine", "steam_engine", "brass_chassis", "leather_straps",
                      "pressure_regulator", "thrust_nozzles", "control_mechanism", "padding"]
    
    # Can't succeed without very high skill
    exact_consumables = True
    exact_tools = True
    
    output_prototypes = [{
        "key": "steam jetpack",
        "typeclass": "typeclasses.objects.SteamJetpack",
        "desc": "A marvel of engineering: twin brass engines mounted on a reinforced frame.",
        "tags": [
            ("jetpack", "item_type"),
            ("steam_device", "item_type"),
            ("flight_capable", "capability")
        ],
        "attrs": [
            ("flight_duration", 300),  # 5 minutes per fuel load
            ("max_altitude", 5),  # 5 rooms high
            ("fuel_capacity", 10),
            ("current_fuel", 0),
            ("thrust_power", 200),
            ("weight", 40),
            ("worn_on", "back"),
            ("requires_training", True)  # Need flight training to use safely
        ]
    }]
    
    error_skill_too_low = (
        "This is far too complex for your current skill level. "
        "Only a true master engineer could hope to create a {outputs}."
    )
    
    success_message = (
        "With a final adjustment, the jetpack roars to life! "
        "The twin engines pulse with barely-contained power. "
        "You've created something truly extraordinary!"
    )
</file>

<file path="world/recipes/survival_recipes.py">
# world/recipes/survival_recipes.py
"""
Survival-focused recipes for basic needs.

These recipes create food, water containers, and basic tools
needed for survival in the game world.
"""

from world.recipes.base_recipes import SkillBasedRecipe, SkillAndStatRecipe
from evennia.contrib.game_systems.crafting.crafting import CraftingValidationError
from evennia.utils.utils import iter_to_str


class WaterContainerRecipe(SkillBasedRecipe):
    """Create a basic water container from leather."""
    
    name = "waterskin"
    skill_requirement = "crafting"
    difficulty = 10
    craft_time = 180  # 3 minutes
    craft_category = "craft_basic"
    
    tool_tags = ["knife"]
    consumable_tags = ["leather", "twine"]
    
    output_prototypes = [{
        "key": "waterskin",
        "typeclass": "typeclasses.objects.Container",
        "desc": "A leather waterskin for carrying water.",
        "tags": [
            ("waterskin", "item_type"),
            ("container", "item_type"),
            ("liquid_only", "container_type")
        ],
        "attrs": [
            ("capacity", 3),  # Can hold 3 water items
            ("liquid_only", True),
            ("empty_weight", 0.5),
            ("durability", 50),
            ("max_durability", 50)
        ]
    }]


class CampfireRecipe(SkillBasedRecipe):
    """Build a campfire for cooking and warmth."""
    
    name = "campfire"
    skill_requirement = "survival" 
    difficulty = 5
    craft_time = 120  # 2 minutes
    craft_category = "craft_basic"
    
    tool_tags = []  # No tools needed
    consumable_tags = ["wood", "wood", "wood"]  # Need 3 wood
    
    output_prototypes = [{
        "key": "campfire",
        "typeclass": "typeclasses.objects.Campfire",
        "desc": "A crackling campfire providing warmth and light.",
        "tags": [
            ("campfire", "item_type"),
            ("heat_source", "item_type"),
            ("light_source", "item_type")
        ],
        "attrs": [
            ("burn_time", 3600),  # Burns for 1 hour
            ("is_lit", True),
            ("warmth_radius", 1),  # Warms adjacent rooms
            ("cooking_bonus", 10),  # +10% to cooking skill when used
            ("portable", False)  # Can't be picked up while lit
        ]
    }]
    
    def do_craft(self, **kwargs):
        """Override to check if location allows fires."""
        location = self.crafter.location
        
        # Check if indoor location allows fires
        if location.db.indoor and not location.db.allow_fire:
            self.msg("|rYou cannot build a fire indoors here!|n")
            return []
        
        # Check weather
        weather = location.get_current_weather()
        if "storm" in weather or "heavy_rain" in weather:
            self.msg("|rThe weather is too harsh to build a fire.|n")
            return []
        
        return super().do_craft(**kwargs)


class BreadRecipe(SkillBasedRecipe):
    """Bake bread - a basic food staple."""
    
    name = "bread"
    skill_requirement = "crafting"
    difficulty = 15
    craft_time = 600  # 10 minutes  
    craft_category = "craft_basic"
    
    tool_tags = ["oven", "mixing_bowl"]
    consumable_tags = ["flour", "water", "yeast", "salt"]
    
    output_prototypes = [{
        "key": "loaf of bread",
        "typeclass": "typeclasses.objects.Food", 
        "desc": "A freshly baked loaf of bread with a golden crust.",
        "tags": [
            ("bread", "item_type"),
            ("food", "item_type")
        ],
        "attrs": [
            ("nutrition", 30),  # Base nutrition value
            ("weight", 0.5),
            ("decay_rate", 0.1),  # Decays slowly
            ("uses", 4)  # Can be eaten 4 times
        ]
    }]
    
    def calculate_quality(self):
        """Override to give better nutrition for higher quality."""
        quality_name, quality_modifier = super().calculate_quality()
        
        # Modify the nutrition value in output
        for proto in self.output_prototypes:
            for i, (attr_name, attr_val) in enumerate(proto.get("attrs", [])):
                if attr_name == "nutrition":
                    # Better quality = more nutritious
                    new_nutrition = int(attr_val * quality_modifier)
                    proto["attrs"][i] = ("nutrition", new_nutrition)
                    break
        
        return quality_name, quality_modifier


class PreservedMeatRecipe(SkillBasedRecipe):
    """Create preserved meat that lasts longer."""
    
    name = "preserved meat"
    skill_requirement = "survival"
    difficulty = 25
    craft_time = 900  # 15 minutes
    craft_category = "craft_basic"
    
    tool_tags = ["knife", "smoking_rack"]
    consumable_tags = ["raw_meat", "raw_meat", "salt", "herbs"]
    
    output_prototypes = [{
        "key": "preserved meat",
        "typeclass": "typeclasses.objects.Food",
        "desc": "Strips of meat preserved with salt and smoke.",
        "tags": [
            ("preserved_meat", "item_type"),
            ("food", "item_type")
        ],
        "attrs": [
            ("nutrition", 40),
            ("weight", 0.8),
            ("decay_rate", 0.02),  # Very slow decay
            ("uses", 2)
        ]
    }]


class HerbalTeaRecipe(SkillBasedRecipe):
    """Brew herbal tea for minor healing."""
    
    name = "herbal tea"
    skill_requirement = "survival"
    difficulty = 20
    craft_time = 300
    craft_category = "craft_basic"
    
    tool_tags = ["pot", "campfire"]
    consumable_tags = ["herbs", "herbs", "water"]
    
    output_prototypes = [{
        "key": "herbal tea",
        "typeclass": "typeclasses.objects.Consumable",
        "desc": "A steaming cup of medicinal herbal tea.",
        "tags": [
            ("tea", "item_type"),
            ("drink", "item_type"),
            ("medicine", "item_type")
        ],
        "attrs": [
            ("thirst_value", 15),
            ("healing_value", 10),  # Restores some health
            ("effect_type", "heal_minor"),
            ("uses", 1),
            ("weight", 0.3)
        ]
    }]


class StewRecipe(SkillAndStatRecipe):
    """A hearty stew - excellent nutrition but requires skill."""
    
    name = "hearty stew"
    skill_requirement = "crafting"
    difficulty = 35
    craft_time = 1200  # 20 minutes
    craft_category = "craft_basic"
    
    # Wisdom helps with seasoning
    stat_requirement = "wisdom"
    stat_weight = 0.2
    
    tool_tags = ["pot", "ladle", "campfire"]
    consumable_tags = ["meat", "vegetables", "vegetables", "herbs", "water", "salt"]
    
    output_prototypes = [{
        "key": "pot of hearty stew",
        "typeclass": "typeclasses.objects.Food",
        "desc": "A large pot of thick, savory stew with chunks of meat and vegetables.",
        "tags": [
            ("stew", "item_type"),
            ("food", "item_type")
        ],
        "attrs": [
            ("nutrition", 60),  # Very nutritious
            ("weight", 2.0),
            ("decay_rate", 0.15),  # Spoils moderately fast
            ("uses", 6),  # Feeds multiple people
            ("warmth_bonus", 5)  # Provides warmth when eaten
        ]
    }]
</file>

<file path="world/recipes/tool_recipes.py">
# world/recipes/tool_recipes.py
"""
Tool and equipment crafting recipes.

These recipes create the tools needed for other crafting,
as well as gathering and survival equipment.
"""

from world.recipes.base_recipes import SkillBasedRecipe, SkillAndStatRecipe


class PickaxeRecipe(SkillAndStatRecipe):
    """Craft a pickaxe for mining stone."""
    
    name = "pickaxe"
    skill_requirement = "crafting"
    difficulty = 20
    craft_time = 600  # 10 minutes
    craft_category = "craft_basic"
    
    # Strength helps forge better tools
    stat_requirement = "strength"
    stat_weight = 0.4
    
    tool_tags = ["forge", "anvil", "hammer"]
    consumable_tags = ["iron_ingot", "iron_ingot", "wooden_handle"]
    
    output_prototypes = [{
        "key": "pickaxe",
        "typeclass": "typeclasses.objects.Tool",
        "desc": "A sturdy pickaxe with an iron head and wooden handle.",
        "tags": [
            ("pickaxe", "item_type"),
            ("tool", "item_type"),
            ("pickaxe", "crafting_tool")  # Can be used as tool in recipes
        ],
        "attrs": [
            ("tool_type", "mining"),
            ("efficiency", 1.0),  # Modified by quality
            ("durability", 100),
            ("max_durability", 100),
            ("repair_materials", ["iron_ingot"]),
            ("weight", 4),
            ("quality", 50)  # Base quality
        ]
    }]
    
    def calculate_quality(self):
        """Tools get bonus durability from quality."""
        quality_name, quality_modifier = super().calculate_quality()
        
        # Apply quality to tool stats
        for proto in self.output_prototypes:
            attrs = proto.get("attrs", [])
            for i, (attr_name, attr_val) in enumerate(attrs):
                if attr_name == "efficiency":
                    attrs[i] = ("efficiency", attr_val * quality_modifier)
                elif attr_name == "max_durability":
                    attrs[i] = ("max_durability", int(attr_val * quality_modifier))
                elif attr_name == "durability":
                    # Current durability matches max
                    max_dur = int(100 * quality_modifier)
                    attrs[i] = ("durability", max_dur)
                elif attr_name == "quality":
                    attrs[i] = ("quality", int(50 * quality_modifier))
        
        return quality_name, quality_modifier


class PrecisionToolsRecipe(SkillBasedRecipe):
    """Craft precision tools for engineering work."""
    
    name = "precision tools"
    skill_requirement = "engineering"
    difficulty = 45
    craft_time = 2400  # 40 minutes
    craft_category = "craft_advanced"
    
    tool_tags = ["forge", "grindstone", "workbench"]
    consumable_tags = ["steel_ingot", "steel_ingot", "brass_fitting", "leather_wrap", "tool_case"]
    
    output_prototypes = [{
        "key": "precision tools",
        "typeclass": "typeclasses.objects.ToolKit",
        "desc": "A leather case containing finely-crafted precision instruments.",
        "tags": [
            ("precision_tools", "item_type"),
            ("tool", "item_type"),
            ("precision_tools", "crafting_tool"),
            ("toolkit", "container_type")
        ],
        "attrs": [
            ("tool_type", "precision"),
            ("engineering_bonus", 15),
            ("contains_tools", [
                "fine_pliers", "jewelers_screwdriver", "calipers",
                "miniature_hammer", "tension_wrench"
            ]),
            ("durability", 80),
            ("max_durability", 80),
            ("repair_materials", ["steel_ingot"]),
            ("weight", 2)
        ]
    }]


class WorkbenchRecipe(SkillAndStatRecipe):
    """Build a workbench for crafting."""
    
    name = "workbench"
    skill_requirement = "crafting"
    difficulty = 35
    craft_time = 3600  # 1 hour
    craft_category = "craft_basic"
    
    stat_requirement = "strength"
    stat_weight = 0.3
    
    tool_tags = ["hammer", "saw", "measuring_tape"]
    consumable_tags = ["wooden_plank", "wooden_plank", "wooden_plank", "wooden_plank",
                      "iron_nails", "iron_nails", "vise"]
    
    output_prototypes = [{
        "key": "sturdy workbench",
        "typeclass": "typeclasses.objects.CraftingStation",
        "desc": "A solid wooden workbench with a built-in vise and tool storage.",
        "tags": [
            ("workbench", "item_type"),
            ("crafting_station", "item_type"),
            ("workbench", "crafting_tool"),
            ("furniture", "item_type")
        ],
        "attrs": [
            ("station_type", "general"),
            ("crafting_bonus", 10),  # +10% success rate
            ("tool_storage", 20),  # Can store 20 items
            ("portable", False),  # Too heavy to move easily
            ("weight", 50),
            ("workshop_level", 1)  # Basic workshop
        ]
    }]


class ForgeRecipe(SkillAndStatRecipe):
    """Build a forge for metalworking - needed for advanced crafting."""
    
    name = "forge"
    skill_requirement = "engineering"
    difficulty = 60
    craft_time = 7200  # 2 hours
    craft_category = "craft_advanced"
    
    stat_requirement = "strength"
    stat_weight = 0.5  # Very physical work
    
    tool_tags = ["hammer", "tongs", "masonry_tools"]
    consumable_tags = ["stone_block", "stone_block", "stone_block", "stone_block",
                      "iron_grate", "bellows", "chimney_pipe", "fire_bricks"]
    
    output_prototypes = [{
        "key": "smithing forge",
        "typeclass": "typeclasses.objects.Forge",
        "desc": "A stone forge with bellows and chimney, ready for metalworking.",
        "tags": [
            ("forge", "item_type"),
            ("crafting_station", "item_type"),
            ("forge", "crafting_tool"),
            ("heat_source", "capability")
        ],
        "attrs": [
            ("station_type", "metalworking"),
            ("max_temperature", 1500),  # Celsius
            ("fuel_type", "coal"),
            ("fuel_capacity", 20),
            ("current_fuel", 0),
            ("crafting_bonus", 20),  # +20% for metal recipes
            ("portable", False),
            ("weight", 200),
            ("workshop_level", 2),  # Advanced workshop
            ("requires_chimney", True)
        ]
    }]
    
    def pre_craft(self, **kwargs):
        """Check if location can support a forge."""
        super().pre_craft(**kwargs)
        
        location = self.crafter.location
        if location.db.indoor and not location.db.workshop:
            err = "You need a proper workshop space to build a forge!"
            self.msg(err)
            raise CraftingValidationError(err)
</file>

<file path="world/tests/__init__.py">
"""
Test package for the Fantasy Steampunk MUD.

This package contains all unit tests for game systems.
"""
</file>

<file path="world/tests/test_characters.py">
"""
Tests for Character typeclass and trait systems.
"""
from evennia.utils.test_resources import EvenniaTest
from evennia.utils import create
from typeclasses.characters import Character


class TestCharacterTraits(EvenniaTest):
    """Test character trait categories and functionality."""
    
    def setUp(self):
        """Set up test character."""
        super().setUp()
        # Create a test character with traits using Evennia's create_object
        self.test_char = create.create_object(
            Character, 
            key="TestChar", 
            location=self.room1
        )
    
    def test_trait_categories_exist(self):
        """Test that all three trait categories are initialized."""
        # Access the properties to ensure they're created
        stats = self.test_char.stats
        traits = self.test_char.traits
        skills = self.test_char.skills
        
        self.assertIsNotNone(stats)
        self.assertIsNotNone(traits)
        self.assertIsNotNone(skills)
        
        # Verify they are TraitHandlers
        self.assertEqual(type(stats).__name__, 'TraitHandler')
        self.assertEqual(type(traits).__name__, 'TraitHandler')
        self.assertEqual(type(skills).__name__, 'TraitHandler')
    
    def test_stat_values(self):
        """Test stat traits have correct default values."""
        # All stats should start at 10
        self.assertEqual(self.test_char.stats.strength.value, 10)
        self.assertEqual(self.test_char.stats.dexterity.value, 10)
        self.assertEqual(self.test_char.stats.constitution.value, 10)
        self.assertEqual(self.test_char.stats.intelligence.value, 10)
        self.assertEqual(self.test_char.stats.wisdom.value, 10)
        self.assertEqual(self.test_char.stats.charisma.value, 10)
        
        # Test stat modification
        self.test_char.stats.strength.base = 15
        self.assertEqual(self.test_char.stats.strength.value, 15)
        
        # Test modifier
        self.test_char.stats.strength.mod = 2
        self.assertEqual(self.test_char.stats.strength.value, 17)
    
    def test_survival_trait_initialization(self):
        """Test survival traits start at correct values."""
        # All survival traits should start at 100 (full)
        self.assertEqual(self.test_char.traits.hunger.value, 100)
        self.assertEqual(self.test_char.traits.thirst.value, 100)
        self.assertEqual(self.test_char.traits.fatigue.value, 100)
        self.assertEqual(self.test_char.traits.health.value, 100)
        
        # Test descriptions
        self.assertEqual(self.test_char.traits.hunger.desc(), "full")
        self.assertEqual(self.test_char.traits.thirst.desc(), "hydrated")
        self.assertEqual(self.test_char.traits.fatigue.desc(), "energized")
        self.assertEqual(self.test_char.traits.health.desc(), "healthy")
    
    def test_survival_trait_decay_rates(self):
        """Test that survival traits have correct decay rates set."""
        # Check decay rates (per second, will be converted to per hour in gametime)
        self.assertEqual(self.test_char.traits.hunger.rate, -2.0)
        self.assertEqual(self.test_char.traits.thirst.rate, -3.0)
        self.assertEqual(self.test_char.traits.fatigue.rate, -1.0)
        self.assertEqual(self.test_char.traits.health.rate, 0)  # Health doesn't auto-decay
    
    def test_survival_trait_modification(self):
        """Test modifying survival traits."""
        # Test direct modification
        self.test_char.traits.hunger.current = 50
        self.assertEqual(self.test_char.traits.hunger.value, 50)
        self.assertEqual(self.test_char.traits.hunger.desc(), "hungry")
        
        # Test boundaries
        self.test_char.traits.hunger.current = -10
        self.assertEqual(self.test_char.traits.hunger.value, 0)  # Should clamp to min
        
        self.test_char.traits.hunger.current = 150
        self.assertEqual(self.test_char.traits.hunger.value, 100)  # Should clamp to max
    
    def test_skill_progression(self):
        """Test skill advancement."""
        # Skills should start at 0
        self.assertEqual(self.test_char.skills.crafting.value, 0)
        self.assertEqual(self.test_char.skills.crafting.desc(), "untrained")
        
        # Test skill increase
        self.test_char.skills.crafting.current = 15
        self.assertEqual(self.test_char.skills.crafting.value, 15)
        self.assertEqual(self.test_char.skills.crafting.desc(), "novice")
        
        # Test skill boundaries
        self.test_char.skills.crafting.current = 150
        self.assertEqual(self.test_char.skills.crafting.value, 100)  # Should clamp to max
    
    def test_convenience_methods(self):
        """Test the convenience methods for accessing traits."""
        # Test get_stat
        self.assertEqual(self.test_char.get_stat("strength"), 10)
        self.assertIsNone(self.test_char.get_stat("invalid_stat"))
        
        # Test get_trait_status
        value, desc = self.test_char.get_trait_status("hunger")
        self.assertEqual(value, 100)
        self.assertEqual(desc, "full")
        
        # Test get_skill_level
        value, desc = self.test_char.get_skill_level("crafting")
        self.assertEqual(value, 0)
        self.assertEqual(desc, "untrained")
        
        # Test modify_trait
        self.assertTrue(self.test_char.modify_trait("hunger", -20))
        self.assertEqual(self.test_char.traits.hunger.value, 80)
        self.assertFalse(self.test_char.modify_trait("invalid_trait", 10))
        
        # Test improve_skill
        self.assertTrue(self.test_char.improve_skill("crafting", 5))
        self.assertEqual(self.test_char.skills.crafting.value, 5)
        self.assertFalse(self.test_char.improve_skill("invalid_skill"))


class TestCharacterSurvival(EvenniaTest):
    """Test survival mechanics specific functionality."""
    
    def setUp(self):
        """Set up test character."""
        super().setUp()
        self.char = create.create_object(
            Character,
            key="SurvivalChar",
            location=self.room1
        )
    
    def test_hunger_boundaries(self):
        """Test hunger can't go below 0 or above 100."""
        # Test lower boundary
        self.char.traits.hunger.current = -50
        self.assertEqual(self.char.traits.hunger.value, 0)
        self.assertEqual(self.char.traits.hunger.desc(), "starving")
        
        # Test upper boundary
        self.char.traits.hunger.current = 200
        self.assertEqual(self.char.traits.hunger.value, 100)
        self.assertEqual(self.char.traits.hunger.desc(), "full")
    
    def test_thirst_progression(self):
        """Test thirst descriptions at different levels."""
        thirst_levels = [
            (0, "dehydrated"),
            (15, "dehydrated"),  # Updated based on new bounds
            (30, "parched"),
            (50, "thirsty"),
            (75, "slightly thirsty"),
            (95, "refreshed")
        ]
        
        for value, expected_desc in thirst_levels:
            self.char.traits.thirst.current = value
            self.assertEqual(self.char.traits.thirst.desc(), expected_desc)
    
    def test_survival_summary(self):
        """Test survival summary generation."""
        # Set some test values
        self.char.traits.hunger.current = 75
        self.char.traits.thirst.current = 50
        self.char.traits.fatigue.current = 25
        self.char.traits.health.current = 90
        
        summary = self.char.get_survival_summary()
        
        # Check that all traits are in summary
        self.assertIn("Hunger: 75% (peckish)", summary)
        self.assertIn("Thirst: 50% (thirsty)", summary)
        self.assertIn("Fatigue: 25% (very tired)", summary)
        self.assertIn("Health: 90% (bruised)", summary)
    
    def test_skill_summary(self):
        """Test skill summary generation."""
        # Set some test values
        self.char.skills.crafting.current = 35
        self.char.skills.hunting.current = 15
        self.char.skills.engineering.current = 75
        
        summary = self.char.get_skill_summary()
        
        # Check that skills show correct values and descriptions
        self.assertIn("Crafting: 35 (apprentice)", summary)
        self.assertIn("Hunting: 15 (novice)", summary)
        self.assertIn("Engineering: 75 (expert)", summary)
        self.assertIn("Foraging: 0 (untrained)", summary)


class TestCharacterStatModifiers(EvenniaTest):
    """Test stat modifier functionality."""
    
    def setUp(self):
        """Set up test character."""
        super().setUp()
        self.char = create.create_object(
            Character,
            key="ModChar",
            location=self.room1
        )
    
    def test_stat_modifiers(self):
        """Test that stat modifiers work correctly."""
        # Base value
        self.assertEqual(self.char.stats.strength.value, 10)
        
        # Add modifier
        self.char.stats.strength.mod = 3
        self.assertEqual(self.char.stats.strength.value, 13)
        
        # Change base
        self.char.stats.strength.base = 12
        self.assertEqual(self.char.stats.strength.value, 15)  # 12 + 3
        
        # Test multiplier
        self.char.stats.strength.mult = 1.5
        # The result will be a float, so we compare with the exact value
        self.assertEqual(self.char.stats.strength.value, 22.5)  # (12 + 3) * 1.5
    
    def test_gauge_reset(self):
        """Test resetting gauge traits to full."""
        # Deplete some traits
        self.char.traits.hunger.current = 25
        self.char.traits.thirst.current = 10
        
        # Reset them
        self.char.traits.hunger.reset()
        self.char.traits.thirst.reset()
        
        # Should be back to full
        self.assertEqual(self.char.traits.hunger.value, 100)
        self.assertEqual(self.char.traits.thirst.value, 100)
    
    def test_skill_reset(self):
        """Test resetting skills back to base."""
        # Increase skill
        self.char.skills.crafting.current = 50
        
        # Reset
        self.char.skills.crafting.reset()
        
        # Should be back to base (0)
        self.assertEqual(self.char.skills.crafting.value, 0)


class TestCharacterEdgeCases(EvenniaTest):
    """Test edge cases and error handling."""
    
    def setUp(self):
        """Set up test character."""
        super().setUp()
        self.char = create.create_object(
            Character,
            key="EdgeCaseChar",
            location=self.room1
        )
    
    def test_modify_trait_edge_cases(self):
        """Test edge cases for modify_trait method."""
        # Test modifying with extreme values
        self.assertTrue(self.char.modify_trait("hunger", 1000))
        self.assertEqual(self.char.traits.hunger.value, 100)  # Should cap at max
    
        self.assertTrue(self.char.modify_trait("hunger", -2000))
        self.assertEqual(self.char.traits.hunger.value, 0)  # Should cap at min
    
        # Test modifying with float values
        # Note: Gauge traits with integer base will round the result
        self.char.traits.hunger.current = 50
        self.assertTrue(self.char.modify_trait("hunger", 5.5))
        # Since base is an integer, the value gets rounded
        self.assertEqual(self.char.traits.hunger.value, 55)  # 55.5 rounds to 55
    
        # Test modifying non-existent trait
        self.assertFalse(self.char.modify_trait("nonexistent", 10))
    
    def test_improve_skill_edge_cases(self):
        """Test edge cases for improve_skill method."""
        # Test improving beyond max
        self.char.skills.crafting.current = 95
        self.assertTrue(self.char.improve_skill("crafting", 20))
        self.assertEqual(self.char.skills.crafting.value, 100)  # Should cap at max
        
        # Test improving with negative value (skill decrease)
        self.char.skills.hunting.current = 50
        self.assertTrue(self.char.improve_skill("hunting", -10))
        self.assertEqual(self.char.skills.hunting.value, 40)
        
        # Test improving below min
        self.char.skills.foraging.current = 5
        self.assertTrue(self.char.improve_skill("foraging", -10))
        self.assertEqual(self.char.skills.foraging.value, 0)  # Should cap at min
    
    def test_convenience_methods_with_empty_traits(self):
        """Test convenience methods on character without traits."""
        # Create a character and manually remove traits
        empty_char = create.create_object(
            Character,
            key="EmptyChar",
            location=self.room1
        )
        # Don't remove the handlers, just test with non-existent trait names
        
        # Test all convenience methods with non-existent traits
        self.assertIsNone(empty_char.get_stat("nonexistent"))
        self.assertEqual(empty_char.get_trait_status("nonexistent"), (None, None))
        self.assertEqual(empty_char.get_skill_level("nonexistent"), (None, None))
        self.assertFalse(empty_char.modify_trait("nonexistent", 10))
        self.assertFalse(empty_char.improve_skill("nonexistent", 5))
    
    def test_summary_methods_formatting(self):
        """Test summary methods with various trait values."""
        # Set all traits to different values
        self.char.traits.hunger.current = 0
        self.char.traits.thirst.current = 33
        self.char.traits.fatigue.current = 66
        self.char.traits.health.current = 100
        
        summary = self.char.get_survival_summary()
        lines = summary.split('\n')
        self.assertEqual(len(lines), 4)  # Should have 4 lines
        
        # Check each line format
        self.assertTrue(all(': ' in line and '% (' in line and ')' in line for line in lines))
        
        # Set skills to various levels
        self.char.skills.crafting.current = 0
        self.char.skills.hunting.current = 25
        self.char.skills.foraging.current = 50
        self.char.skills.engineering.current = 75
        self.char.skills.survival.current = 90
        self.char.skills.trading.current = 100
        
        skill_summary = self.char.get_skill_summary()
        skill_lines = skill_summary.split('\n')
        self.assertEqual(len(skill_lines), 6)  # Should have 6 lines
        
        # Verify all skill levels are represented
        self.assertIn("untrained", skill_summary)
        self.assertIn("novice", skill_summary)
        self.assertIn("journeyman", skill_summary)
        self.assertIn("expert", skill_summary)
        self.assertIn("master", skill_summary)


class TestTraitModifiersAndMultipliers(EvenniaTest):
    """Test advanced trait modifications with mods and multipliers."""
    
    def setUp(self):
        """Set up test character."""
        super().setUp()
        self.char = create.create_object(
            Character,
            key="ModTestChar",
            location=self.room1
        )
    
    def test_skill_with_modifiers(self):
        """Test skills with mod and mult values."""
        # Test base + mod
        self.char.skills.crafting.base = 20
        self.char.skills.crafting.mod = 10
        self.assertEqual(self.char.skills.crafting.value, 30)  # 20 + 10
        
        # Test with current different from base
        self.char.skills.crafting.current = 40
        self.assertEqual(self.char.skills.crafting.value, 50)  # 40 + 10
        
        # Test with multiplier
        self.char.skills.crafting.mult = 1.5
        self.assertEqual(self.char.skills.crafting.value, 75)  # (40 + 10) * 1.5
        
        # Test that desc() still works correctly with modifiers
        self.assertEqual(self.char.skills.crafting.desc(), "expert")  # 75 is in 70-89 range
    
    def test_survival_trait_modifiers(self):
        """Test survival traits with modifiers don't break gauge behavior."""
        # Gauges use mod differently - it affects max, not current
        self.char.traits.hunger.base = 100
        self.char.traits.hunger.mod = 20
        
        # Max should be base + mod
        self.assertEqual(self.char.traits.hunger.max, 120)
        
        # Current should start at max
        self.char.traits.hunger.reset()
        self.assertEqual(self.char.traits.hunger.value, 120)
        
        # Test with multiplier
        self.char.traits.hunger.mult = 0.5
        self.assertEqual(self.char.traits.hunger.max, 60)  # (100 + 20) * 0.5
    
    def test_stat_modifier_combinations(self):
        """Test various combinations of base, mod, and mult."""
        # Test negative modifier
        self.char.stats.strength.base = 15
        self.char.stats.strength.mod = -3
        self.assertEqual(self.char.stats.strength.value, 12)
    
        # Test fractional multiplier with negative mod
        self.char.stats.strength.mult = 0.8
        # Use assertAlmostEqual for floating point comparison to avoid precision issues
        self.assertAlmostEqual(self.char.stats.strength.value, 9.6, places=1)
    
        # Test zero multiplier (edge case)
        self.char.stats.strength.mult = 0
        self.assertEqual(self.char.stats.strength.value, 0)
    
        # Reset and test large multiplier
        self.char.stats.strength.mult = 3.0
        self.char.stats.strength.mod = 5
        self.assertEqual(self.char.stats.strength.value, 60)  # (15 + 5) * 3


class TestAutoDecaySimulation(EvenniaTest):
    """Test auto-decay behavior (without actual time passing)."""
    
    def setUp(self):
        """Set up test character."""
        super().setUp()
        self.char = create.create_object(
            Character,
            key="DecayTestChar",
            location=self.room1
        )
    
    def test_decay_rates_are_set(self):
        """Verify decay rates are properly configured."""
        # Check all decay rates
        self.assertEqual(self.char.traits.hunger.rate, -2.0)
        self.assertEqual(self.char.traits.thirst.rate, -3.0)
        self.assertEqual(self.char.traits.fatigue.rate, -1.0)
        self.assertEqual(self.char.traits.health.rate, 0)
        
        # Verify rates are negative (decay) except health
        self.assertLess(self.char.traits.hunger.rate, 0)
        self.assertLess(self.char.traits.thirst.rate, 0)
        self.assertLess(self.char.traits.fatigue.rate, 0)
        self.assertEqual(self.char.traits.health.rate, 0)
    
    def test_manual_decay_simulation(self):
        """Simulate decay by manually adjusting values."""
        # Start with known values
        self.char.traits.hunger.current = 100
        self.char.traits.thirst.current = 100
        self.char.traits.fatigue.current = 100
        
        # Simulate 1 hour of decay manually
        self.char.traits.hunger.current += self.char.traits.hunger.rate
        self.char.traits.thirst.current += self.char.traits.thirst.rate
        self.char.traits.fatigue.current += self.char.traits.fatigue.rate
        
        # Check values decreased correctly
        self.assertEqual(self.char.traits.hunger.value, 98)  # 100 - 2
        self.assertEqual(self.char.traits.thirst.value, 97)  # 100 - 3
        self.assertEqual(self.char.traits.fatigue.value, 99)  # 100 - 1
        
        # Simulate many hours until hitting bottom
        self.char.traits.hunger.current = 5
        self.char.traits.hunger.current += self.char.traits.hunger.rate * 3  # 3 hours
        self.assertEqual(self.char.traits.hunger.value, 0)  # Should stop at 0
    
    def test_trait_descriptions_during_decay(self):
        """Test that descriptions update correctly as traits decay."""
        # Test hunger descriptions at each threshold
        hunger_thresholds = [
            (100, "full"),
            (95, "satisfied"),
            (75, "peckish"),
            (55, "hungry"),
            (35, "very hungry"),
            (15, "starving"),
            (0, "starving")
        ]
        
        for value, expected_desc in hunger_thresholds:
            self.char.traits.hunger.current = value
            self.assertEqual(
                self.char.traits.hunger.desc(), 
                expected_desc,
                f"At hunger {value}, expected '{expected_desc}' but got '{self.char.traits.hunger.desc()}'"
            )


class TestCharacterCreationVariations(EvenniaTest):
    """Test creating characters in different ways."""
    
    def test_multiple_character_creation(self):
        """Test that multiple characters have independent traits."""
        char1 = create.create_object(Character, key="Char1", location=self.room1)
        char2 = create.create_object(Character, key="Char2", location=self.room1)
        
        # Modify char1's traits
        char1.stats.strength.base = 15
        char1.traits.hunger.current = 50
        char1.skills.crafting.current = 30
        
        # Verify char2's traits are unaffected
        self.assertEqual(char2.stats.strength.value, 10)
        self.assertEqual(char2.traits.hunger.value, 100)
        self.assertEqual(char2.skills.crafting.value, 0)
        
        # Verify modifications stuck to char1
        self.assertEqual(char1.stats.strength.value, 15)
        self.assertEqual(char1.traits.hunger.value, 50)
        self.assertEqual(char1.skills.crafting.value, 30)
    
    def test_character_persistence_simulation(self):
        """Test that trait values would persist (without actual save/load)."""
        char = create.create_object(Character, key="PersistChar", location=self.room1)
        
        # Modify various traits
        char.stats.intelligence.mod = 3
        char.traits.thirst.current = 75
        char.skills.engineering.current = 45
        
        # Get the underlying data (this is what would be saved)
        stats_data = char.attributes.get("stats", category="traits")
        traits_data = char.attributes.get("traits", category="traits")
        skills_data = char.attributes.get("skills", category="traits")
        
        # Verify data structures exist
        self.assertIsNotNone(stats_data)
        self.assertIsNotNone(traits_data)
        self.assertIsNotNone(skills_data)
        
        # Verify our modifications are in the data
        self.assertEqual(stats_data.get("intelligence", {}).get("mod"), 3)
        self.assertEqual(traits_data.get("thirst", {}).get("current"), 75)
        self.assertEqual(skills_data.get("engineering", {}).get("current"), 45)
</file>

<file path="world/tests/test_clothing.py">
# world/tests/test_clothing.py
"""
Tests for the clothing system and survival benefits.
"""

from evennia.utils.test_resources import EvenniaTest
from evennia.utils import create
from typeclasses.characters import Character
from typeclasses.objects import (
    WinterCloak, LeatherBoots, RainCoat, WorkGloves,
    WoolenHat, EngineeringGoggles, DecorativeScarf,
    CamouflageCloak, SurvivalClothing
)
from typeclasses.rooms import Room
from unittest.mock import patch


class TestClothingSystem(EvenniaTest):
    """Test basic clothing functionality."""
    
    def setUp(self):
        super().setUp()
        self.char = create.create_object(Character, key="TestChar", location=self.room1)
        self.cloak = create.create_object(WinterCloak, key="winter cloak", location=self.char)
        self.boots = create.create_object(LeatherBoots, key="boots", location=self.char)
    
    def test_clothing_creation(self):
        """Test clothing items are created with correct properties."""
        # Check cloak properties
        self.assertEqual(self.cloak.db.clothing_type, "cloak")
        self.assertEqual(self.cloak.db.warmth_value, 25)
        self.assertIn("snow", self.cloak.db.weather_protection)
        self.assertIn("wind", self.cloak.db.weather_protection)
        self.assertIn("rain", self.cloak.db.weather_protection)
        self.assertEqual(self.cloak.db.stat_modifiers.get("constitution"), 1)
        
        # Check boots properties
        self.assertEqual(self.boots.db.clothing_type, "shoes")
        self.assertEqual(self.boots.db.warmth_value, 5)
        self.assertIn("rain", self.boots.db.weather_protection)
        
        # Check visibility properties (from Object inheritance)
        self.assertEqual(self.cloak.db.visibility_size, "large")
        self.assertEqual(self.boots.db.visibility_size, "normal")
    
    def test_wearing_clothing(self):
        """Test wearing clothing items."""
        # Initially not worn
        self.assertFalse(self.cloak.db.worn)
        
        # Wear the cloak
        self.cloak.wear(self.char, True)
        self.assertTrue(self.cloak.db.worn)
        
        # Check it's in worn items
        worn = self.char.get_worn_clothes()
        self.assertIn(self.cloak, worn)
    
    def test_removing_clothing(self):
        """Test removing worn clothing."""
        # Wear then remove
        self.cloak.wear(self.char, True)
        self.cloak.remove(self.char)
        
        self.assertFalse(self.cloak.db.worn)
        worn = self.char.get_worn_clothes()
        self.assertNotIn(self.cloak, worn)
    
    def test_clothing_stat_modifiers(self):
        """Test stat modifiers from clothing."""
        # Check base constitution
        base_con = self.char.stats.constitution.value
        
        # Wear cloak with +1 CON
        self.cloak.wear(self.char, True)
        
        # Verify modifier was applied
        self.assertEqual(self.char.stats.constitution.mod, 1)
        self.assertEqual(self.char.stats.constitution.value, base_con + 1)
        
        # Remove and verify modifier removed
        self.cloak.remove(self.char)
        self.assertEqual(self.char.stats.constitution.mod, 0)
        self.assertEqual(self.char.stats.constitution.value, base_con)
    
    def test_multiple_clothing_modifiers(self):
        """Test multiple items providing stat bonuses."""
        # Create gloves with STR bonus
        gloves = create.create_object(WorkGloves, key="test_gloves", location=self.char)
        
        # Wear both items
        self.cloak.wear(self.char, True)
        gloves.wear(self.char, True)
        
        # Check both modifiers applied
        self.assertEqual(self.char.stats.constitution.mod, 1)  # From cloak
        self.assertEqual(self.char.stats.strength.mod, 1)      # From gloves
    
    def test_warmth_calculation(self):
        """Test total warmth calculation."""
        # No warmth when naked
        self.assertEqual(self.char.get_total_warmth(), 0)
        
        # Wear cloak
        self.cloak.wear(self.char, True)
        self.assertEqual(self.char.get_total_warmth(), 25)
        
        # Wear boots too
        self.boots.wear(self.char, True)
        self.assertEqual(self.char.get_total_warmth(), 30)  # 25 + 5
    
    def test_weather_protection(self):
        """Test weather protection detection."""
        # No protection initially
        self.assertFalse(self.char.has_weather_protection("rain"))
        self.assertFalse(self.char.has_weather_protection("snow"))
        
        # Wear cloak
        self.cloak.wear(self.char, True)
        
        # Now protected from rain, snow, wind
        self.assertTrue(self.char.has_weather_protection("rain"))
        self.assertTrue(self.char.has_weather_protection("snow"))
        self.assertTrue(self.char.has_weather_protection("wind"))
        
        # But not from made-up weather
        self.assertFalse(self.char.has_weather_protection("acid_rain"))
    
    def test_clothing_durability(self):
        """Test clothing condition system."""
        # Start at max durability
        self.assertEqual(self.cloak.db.durability, 100)
        self.assertEqual(self.cloak.db.max_durability, 100)
        
        # Damage it
        self.cloak.db.durability = 50
        condition = self.cloak.get_condition_string()
        self.assertIn("worn but serviceable", condition)
        
        # Damage more
        self.cloak.db.durability = 10
        condition = self.cloak.get_condition_string()
        self.assertIn("badly damaged", condition)
    
    def test_clothing_type_limits(self):
        """Test that clothing type limits are enforced."""
        # Create multiple hats
        hat1 = create.create_object(WoolenHat, key="hat 1", location=self.char)
        hat2 = create.create_object(WoolenHat, key="hat 2", location=self.char)
        
        # Wear first hat - should work
        hat1.wear(self.char, True)
        self.assertTrue(hat1.db.worn)
        
        # Try to wear second hat - should respect limit
        # (This would be enforced by the command, not the object)
        # Just verify we can check the count
        from evennia.contrib.game_systems.clothing.clothing import single_type_count
        worn = self.char.get_worn_clothes()
        hat_count = single_type_count(worn, "hat")
        self.assertEqual(hat_count, 1)
    
    def test_clothing_covering(self):
        """Test clothing covering mechanics."""
        # Create undershirt and top
        undershirt = create.create_object(SurvivalClothing, key="test_undershirt", location=self.char)
        undershirt.db.clothing_type = "undershirt"
        top = create.create_object(SurvivalClothing, key="test_top", location=self.char)
        top.db.clothing_type = "top"
        
        # Wear undershirt first
        undershirt.wear(self.char, True)
        
        # Wear top - should auto-cover undershirt
        top.wear(self.char, True)
        
        # Check covering
        self.assertEqual(undershirt.db.covered_by, top)
        
        # Covered items shouldn't show in description
        visible_worn = self.char.get_worn_clothes(exclude_covered=True)
        self.assertIn(top, visible_worn)
        self.assertNotIn(undershirt, visible_worn)
    
    # I test_clothing.py, uppdatera test_dropped_clothing_visibility metoden:

    def test_dropped_clothing_visibility(self):
        """Test that dropped clothing has appropriate visibility."""
        # Create various clothing items
        cloak = create.create_object(WinterCloak, key="test_cloak_vis", location=self.char)
        hat = create.create_object(WoolenHat, key="test_hat_vis", location=self.char)
        goggles = create.create_object(EngineeringGoggles, key="test_goggles_vis", location=self.char)
    
        # Check visibility properties are set
        self.assertEqual(cloak.db.visibility_size, "large")  # Easy to spot
        self.assertEqual(hat.db.visibility_size, "small")    # Harder to see
        self.assertEqual(goggles.db.luminosity, "shiny")     # Catches light
    
        # Drop them in a room
        cloak.move_to(self.room1)
        hat.move_to(self.room1)
        goggles.move_to(self.room1)
    
        # Test visibility calculations
        # FIX: Anropa calculate_object_visibility på ROOM objektet, inte character
        cloak_vis = self.room1.calculate_object_visibility(cloak, self.char1)
        hat_vis = self.room1.calculate_object_visibility(hat, self.char1)
    
        # Large cloak should be more visible than small hat
        self.assertGreater(cloak_vis, hat_vis)
    
    def test_worn_clothing_not_visible_in_room(self):
        """Test that worn clothing doesn't show in room contents."""
        cloak = create.create_object(WinterCloak, key="test_worn_cloak", location=self.char)
        
        # When worn, should not appear in room's visible objects
        cloak.wear(self.char, True)
        visible_objects = self.room1.get_visible_objects(self.char)
        self.assertNotIn(cloak, visible_objects)
    
    def test_special_clothing_properties(self):
        """Test special properties of specific clothing types."""
        # Test engineering goggles
        goggles = create.create_object(EngineeringGoggles, key="test_eng_goggles", location=self.char)
        self.assertEqual(goggles.db.stat_modifiers.get("intelligence"), 2)
        self.assertEqual(goggles.db.engineering_bonus, 10)
        self.assertEqual(goggles.db.luminosity, "shiny")
        
        # Test work gloves
        gloves = create.create_object(WorkGloves, key="test_work_gloves", location=self.char)
        self.assertEqual(gloves.db.crafting_bonus, 5)
        
        # Test decorative scarf
        scarf = create.create_object(DecorativeScarf, key="test_scarf", location=self.char)
        self.assertEqual(scarf.db.stat_modifiers.get("charisma"), 1)
        self.assertEqual(scarf.db.contrast, "bright")
    
    def test_camouflage_clothing(self):
        """Test camouflage clothing properties."""
        camo_cloak = create.create_object(CamouflageCloak, key="test_camo_cloak", location=self.char)
        
        # Check camouflage properties
        self.assertEqual(camo_cloak.db.contrast, "camouflaged")
        self.assertEqual(camo_cloak.db.camouflage_type, "natural")
        self.assertEqual(camo_cloak.db.stealth_bonus, 20)
        
        # Test visibility when dropped in appropriate environment
        forest_room = create.create_object(Room, key="Forest")
        forest_room.db.desc = "A dense forest with thick undergrowth."
        camo_cloak.move_to(forest_room)
        
        # Should be harder to see in forest
        visibility = forest_room.calculate_object_visibility(camo_cloak, self.char)
        self.assertLess(visibility, 0.5)  # Hard to spot
    
    def test_at_drop_removes_worn_clothing(self):
        """Test that dropping worn clothing removes it."""
        # Wear the cloak
        self.cloak.wear(self.char, True)
        self.assertTrue(self.cloak.db.worn)
        
        # Drop it
        self.cloak.at_drop(self.char)
        
        # Should no longer be worn
        self.assertFalse(self.cloak.db.worn)
        self.assertNotIn(self.cloak, self.char.get_worn_clothes())
    
    def test_clothing_appearance(self):
        """Test clothing appearance shows condition and benefits."""
        # Check appearance includes benefits
        appearance = self.cloak.return_appearance(self.char)
        
        # Should show warmth
        self.assertIn("warmth", appearance.lower())
        self.assertIn("25", appearance)
        
        # Should show weather protection
        self.assertIn("protects against", appearance.lower())
        self.assertIn("snow", appearance.lower())
        
        # Should show stat modifiers
        self.assertIn("constitution +1", appearance.lower())
        
        # Damage it and check condition shows
        self.cloak.db.durability = 30
        appearance = self.cloak.return_appearance(self.char)
        self.assertIn("well-worn and fraying", appearance.lower())


class TestEnvironmentalEffects(EvenniaTest):
    """Test environmental effects on characters based on clothing."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Test Room")
        self.char = create.create_object(Character, key="TestChar", location=self.room)
        self.room.db.indoor = False
    
    def test_cold_weather_effects(self):
        """Test cold weather effects without protection."""
        with patch.object(self.room, 'get_season', return_value="winter"):
            with patch.object(self.room, 'get_current_weather', return_value=["snow"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should have severe cold effects
                self.assertGreater(effects["fatigue_rate_mod"], 1.5)
                self.assertGreater(effects["health_drain"], 0)
                self.assertTrue(any("freezing" in msg for msg in effects["messages"]))
    
    def test_cold_weather_with_protection(self):
        """Test cold weather with warm clothing."""
        # Give character warm clothes
        cloak = create.create_object(WinterCloak, key="test_cold_cloak", location=self.char)
        cloak.wear(self.char, True)
        
        with patch.object(self.room, 'get_season', return_value="winter"):
            with patch.object(self.room, 'get_current_weather', return_value=["clear"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should have minimal effects with 25 warmth
                self.assertLess(effects["fatigue_rate_mod"], 1.3)
                self.assertEqual(effects["health_drain"], 0)
    
    def test_rain_without_protection(self):
        """Test rain effects without rain gear."""
        with patch.object(self.room, 'get_season', return_value="spring"):
            with patch.object(self.room, 'get_current_weather', return_value=["rain"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should increase fatigue from being wet
                self.assertGreater(effects["fatigue_rate_mod"], 1.0)
                self.assertTrue(any("wet" in msg for msg in effects["messages"]))
    
    def test_rain_with_protection(self):
        """Test rain with proper rain gear."""
        # Give character raincoat
        raincoat = create.create_object(RainCoat, key="test_raincoat", location=self.char)
        raincoat.wear(self.char, True)
        
        with patch.object(self.room, 'get_season', return_value="spring"):
            with patch.object(self.room, 'get_current_weather', return_value=["rain"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should have no rain effects
                self.assertEqual(effects["fatigue_rate_mod"], 1.0)
                self.assertFalse(any("wet" in msg for msg in effects["messages"]))
    
    def test_overheating_in_summer(self):
        """Test wearing too much in hot weather."""
        # Wear heavy winter gear
        cloak = create.create_object(WinterCloak, key="test_summer_cloak", location=self.char)
        cloak.wear(self.char, True)
        
        with patch.object(self.room, 'get_season', return_value="summer"):
            with patch.object(self.room, 'get_time_of_day', return_value="noon"):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should increase thirst and fatigue
                self.assertGreater(effects["thirst_rate_mod"], 1.0)
                self.assertGreater(effects["fatigue_rate_mod"], 1.0)
                # Check for any heat-related message
                self.assertTrue(any("heat" in msg.lower() or "overheat" in msg.lower() or "sweat" in msg.lower() 
                                  for msg in effects["messages"]))
    
    def test_indoor_protection(self):
        """Test that indoor rooms protect from weather."""
        self.room.db.indoor = True
        
        with patch.object(self.room, 'get_season', return_value="winter"):
            with patch.object(self.room, 'get_current_weather', return_value=["storm"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should have no weather effects indoors
                self.assertEqual(effects["fatigue_rate_mod"], 1.0)
                self.assertEqual(effects["health_drain"], 0)
                self.assertEqual(len(effects["messages"]), 0)
    
    def test_layered_protection(self):
        """Test multiple layers of clothing provide cumulative warmth."""
        # Wear multiple items
        hat = create.create_object(WoolenHat, key="test_layer_hat", location=self.char)
        cloak = create.create_object(WinterCloak, key="test_layer_cloak", location=self.char)
        boots = create.create_object(LeatherBoots, key="test_layer_boots", location=self.char)
        gloves = create.create_object(WorkGloves, key="test_layer_gloves", location=self.char)
        
        hat.wear(self.char, True)
        cloak.wear(self.char, True)
        boots.wear(self.char, True)
        gloves.wear(self.char, True)
        
        # Total warmth should be sum of all
        total_warmth = self.char.get_total_warmth()
        expected = 8 + 25 + 5 + 3  # hat + cloak + boots + gloves
        self.assertEqual(total_warmth, expected)
        
        # Should be well protected in winter
        with patch.object(self.room, 'get_season', return_value="winter"):
            with patch.object(self.room, 'get_current_weather', return_value=["snow"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Should have no cold effects with 41 warmth
                self.assertEqual(effects["fatigue_rate_mod"], 1.0)
                self.assertEqual(effects["health_drain"], 0)
    
    def test_wind_protection(self):
        """Test wind effects and protection."""
        with patch.object(self.room, 'get_season', return_value="winter"):
            with patch.object(self.room, 'get_current_weather', return_value=["wind"]):
                # Without protection
                effects = self.room.get_environmental_effects(self.char)
                self.assertGreater(effects["fatigue_rate_mod"], 1.0)
                self.assertTrue(any("wind" in msg for msg in effects["messages"]))
                
                # With wind protection
                cloak = create.create_object(WinterCloak, key="test_wind_cloak", location=self.char)
                cloak.wear(self.char, True)
                effects = self.room.get_environmental_effects(self.char)
                # Still cold but wind doesn't add extra penalty
                self.assertLess(effects["fatigue_rate_mod"], 2.0)
    
    def test_storm_conditions(self):
        """Test severe storm combines multiple effects."""
        with patch.object(self.room, 'get_season', return_value="winter"):
            with patch.object(self.room, 'get_current_weather', return_value=["storm"]):
                effects = self.room.get_environmental_effects(self.char)
                
                # Storm in winter should be very harsh
                self.assertGreater(effects["fatigue_rate_mod"], 1.5)
                self.assertGreater(effects["health_drain"], 0)
                
                # Full protection gear
                raincoat = create.create_object(RainCoat, key="test_storm_raincoat", location=self.char)
                cloak = create.create_object(WinterCloak, key="test_storm_cloak", location=self.char)
                raincoat.wear(self.char, True)
                cloak.wear(self.char, True)
                
                effects = self.room.get_environmental_effects(self.char)
                # Should be mostly protected
                self.assertLess(effects["fatigue_rate_mod"], 1.5)


class TestClothingCommands(EvenniaTest):
    """Test clothing-related commands."""
    
    def setUp(self):
        super().setUp()
        self.char = create.create_object(Character, key="Tester", location=self.room1)
        self.cloak = create.create_object(WinterCloak, key="cloak", location=self.char)
        
        # Add command set to character
        from commands.default_cmdsets import CharacterCmdSet
        self.char.cmdset.add(CharacterCmdSet)
    
    def test_wear_command(self):
        """Test the wear command."""
        # Execute wear command
        self.char.execute_cmd("wear cloak")
        
        # Check that cloak is worn
        self.assertTrue(self.cloak.db.worn)
        
        # Test with style
        self.char.execute_cmd("wear cloak = draped dramatically")
        self.assertEqual(self.cloak.db.worn, "draped dramatically")
    
    def test_remove_command(self):
        """Test the remove command."""
        # First wear the cloak
        self.cloak.wear(self.char, True)
        self.assertTrue(self.cloak.db.worn)
        
        # Now remove it
        self.char.execute_cmd("remove cloak")
        self.assertFalse(self.cloak.db.worn)
    
    def test_clothing_status_command(self):
        """Test the clothing status command."""
        # Wear some items
        self.cloak.wear(self.char, True)
        boots = create.create_object(LeatherBoots, key="test_boots", location=self.char)
        boots.wear(self.char, True)
        
        self.char.execute_cmd("clothing status")
        # Command should execute without error
        # (actual output testing would require capturing messages)
    
    def test_repair_command_basics(self):
        """Test basic repair command functionality."""
        # Damage the cloak
        self.cloak.db.durability = 50
        
        # Try to repair without materials
        self.char.execute_cmd("repair cloak")
        # Should fail due to lack of materials
        
        # Give character required crafting skill
        self.char.skills.crafting.base = 30
        
        # Try again (still no materials)
        self.char.execute_cmd("repair cloak")
        # Should still fail but for different reason
    
    def test_inventory_shows_worn_items(self):
        """Test that inventory separates worn and carried items."""
        # Have some worn and some carried items
        self.cloak.wear(self.char, True)
        
        carried_item = create.create_object("typeclasses.objects.Object", 
                                          key="backpack", 
                                          location=self.char)
        
        self.char.execute_cmd("inventory")
        # Should show both worn and carried sections
        # (actual output testing would require message capture)
    
    def test_cover_command(self):
        """Test covering clothing with other clothing."""
        # Create items that can cover each other
        shirt = create.create_object(SurvivalClothing, key="shirt", location=self.char)
        shirt.db.clothing_type = "top"
        jacket = create.create_object(SurvivalClothing, key="jacket", location=self.char)
        jacket.db.clothing_type = "outerwear"
        
        # Wear shirt first
        shirt.wear(self.char, True)
        self.assertTrue(shirt.db.worn)
        
        # The cover command should handle wearing the jacket
        # But we need to test the actual command behavior
        # For now, wear the jacket manually before covering
        jacket.wear(self.char, True)
        
        # Now use cover command
        self.char.execute_cmd("cover shirt with jacket")
        
        # Verify shirt is covered by jacket
        self.assertEqual(shirt.db.covered_by, jacket)
    
    def test_uncover_command(self):
        """Test uncovering clothing."""
        # Setup covered clothing
        shirt = create.create_object(SurvivalClothing, key="shirt", location=self.char)
        shirt.db.clothing_type = "top"
        jacket = create.create_object(SurvivalClothing, key="jacket", location=self.char)
        jacket.db.clothing_type = "outerwear"
        
        shirt.wear(self.char, True)
        jacket.wear(self.char, True)
        shirt.db.covered_by = jacket
        
        # Uncover the shirt
        self.char.execute_cmd("uncover shirt")
        
        # Should no longer be covered
        self.assertIsNone(shirt.db.covered_by)
</file>

<file path="world/tests/test_cooldowns.py">
# world/tests/test_cooldowns.py
"""
Tests for the cooldown system integration.
"""

from evennia.utils.test_resources import EvenniaTest
from evennia.utils import create
from typeclasses.characters import Character
from unittest.mock import patch, MagicMock
import time


class TestCharacterCooldowns(EvenniaTest):
    """Test cooldown functionality on characters."""
    
    def setUp(self):
        super().setUp()
        self.char = create.create_object(Character, key="TestChar", location=self.room1)
    
    def test_cooldown_handler_exists(self):
        """Test that characters have cooldown handler."""
        self.assertTrue(hasattr(self.char, 'cooldowns'))
        self.assertIsNotNone(self.char.cooldowns)
    
    def test_basic_cooldown_functionality(self):
        """Test basic cooldown operations."""
        # No cooldown initially
        self.assertTrue(self.char.cooldowns.ready("test"))
        self.assertEqual(self.char.cooldowns.time_left("test"), 0)
        
        # Add cooldown
        self.char.cooldowns.add("test", 10)
        self.assertFalse(self.char.cooldowns.ready("test"))
        self.assertGreater(self.char.cooldowns.time_left("test"), 0)
        
        # Reset cooldown
        self.char.cooldowns.reset("test")
        self.assertTrue(self.char.cooldowns.ready("test"))
    
    def test_multiple_cooldowns(self):
        """Test multiple cooldowns can be tracked."""
        self.char.cooldowns.add("gather", 300)
        self.char.cooldowns.add("rest", 180)
        self.char.cooldowns.add("craft", 600)
        
        self.assertFalse(self.char.cooldowns.ready("gather"))
        self.assertFalse(self.char.cooldowns.ready("rest"))
        self.assertFalse(self.char.cooldowns.ready("craft"))
        
        # Reset one
        self.char.cooldowns.reset("rest")
        self.assertTrue(self.char.cooldowns.ready("rest"))
        self.assertFalse(self.char.cooldowns.ready("gather"))
    
    def test_skill_based_cooldown_reduction(self):
        """Test that skills reduce cooldown duration."""
        # Test with no skill
        base_cooldown = 300
        modifier = self.char.get_cooldown_modifier("gather", "foraging")
        self.assertEqual(modifier, 1.0)  # No reduction
        
        # Test with mid-level skill
        self.char.skills.foraging.base = 50
        modifier = self.char.get_cooldown_modifier("gather", "foraging")
        self.assertEqual(modifier, 0.75)  # 25% reduction
        
        # Test with max skill
        self.char.skills.foraging.base = 100
        modifier = self.char.get_cooldown_modifier("gather", "foraging")
        self.assertEqual(modifier, 0.5)  # 50% reduction
    
    def test_constitution_affects_physical_cooldowns(self):
        """Test that constitution reduces physical action cooldowns."""
        # Set up character with high constitution
        self.char.stats.constitution.base = 15  # +5 above base
        self.char.skills.foraging.base = 0  # No skill bonus
        
        # Apply a gather cooldown
        base_cooldown = 300
        actual = self.char.apply_cooldown("gather", base_cooldown, "foraging")
        
        # Should be reduced by CON bonus
        # Base modifier = 1.0 (no skill)
        # CON reduction = (15-10) * 0.01 = 0.05 (5% reduction)
        # Total modifier = 1.0 * (1 - 0.05) = 0.95
        expected = int(300 * 0.95)  # 285
        self.assertEqual(actual, expected)
    
    def test_apply_cooldown_with_all_bonuses(self):
        """Test cooldown application with skill and stat bonuses."""
        # Set up skilled character with good constitution
        self.char.skills.foraging.base = 80  # Expert forager
        self.char.stats.constitution.base = 14  # +4 CON
        
        base_cooldown = 300
        actual = self.char.apply_cooldown("gather", base_cooldown, "foraging")
        
        # Skill modifier: 0.5 + (0.5 * 20/100) = 0.6
        # CON modifier: 1 - 0.04 = 0.96
        # Total: 300 * 0.6 * 0.96 = 172.8 → 172
        expected = int(300 * 0.6 * 0.96)
        self.assertEqual(actual, expected)
    
    def test_cooldown_persistence(self):
        """Test that cooldowns persist on character."""
        # Add some cooldowns
        self.char.cooldowns.add("gather", 300)
        self.char.cooldowns.add("craft", 600)
        
        # Verify they're stored
        self.assertIn("gather", self.char.cooldowns.all)
        self.assertIn("craft", self.char.cooldowns.all)
        
        # Clear all
        self.char.cooldowns.clear()
        self.assertEqual(len(self.char.cooldowns.all), 0)


# world/tests/test_cooldowns.py (rekommenderad version)

class TestCooldownCommands(EvenniaTest):
    """Test cooldown integration in commands."""
    
    def setUp(self):
        super().setUp()
        self.char = create.create_object(Character, key="Gatherer", location=self.room1)
        
        # Add command set
        from commands.default_cmdsets import CharacterCmdSet
        self.char.cmdset.add(CharacterCmdSet)
    
    def test_gather_respects_cooldown(self):
        """Test that gather command checks cooldown."""
        # The actual cooldown functionality is tested in TestCharacterCooldowns
        # Here we just verify that commands can use cooldowns
        
        # Set a cooldown
        self.char.cooldowns.add("gather", 300)
        
        # Verify it's set
        self.assertFalse(self.char.cooldowns.ready("gather"))
        
        # Verify time remaining
        time_left = self.char.cooldowns.time_left("gather", use_int=True)
        self.assertEqual(time_left, 300)
    
    def test_forage_separate_cooldown(self):
        """Test forage has its own cooldown."""
        # Apply gather cooldown
        self.char.cooldowns.add("gather", 300)
        
        # Forage should still work
        self.assertTrue(self.char.cooldowns.ready("forage"))
        
        # Add forage cooldown
        self.char.cooldowns.add("forage", 180)
        
        # Now both should be on cooldown
        self.assertFalse(self.char.cooldowns.ready("gather"))
        self.assertFalse(self.char.cooldowns.ready("forage"))
        
        # And they should have different times
        gather_time = self.char.cooldowns.time_left("gather", use_int=True)
        forage_time = self.char.cooldowns.time_left("forage", use_int=True)
        self.assertNotEqual(gather_time, forage_time)
    
    @patch('commands.survival_commands.delay')
    def test_rest_cooldown_after_completion(self, mock_delay):
        """Test rest command applies cooldown after rest completes."""
        # Set character fatigue to allow rest
        self.char.traits.fatigue.current = 50  # Tired
        
        # Execute rest command
        self.char.execute_cmd("rest")
        
        # Get the delayed function
        self.assertEqual(mock_delay.call_count, 1)
        delay_time, delayed_func = mock_delay.call_args[0]
        
        # Rest should mark character as resting
        self.assertTrue(self.char.db.is_resting)
        
        # Execute the delayed function
        delayed_func()
        
        # Should no longer be resting
        self.assertFalse(self.char.db.is_resting)
        
        # Should have rest cooldown
        self.assertFalse(self.char.cooldowns.ready("rest"))
    
    def test_status_shows_cooldowns(self):
        """Test status command displays active cooldowns."""
        # Set some cooldowns
        self.char.cooldowns.add("gather", 120)
        self.char.cooldowns.add("rest", 60)
        
        # Capture output
        messages = []
        old_msg = self.char.msg
        self.char.msg = lambda text, **kwargs: messages.append(text)
        
        self.char.execute_cmd("status")
        
        # Check output includes cooldowns
        output = "\n".join(messages)
        self.assertIn("Active Cooldowns:", output)
        self.assertIn("gather:", output)
        self.assertIn("rest:", output)
        
        self.char.msg = old_msg
    
    def test_eat_no_cooldown(self):
        """Test eat command has no cooldown."""
        # Create food
        food = create.create_object("typeclasses.objects.Object", 
                                  key="bread", 
                                  location=self.char)
        food.tags.add("food", category="item_type")
        food.db.nutrition = 20
        
        # Eat once
        self.char.traits.hunger.current = 70  # Make somewhat hungry
        self.char.execute_cmd("eat bread")
        
        # Verify bread was consumed
        bread_search = self.char.search("bread", location=self.char, quiet=True)
        self.assertFalse(bread_search)  # Should not find it
        
        # Create another food
        food2 = create.create_object("typeclasses.objects.Object",
                                   key="apple",
                                   location=self.char)
        food2.tags.add("food", category="item_type")
        food2.db.nutrition = 10
        
        # Should be able to eat again immediately (if hungry)
        self.char.traits.hunger.current = 50  # Make hungry again
        self.char.execute_cmd("eat apple")
        
        # Verify apple was consumed
        apple_search = self.char.search("apple", location=self.char, quiet=True)
        self.assertFalse(apple_search)  # Should not find it


class TestCooldownBalancing(EvenniaTest):
    """Test cooldown balance and gameplay impact."""
    
    def setUp(self):
        super().setUp()
        self.novice = create.create_object(Character, key="Novice", location=self.room1)
        self.expert = create.create_object(Character, key="Expert", location=self.room1)
        
        # Set up expert with high skills
        self.expert.skills.foraging.base = 90
        self.expert.skills.crafting.base = 85
        self.expert.skills.survival.base = 95
        self.expert.stats.constitution.base = 16
    
    def test_skill_progression_benefit(self):
        """Test that experts can work significantly faster."""
        base_gather = 300
        
        # Novice cooldown
        novice_cd = self.novice.apply_cooldown("gather", base_gather, "foraging")
        
        # Expert cooldown
        expert_cd = self.expert.apply_cooldown("gather", base_gather, "foraging")
        
        # Expert should be significantly faster
        self.assertLess(expert_cd, novice_cd * 0.6)  # At least 40% faster
        
        # But not too fast (game balance)
        self.assertGreater(expert_cd, 120)  # At least 2 minutes
    
    def test_different_action_cooldowns(self):
        """Test that different actions have appropriate cooldowns."""
        # Use novice character
        # Quick actions
        self.novice.apply_cooldown("forage", 180)  # 3 min
        forage_time = self.novice.cooldowns.time_left("forage")
        
        # Standard actions
        self.novice.apply_cooldown("gather", 300)  # 5 min
        gather_time = self.novice.cooldowns.time_left("gather")
        
        # Long actions
        self.novice.apply_cooldown("craft_advanced", 1800)  # 30 min
        craft_time = self.novice.cooldowns.time_left("craft_advanced")
        
        # Verify hierarchy
        self.assertLess(forage_time, gather_time)
        self.assertLess(gather_time, craft_time)
    
    def test_cooldown_cleanup(self):
        """Test that expired cooldowns are cleaned up."""
        # Use novice character
        # Add several cooldowns
        with patch('time.time', return_value=0):
            self.novice.cooldowns.add("test1", 10)
            self.novice.cooldowns.add("test2", 20)
            self.novice.cooldowns.add("test3", 30)
        
        # Advance time
        with patch('time.time', return_value=25):
            # Cleanup should remove expired cooldowns
            self.novice.cooldowns.cleanup()
            
            # test1 and test2 should be gone
            self.assertTrue(self.novice.cooldowns.ready("test1"))
            self.assertTrue(self.novice.cooldowns.ready("test2"))
            
            # test3 should still be active
            self.assertFalse(self.novice.cooldowns.ready("test3"))
</file>

<file path="world/tests/test_crafting.py">
# world/tests/test_crafting.py
"""
Tests for the crafting system integration.
"""

from evennia.utils.test_resources import EvenniaTest
from evennia.utils import create
from typeclasses.characters import Character
from typeclasses.objects import Object
from world.recipes.survival_recipes import BreadRecipe, WaterContainerRecipe
from world.recipes.tool_recipes import PickaxeRecipe
from evennia.contrib.game_systems.crafting import craft
from evennia.contrib.game_systems.crafting.crafting import CraftingValidationError
from unittest.mock import patch, MagicMock, call


class TestCraftingIntegration(EvenniaTest):
    """Test crafting system with our custom recipes."""
    
    def setUp(self):
        super().setUp()
        self.crafter = create.create_object(Character, key="Crafter", location=self.room1)
        
        # Set up some basic skills
        self.crafter.skills.crafting.base = 30
        self.crafter.skills.engineering.base = 20
        self.crafter.skills.survival.base = 25
        
        # Clear any cooldowns before each test
        if hasattr(self.crafter, 'cooldowns'):
            self.crafter.cooldowns.clear()
    
    def test_recipe_skill_requirements(self):
        """Test that recipes check skill requirements."""
        # Create ingredients for bread
        flour = create.create_object(Object, key="flour", location=self.crafter)
        flour.tags.add("flour", category="crafting_material")
        
        water = create.create_object(Object, key="water", location=self.crafter)
        water.tags.add("water", category="crafting_material")
        
        yeast = create.create_object(Object, key="yeast", location=self.crafter)
        yeast.tags.add("yeast", category="crafting_material")
        
        salt = create.create_object(Object, key="salt", location=self.crafter)
        salt.tags.add("salt", category="crafting_material")
        
        # Create tools
        oven = create.create_object(Object, key="oven", location=self.room1)
        oven.tags.add("oven", category="crafting_tool")
        
        bowl = create.create_object(Object, key="bowl", location=self.crafter)
        bowl.tags.add("mixing_bowl", category="crafting_tool")
        
        # Bread requires crafting 15, we have 30 - should succeed
        recipe = BreadRecipe(self.crafter, flour, water, yeast, salt, oven, bowl)
        
        # Pre-craft should pass
        try:
            recipe.pre_craft()
            validation_passed = True
        except:
            validation_passed = False
            
        self.assertTrue(validation_passed)
        
        # Lower skill and try again
        self.crafter.skills.crafting.base = 10
        recipe2 = BreadRecipe(self.crafter, flour, water, yeast, salt, oven, bowl)
        
        with self.assertRaises(Exception):  # Should raise CraftingValidationError
            recipe2.pre_craft()
    
    def test_cooldown_integration(self):
        """Test that crafting applies cooldowns."""
        # Give crafter materials using seed
        tools, consumables = WaterContainerRecipe.seed(location=self.crafter)
        
        # Craft waterskin
        recipe = WaterContainerRecipe(self.crafter, *(tools + consumables))
        
        # Should not be on cooldown initially
        self.assertTrue(self.crafter.cooldowns.ready("craft_basic"))
        
        # Craft the item
        recipe.pre_craft()
        result = recipe.do_craft()
        recipe.post_craft(result)
        
        # Should now be on cooldown
        self.assertFalse(self.crafter.cooldowns.ready("craft_basic"))
        
        # Check cooldown duration is affected by skill
        time_left = self.crafter.cooldowns.time_left("craft_basic")
        # With 30 crafting skill, should have some reduction
        self.assertLess(time_left, 180)  # Less than base 3 minutes
    
    def test_quality_system(self):
        """Test that skill affects quality."""
        # Create a skilled crafter
        skilled_crafter = create.create_object(Character, key="Master", location=self.room1)
        skilled_crafter.skills.crafting.base = 80  # Expert level
        
        # Create pickaxe ingredients
        tools, consumables = PickaxeRecipe.seed(location=skilled_crafter)
        
        # Mock random to ensure consistent quality
        with patch('world.recipes.base_recipes.random', return_value=0.5):
            recipe = PickaxeRecipe(skilled_crafter, *(tools + consumables))
            recipe.pre_craft()  # This sets crafter_skill
            
            quality_name, quality_mod = recipe.calculate_quality()
            
            # With skill 80 vs difficulty 20, should get excellent or masterwork
            self.assertIn(quality_name, ["excellent", "masterwork"])
            self.assertGreater(quality_mod, 1.3)  # Should have significant bonus
    
    def test_stat_bonus_crafting(self):
        """Test that stats provide bonuses to crafting."""
        # PickaxeRecipe uses strength
        self.crafter.stats.strength.base = 16  # +6 bonus
        
        tools, consumables = PickaxeRecipe.seed(location=self.crafter)
        recipe = PickaxeRecipe(self.crafter, *(tools + consumables))
        
        with patch('world.recipes.base_recipes.random', return_value=0.5):
            recipe.pre_craft()
            quality_name, quality_mod = recipe.calculate_quality()
            
            # Should get some bonus from strength
            self.assertGreater(quality_mod, 1.0)
    
    # I world/tests/test_crafting.py

    def test_craft_function_integration(self):
        """Test using the craft() function directly."""
        # Set up for bread crafting
        tools, consumables = BreadRecipe.seed(location=self.crafter)
    
        # Mock random for consistent results - need to mock the right random
        # Success chance with skill 30 is 0.65, so we need random < 0.65 to succeed
        with patch('world.recipes.base_recipes.random') as mock_random:
            mock_random.return_value = 0.5
            # Create the recipe instance and craft directly
            recipe = BreadRecipe(self.crafter, *(tools + consumables))
            
            # Run pre_craft first to validate inputs
            recipe.pre_craft()
            
            # Now verify we have the right inputs after validation
            self.assertEqual(len(recipe.validated_tools), 2)  # oven and mixing_bowl
            self.assertEqual(len(recipe.validated_consumables), 4)  # flour, water, yeast, salt
            
            result = recipe.do_craft()
            recipe.post_craft(result)
        
            # Check that result is a list with objects
            self.assertTrue(result)  # Should have items in list
            self.assertIsInstance(result, list)  # Should be a list
            self.assertGreater(len(result), 0)  # Should have at least one item
            self.assertTrue(any("bread" in item.key for item in result))
        
            # Check quality was applied
            self.assertTrue(hasattr(result[0].db, 'quality'))
            self.assertTrue(hasattr(result[0].db, 'crafted_by'))
            self.assertEqual(result[0].db.crafted_by, "Crafter")

    
    def test_tool_quality_affects_crafting(self):
        """Test that tool quality affects results."""
        # Create high-quality tools
        hammer = create.create_object(Object, key="masterwork hammer", location=self.crafter)
        hammer.tags.add("hammer", category="crafting_tool")
        hammer.db.quality = 90  # High quality tool
        
        # Create normal tools and materials
        forge = create.create_object(Object, key="forge", location=self.room1)
        forge.tags.add("forge", category="crafting_tool")
        forge.db.quality = 50  # Average
        
        anvil = create.create_object(Object, key="anvil", location=self.room1)
        anvil.tags.add("anvil", category="crafting_tool")
        anvil.db.quality = 50
        
        # Materials
        iron1 = create.create_object(Object, key="iron", location=self.crafter)
        iron1.tags.add("iron_ingot", category="crafting_material")
        iron2 = create.create_object(Object, key="iron", location=self.crafter)
        iron2.tags.add("iron_ingot", category="crafting_material")
        handle = create.create_object(Object, key="handle", location=self.crafter)
        handle.tags.add("wooden_handle", category="crafting_material")
        
        # Craft with high-quality hammer
        recipe = PickaxeRecipe(self.crafter, hammer, forge, anvil, iron1, iron2, handle)
        
        with patch('world.recipes.base_recipes.random', return_value=0.5):
            recipe.pre_craft()
            quality_name, quality_mod = recipe.calculate_quality()
            
            # Should get bonus from high-quality hammer
            self.assertGreater(quality_mod, 1.0)


class TestCraftingCommands(EvenniaTest):
    """Test crafting commands."""
    
    def setUp(self):
        super().setUp()
        self.char = create.create_object(Character, key="Tester", location=self.room1)
        self.char.skills.crafting.base = 20
        
        # Add command set
        from commands.default_cmdsets import CharacterCmdSet
        self.char.cmdset.add(CharacterCmdSet)
    
    @patch('evennia.contrib.game_systems.crafting.crafting._RECIPE_CLASSES', {
        "bread": BreadRecipe,
        "waterskin": WaterContainerRecipe
    })
    def test_craft_list_command(self):
        """Test the craft list command."""
        # Capture output
        old_msg = self.char.msg
        messages = []
        self.char.msg = lambda text, **kwargs: messages.append(text)
        
        self.char.execute_cmd("craft list")
        
        # Check output
        output = "\n".join(messages)
        self.assertIn("Crafting Recipes", output)
        self.assertIn("Your Skills:", output)
        
        # Should show recipes with difficulty
        self.assertIn("bread", output.lower())
        self.assertIn("waterskin", output.lower())
        
        self.char.msg = old_msg
    
    @patch('evennia.contrib.game_systems.crafting.crafting._RECIPE_CLASSES', {
        "bread": BreadRecipe
    })
    def test_craft_info_command(self):
        """Test the craft info command."""
        old_msg = self.char.msg
        messages = []
        self.char.msg = lambda text, **kwargs: messages.append(text)
        
        self.char.execute_cmd("craft info bread")
        
        output = "\n".join(messages)
        self.assertIn("Bread", output)
        self.assertIn("Requirements:", output)
        self.assertIn("Tools needed:", output)
        self.assertIn("Ingredients:", output)
        self.assertIn("flour", output)
        
        self.char.msg = old_msg
    
    def test_recipes_command(self):
        """Test the recipes command."""
        # Give character some known recipes
        self.char.db.known_recipes = ["bread", "waterskin", "pickaxe"]
        self.char.db.craft_counts = {"bread": 5, "waterskin": 2, "pickaxe": 1}
        self.char.db.best_quality = {"bread": "good", "pickaxe": "excellent"}
        
        old_msg = self.char.msg
        messages = []
        self.char.msg = lambda text, **kwargs: messages.append(text)
        
        self.char.execute_cmd("recipes")
        
        output = "\n".join(messages)
        self.assertIn("Your Known Recipes", output)
        self.assertIn("bread", output)
        self.assertIn("crafted 5x", output)
        self.assertIn("best: good", output)
        
        self.char.msg = old_msg
    
    def test_recipes_stats_command(self):
        """Test the recipes stats command."""
        # Set up some stats
        self.char.db.crafting_stats = {
            'total_crafted': 25,
            'total_failed': 5,
            'quality_counts': {
                'poor': 2,
                'average': 10,
                'good': 8,
                'excellent': 5
            }
        }
        
        old_msg = self.char.msg
        messages = []
        self.char.msg = lambda text, **kwargs: messages.append(text)
        
        self.char.execute_cmd("recipes stats")
        
        output = "\n".join(messages)
        self.assertIn("Crafting Statistics", output)
        self.assertIn("Total items crafted: 25", output)
        self.assertIn("Success rate: 83.3%", output)
        self.assertIn("Quality Distribution", output)
        
        self.char.msg = old_msg


# world/tests/test_crafting.py

class TestCraftingTracking(EvenniaTest):
    """Test that crafting statistics are tracked properly."""
    
    def setUp(self):
        super().setUp()
        self.crafter = create.create_object(Character, key="Tracker", location=self.room1)
        self.crafter.skills.crafting.base = 50
        
        # Clear any cooldowns before each test
        if hasattr(self.crafter, 'cooldowns'):
            self.crafter.cooldowns.clear()
        
        # Initialize tracking dicts on the crafter
        self.crafter.db.known_recipes = []
        self.crafter.db.craft_counts = {}
        self.crafter.db.best_quality = {}
        self.crafter.db.crafting_stats = {
            'total_crafted': 0,
            'total_failed': 0,
            'quality_counts': {}
        }
    
    def test_successful_craft_tracking(self):
        """Test that successful crafts are tracked."""
        # Craft bread using the normal craft function
        tools, consumables = BreadRecipe.seed(location=self.crafter)
        
        with patch('world.recipes.base_recipes.random') as mock_random:
            mock_random.return_value = 0.5
            recipe = BreadRecipe(self.crafter, *(tools + consumables))
            recipe.pre_craft()
            result = recipe.do_craft()
            recipe.post_craft(result)
        
        # Check that craft succeeded
        self.assertTrue(result)
        self.assertIsInstance(result, list)
        self.assertGreater(len(result), 0)
        
        # Check tracking
        self.assertIn("bread", self.crafter.db.known_recipes)
        self.assertEqual(self.crafter.db.craft_counts.get("bread", 0), 1)
        self.assertEqual(self.crafter.db.crafting_stats['total_crafted'], 1)
        
        # Check quality tracking
        quality_counts = self.crafter.db.crafting_stats.get('quality_counts', {})
        self.assertGreater(sum(quality_counts.values()), 0)
    
    def test_multiple_craft_tracking(self):
        """Test that multiple crafts are tracked correctly."""
        # Craft bread three times
        for i in range(3):
            # Clear cooldowns between crafts
            if hasattr(self.crafter, 'cooldowns'):
                self.crafter.cooldowns.clear()
                
            tools, consumables = BreadRecipe.seed(location=self.crafter)
            with patch('world.recipes.base_recipes.random') as mock_random:
                mock_random.return_value = 0.5
                recipe = BreadRecipe(self.crafter, *(tools + consumables))
                recipe.pre_craft()
                result = recipe.do_craft()
                recipe.post_craft(result)
                self.assertTrue(result)
        
        # Check counts
        self.assertEqual(self.crafter.db.craft_counts.get("bread", 0), 3)
        self.assertEqual(self.crafter.db.crafting_stats['total_crafted'], 3)
    
    def test_quality_tracking(self):
        """Test that quality is tracked correctly."""
        # Craft with different skill levels to get different qualities
        
        # Low skill - should get average or poor quality
        self.crafter.skills.crafting.base = 20
        tools, consumables = BreadRecipe.seed(location=self.crafter)
        with patch('random.random', return_value=0.9):
            recipe = BreadRecipe(self.crafter, *(tools + consumables))
            recipe.pre_craft()
            result = recipe.do_craft()
            recipe.post_craft(result)
        
        # Clear cooldown before second craft
        if hasattr(self.crafter, 'cooldowns'):
            self.crafter.cooldowns.clear()
            
        # High skill - should get better quality
        self.crafter.skills.crafting.base = 80
        tools, consumables = BreadRecipe.seed(location=self.crafter)
        with patch('world.recipes.base_recipes.random') as mock_random:
            mock_random.return_value = 0.5
            recipe = BreadRecipe(self.crafter, *(tools + consumables))
            recipe.pre_craft()
            result = recipe.do_craft()
            recipe.post_craft(result)
        
        # Check that we have quality data
        quality_counts = self.crafter.db.crafting_stats.get('quality_counts', {})
        self.assertGreater(len(quality_counts), 0)
        
        # Check best quality tracking
        best_quality = self.crafter.db.best_quality.get("bread", "poor")
        self.assertIn(best_quality, ["poor", "average", "good", "fine", "excellent", "masterwork"])
    
    def test_failed_craft_tracking(self):
        """Test that failed crafts are tracked."""
        # Set skill too low for recipe
        self.crafter.skills.crafting.base = 5  # Below bread's requirement of 15
        
        tools, consumables = BreadRecipe.seed(location=self.crafter)
        
        # This should fail due to low skill
        try:
            recipe = BreadRecipe(self.crafter, *(tools + consumables))
            recipe.pre_craft()
            result = []
        except CraftingValidationError:
            result = []
        
        # Should return empty list on failure
        self.assertEqual(result, [])
        
        # Should not be in known recipes since it failed
        self.assertNotIn("bread", self.crafter.db.known_recipes)
        
        # Should not increment craft count
        self.assertEqual(self.crafter.db.craft_counts.get("bread", 0), 0)
        
        # Total crafted should still be 0
        self.assertEqual(self.crafter.db.crafting_stats['total_crafted'], 0)
    
    def test_different_recipe_tracking(self):
        """Test tracking multiple different recipes."""
        # First craft bread
        self.crafter.skills.crafting.base = 30
        tools, consumables = BreadRecipe.seed(location=self.crafter)
        with patch('world.recipes.base_recipes.random') as mock_random:
            mock_random.return_value = 0.5
            recipe = BreadRecipe(self.crafter, *(tools + consumables))
            recipe.pre_craft()
            result = recipe.do_craft()
            recipe.post_craft(result)
        
        # Clear cooldown before second craft
        if hasattr(self.crafter, 'cooldowns'):
            self.crafter.cooldowns.clear()
            
        # Then craft a waterskin
        tools2, consumables2 = WaterContainerRecipe.seed(location=self.crafter)
        with patch('world.recipes.base_recipes.random') as mock_random:
            mock_random.return_value = 0.5
            recipe2 = WaterContainerRecipe(self.crafter, *(tools2 + consumables2))
            recipe2.pre_craft()
            result2 = recipe2.do_craft()
            recipe2.post_craft(result2)
        
        # Check both are tracked
        self.assertIn("bread", self.crafter.db.known_recipes)
        self.assertIn("waterskin", self.crafter.db.known_recipes)
        
        # Check individual counts
        self.assertEqual(self.crafter.db.craft_counts.get("bread", 0), 1)
        self.assertEqual(self.crafter.db.craft_counts.get("waterskin", 0), 1)
        
        # Total should be 2
        self.assertEqual(self.crafter.db.crafting_stats['total_crafted'], 2)
    
    def test_craft_stats_initialization(self):
        """Test that craft stats are properly initialized."""
        # Create a new crafter without pre-initialized stats
        new_crafter = create.create_object(Character, key="NewCrafter", location=self.room1)
        new_crafter.skills.crafting.base = 30
        
        # Clear any cooldowns
        if hasattr(new_crafter, 'cooldowns'):
            new_crafter.cooldowns.clear()
        
        # Craft something
        tools, consumables = BreadRecipe.seed(location=new_crafter)
        # Mock random to return different values for quality calculation and success check
        # First call is for quality randomness, second is for success check
        with patch('world.recipes.base_recipes.random') as mock_random:
            mock_random.return_value = 0.5
            recipe = BreadRecipe(new_crafter, *(tools + consumables))
            recipe.pre_craft()
            result = recipe.do_craft()
            recipe.post_craft(result)
            
        # Verify the craft succeeded
        self.assertTrue(result, "Craft should have succeeded")
        self.assertGreater(len(result), 0, "Should have created at least one item")
        
        # Check that all tracking attributes were created
        self.assertTrue(hasattr(new_crafter.db, 'known_recipes'))
        self.assertTrue(hasattr(new_crafter.db, 'craft_counts'))
        self.assertTrue(hasattr(new_crafter.db, 'best_quality'))
        self.assertTrue(hasattr(new_crafter.db, 'crafting_stats'))
        
        # Check they have correct values
        self.assertIn("bread", new_crafter.db.known_recipes)
        self.assertEqual(new_crafter.db.craft_counts.get("bread", 0), 1)
        self.assertEqual(new_crafter.db.crafting_stats['total_crafted'], 1)
</file>

<file path="world/tests/test_gametime.py">
# world/tests/test_gametime.py - hela den uppdaterade test-filen med enklare test

"""
Tests for the custom gametime system.
"""

from django.test import override_settings
from evennia.utils.test_resources import EvenniaTest
from evennia.contrib.base_systems import custom_gametime
from unittest.mock import patch, MagicMock
from commands.time_commands import CmdTime, CmdUptime
from world.gametime_utils import (
    get_current_season, get_time_of_day, format_game_date,
    is_night_time, is_winter, get_seasonal_modifier
)


# Test settings to use
TEST_TIME_UNITS = {
    "sec": 1,
    "min": 60,
    "hour": 60 * 60,
    "day": 60 * 60 * 24,
    "week": 60 * 60 * 24 * 7,
    "month": 60 * 60 * 24 * 30,
    "year": 60 * 60 * 24 * 30 * 12,
}

TEST_MONTH_NAMES = [
    "Frosthold", "Icewind", "Thawmoon", "Seedtime",
    "Bloomheart", "Greentide", "Sunpeak", "Hearthfire",
    "Goldfall", "Harvestmoon", "Dimming", "Darkening"
]

TEST_SEASONS = {
    "winter": [11, 0, 1, 2],
    "spring": [3, 4, 5],
    "summer": [6, 7, 8],
    "autumn": [9, 10]
}

TEST_TIME_OF_DAY = {
    "dawn": (5, 7),
    "morning": (7, 12),
    "noon": (12, 14),
    "afternoon": (14, 17),
    "dusk": (17, 19),
    "evening": (19, 22),
    "night": (22, 5)
}


@override_settings(
    TIME_FACTOR=4,
    TIME_UNITS=TEST_TIME_UNITS,
    MONTH_NAMES=TEST_MONTH_NAMES,
    SEASONS=TEST_SEASONS,
    TIME_OF_DAY=TEST_TIME_OF_DAY
)
class TestCustomGametime(EvenniaTest):
    """Test the custom gametime system."""
    
    def test_time_factor(self):
        """Test that TIME_FACTOR is correctly applied."""
        from django.conf import settings
        self.assertEqual(settings.TIME_FACTOR, 4)
    
    def test_month_duration(self):
        """Test that months are exactly 30 days."""
        month_seconds = TEST_TIME_UNITS["month"]
        day_seconds = TEST_TIME_UNITS["day"]
        self.assertEqual(month_seconds, day_seconds * 30)
    
    def test_year_duration(self):
        """Test that years are exactly 360 days."""
        year_seconds = TEST_TIME_UNITS["year"]
        day_seconds = TEST_TIME_UNITS["day"]
        self.assertEqual(year_seconds, day_seconds * 360)
    
    def test_custom_gametime_tuple(self):
        """Test that custom_gametime returns correct tuple format."""
        with patch('evennia.utils.gametime.gametime') as mock_gametime:
            # Test 1: Simple test - just one day
            mock_seconds = TEST_TIME_UNITS["day"]
            mock_gametime.return_value = mock_seconds
            
            result = custom_gametime.custom_gametime()
            year, month, week, day, hour, minute, second = result
            
            # One day should give us day=1 (or 0 depending on implementation)
            self.assertEqual(year, 0)
            self.assertEqual(month, 0)
            self.assertEqual(hour, 0)
            self.assertEqual(minute, 0)
            self.assertEqual(second, 0)
            
            # Test 2: Complex test - let's use exact time and check hour/min/sec
            # which are more predictable
            mock_seconds = (
                TEST_TIME_UNITS["hour"] * 14 +
                TEST_TIME_UNITS["min"] * 30 +
                45
            )
            mock_gametime.return_value = mock_seconds
            
            year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
            
            # These should be exact
            self.assertEqual(hour, 14)
            self.assertEqual(minute, 30)
            self.assertEqual(second, 45)
            
            # Test 3: Test with years and months for basic functionality
            mock_seconds = (
                TEST_TIME_UNITS["year"] * 1 +
                TEST_TIME_UNITS["month"] * 3
            )
            mock_gametime.return_value = mock_seconds
            
            year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
            
            # Should have 1 year and 3 months
            self.assertEqual(year, 1)
            self.assertEqual(month, 3)
            self.assertEqual(hour, 0)
            self.assertEqual(minute, 0)
            self.assertEqual(second, 0)
    
    def test_real_seconds_until(self):
        """Test calculating real seconds until a specific game time."""
        with patch('evennia.utils.gametime.gametime') as mock_gametime:
            # Current time: 12:00:00
            current_seconds = TEST_TIME_UNITS["hour"] * 12
            mock_gametime.return_value = current_seconds
            
            # Ask for 13:00:00 (1 game hour later)
            real_seconds = custom_gametime.real_seconds_until(hour=13, min=0, sec=0)
            
            # Should be 900 real seconds (1 game hour / 4)
            self.assertEqual(real_seconds, 900)


@override_settings(
    TIME_FACTOR=4,
    TIME_UNITS=TEST_TIME_UNITS,
    MONTH_NAMES=TEST_MONTH_NAMES,
    SEASONS=TEST_SEASONS,
    TIME_OF_DAY=TEST_TIME_OF_DAY
)
class TestTimeCommands(EvenniaTest):
    """Test time-related commands."""
    
    def test_cmd_time(self):
        """Test the time command output."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Mock a specific time: Year 850, Bloomheart (month 4), day 14, 19:30
            mock_time.return_value = (850, 4, 2, 14, 19, 30, 0)
            
            # Create command instance and set up properly
            cmd = CmdTime()
            cmd.caller = self.char1
            cmd.args = ""
            cmd.cmdstring = "time"
            cmd.raw_string = "time"
            cmd.switches = []
            
            # Capture output
            messages = []
            self.char1.msg = lambda text, **kwargs: messages.append(text)
            
            # Execute command
            cmd.func()
            
            # Check the output contains expected parts
            output = "\n".join(messages)
            self.assertIn("It is evening on the 15th day of Bloomheart, in the year 850.", output)
            self.assertIn("The season is spring", output)
            self.assertIn("Game time moves at 4x speed", output)
    
    def test_cmd_time_exact(self):
        """Test the time command with exact switch."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Mock a specific time
            mock_time.return_value = (850, 4, 2, 14, 19, 30, 45)
            
            # Test with /exact switch
            cmd = CmdTime()
            cmd.caller = self.char1
            cmd.switches = ["exact"]
            
            # Capture the output
            messages = []
            self.char1.msg = lambda text, **kwargs: messages.append(text)
            
            cmd.func()
            
            # Check that exact time was included
            self.assertTrue(any("19:30:45" in msg for msg in messages))
    
    def test_cmd_uptime(self):
        """Test the uptime command."""
        with patch('evennia.utils.gametime.uptime') as mock_uptime:
            # Mock 2 hours of real uptime
            mock_uptime.return_value = 7200
            
            cmd = CmdUptime()
            cmd.caller = self.char1
            
            # Capture output
            messages = []
            self.char1.msg = lambda text, **kwargs: messages.append(text)
            
            cmd.func()
            
            # Check output contains both real and game time
            output = "\n".join(messages)
            self.assertIn("Real time: 2 hours", output)
            self.assertIn("Game time: 8 hours", output)  # 2 * 4 = 8


@override_settings(
    TIME_FACTOR=4,
    TIME_UNITS=TEST_TIME_UNITS,
    MONTH_NAMES=TEST_MONTH_NAMES,
    SEASONS=TEST_SEASONS,
    TIME_OF_DAY=TEST_TIME_OF_DAY
)
class TestGametimeUtils(EvenniaTest):
    """Test gametime utility functions."""
    
    def test_get_current_season(self):
        """Test season detection."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Test winter (month 0 - Frosthold)
            mock_time.return_value = (850, 0, 0, 0, 0, 0, 0)
            self.assertEqual(get_current_season(), "winter")
            
            # Test spring (month 4 - Bloomheart)
            mock_time.return_value = (850, 4, 0, 0, 0, 0, 0)
            self.assertEqual(get_current_season(), "spring")
            
            # Test summer (month 7 - Hearthfire)
            mock_time.return_value = (850, 7, 0, 0, 0, 0, 0)
            self.assertEqual(get_current_season(), "summer")
            
            # Test autumn (month 10 - Dimming)
            mock_time.return_value = (850, 10, 0, 0, 0, 0, 0)
            self.assertEqual(get_current_season(), "autumn")
    
    def test_get_time_of_day(self):
        """Test time of day detection."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Test dawn (6:00)
            mock_time.return_value = (0, 0, 0, 0, 6, 0, 0)
            self.assertEqual(get_time_of_day(), "dawn")
            
            # Test noon (13:00)
            mock_time.return_value = (0, 0, 0, 0, 13, 0, 0)
            self.assertEqual(get_time_of_day(), "noon")
            
            # Test night (23:00)
            mock_time.return_value = (0, 0, 0, 0, 23, 0, 0)
            self.assertEqual(get_time_of_day(), "night")
            
            # Test night (3:00 - crosses midnight)
            mock_time.return_value = (0, 0, 0, 0, 3, 0, 0)
            self.assertEqual(get_time_of_day(), "night")
    
    def test_format_game_date(self):
        """Test date formatting."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Test various dates
            mock_time.return_value = (850, 4, 0, 0, 0, 0, 0)
            self.assertEqual(format_game_date(), "1st of Bloomheart, Year 850")
            
            mock_time.return_value = (850, 4, 0, 1, 0, 0, 0)
            self.assertEqual(format_game_date(), "2nd of Bloomheart, Year 850")
            
            mock_time.return_value = (850, 4, 0, 2, 0, 0, 0)
            self.assertEqual(format_game_date(), "3rd of Bloomheart, Year 850")
            
            mock_time.return_value = (850, 4, 0, 20, 0, 0, 0)
            self.assertEqual(format_game_date(), "21st of Bloomheart, Year 850")
    
    def test_is_night_time(self):
        """Test night time detection."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Night (23:00)
            mock_time.return_value = (0, 0, 0, 0, 23, 0, 0)
            self.assertTrue(is_night_time())
            
            # Dawn (6:00)
            mock_time.return_value = (0, 0, 0, 0, 6, 0, 0)
            self.assertTrue(is_night_time())
            
            # Dusk (18:00)
            mock_time.return_value = (0, 0, 0, 0, 18, 0, 0)
            self.assertTrue(is_night_time())
            
            # Noon (12:00)
            mock_time.return_value = (0, 0, 0, 0, 12, 0, 0)
            self.assertFalse(is_night_time())
    
    def test_is_winter(self):
        """Test winter detection."""
        with patch('evennia.contrib.base_systems.custom_gametime.custom_gametime') as mock_time:
            # Winter month (Frosthold)
            mock_time.return_value = (850, 0, 0, 0, 0, 0, 0)
            self.assertTrue(is_winter())
            
            # Summer month (Sunpeak)
            mock_time.return_value = (850, 6, 0, 0, 0, 0, 0)
            self.assertFalse(is_winter())
    
    def test_get_seasonal_modifier(self):
        """Test seasonal modifiers."""
        # Test winter modifiers
        winter_mods = get_seasonal_modifier("winter")
        self.assertEqual(winter_mods["resource_availability"], 0.5)
        self.assertEqual(winter_mods["fatigue_rate"], 1.5)
        
        # Test summer modifiers
        summer_mods = get_seasonal_modifier("summer")
        self.assertEqual(summer_mods["resource_availability"], 1.5)
        self.assertEqual(summer_mods["food_decay"], 1.5)
        
        # Test current season modifiers
        with patch('world.gametime_utils.get_current_season') as mock_season:
            mock_season.return_value = "spring"
            spring_mods = get_seasonal_modifier()
            self.assertEqual(spring_mods["resource_availability"], 1.2)


class TestTraitDecayIntegration(EvenniaTest):
    """Test that trait decay will work with gametime."""
    
    def test_trait_decay_preparation(self):
        """Test that traits are ready for gametime-based decay."""
        # Verify our character has decay rates set
        self.assertEqual(self.char1.traits.hunger.rate, -2.0)
        self.assertEqual(self.char1.traits.thirst.rate, -3.0)
        self.assertEqual(self.char1.traits.fatigue.rate, -1.0)
        
        # Verify TIME_FACTOR affects decay calculation
        # With TIME_FACTOR = 4, 1 real hour = 4 game hours
        # So traits should decay 4x their rate per real hour
        from django.conf import settings
        time_factor = getattr(settings, 'TIME_FACTOR', 1)
        
        # In 1 real hour, hunger should drop by 8 (2 * 4)
        expected_hunger_per_real_hour = abs(self.char1.traits.hunger.rate) * time_factor
        self.assertEqual(expected_hunger_per_real_hour, 8.0)


class TestMonthNameIntegration(EvenniaTest):
    """Test month name integration."""
    
    def test_all_months_have_names(self):
        """Verify all 12 months have fantasy names."""
        from django.conf import settings
        self.assertEqual(len(settings.MONTH_NAMES), 12)
        
        # Verify no duplicates
        self.assertEqual(len(set(settings.MONTH_NAMES)), 12)
        
        # Verify all are strings
        for name in settings.MONTH_NAMES:
            self.assertIsInstance(name, str)
            self.assertTrue(len(name) > 0)
    
    def test_seasons_cover_all_months(self):
        """Verify every month belongs to a season."""
        from django.conf import settings
        
        all_months = set()
        for season, months in settings.SEASONS.items():
            all_months.update(months)
        
        # Should have all months 0-11
        self.assertEqual(all_months, set(range(12)))
</file>

<file path="world/tests/test_rooms.py">
# world/tests/test_rooms.py
"""
Tests for Room typeclass, visibility, and environmental systems.
"""
from evennia.utils.test_resources import EvenniaTest
from evennia.utils import create
from typeclasses.rooms import Room
from typeclasses.objects import Object, SmallValuable, Torch
from typeclasses.characters import Character
from unittest.mock import patch, MagicMock


class TestRoomVisibility(EvenniaTest):
    """Test room visibility systems."""
    
    def setUp(self):
        super().setUp()
        self.outdoor_room = create.create_object(Room, key="Outdoor Test")
        self.outdoor_room.db.indoor = False
        self.indoor_room = create.create_object(Room, key="Indoor Test")
        self.indoor_room.db.indoor = True
        
        # Move test character to outdoor room
        self.char1.move_to(self.outdoor_room, quiet=True)
    
    def test_time_based_visibility(self):
        """Test visibility changes with time of day."""
        with patch.object(self.outdoor_room, 'get_time_of_day') as mock_time:
            # Test noon visibility
            mock_time.return_value = "noon"
            self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 10)
            
            # Test night visibility
            mock_time.return_value = "night"
            self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 2)
            
            # Test dawn/dusk
            mock_time.return_value = "dawn"
            self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 5)
    
    def test_weather_visibility_impact(self):
        """Test weather affects visibility."""
        with patch.object(self.outdoor_room, 'get_current_weather') as mock_weather:
            with patch.object(self.outdoor_room, 'get_time_of_day', return_value="noon"):
                # Clear weather
                mock_weather.return_value = ["clear"]
                self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 10)
                
                # Fog severely limits visibility
                mock_weather.return_value = ["fog"]
                self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 1)
                
                # Storm conditions
                mock_weather.return_value = ["storm"]
                self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 3)
    
    def test_indoor_visibility(self):
        """Test indoor rooms always have full visibility."""
        with patch.object(self.indoor_room, 'get_time_of_day', return_value="night"):
            with patch.object(self.indoor_room, 'get_current_weather', return_value=["fog"]):
                # Indoor rooms ignore time and weather
                self.assertEqual(self.indoor_room.get_visibility_range(self.char1), 10)
    
    def test_light_source_visibility(self):
        """Test light sources improve visibility in darkness."""
        # Create a torch
        torch = create.create_object(Torch, key="torch", location=self.char1)
        
        with patch.object(self.outdoor_room, 'get_time_of_day', return_value="night"):
            # Without light
            torch.db.light_active = False
            self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 2)
            
            # With lit torch
            torch.db.light_active = True
            self.assertEqual(self.outdoor_room.get_visibility_range(self.char1), 5)


class TestObjectVisibility(EvenniaTest):
    """Test object detection in various conditions."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Test Room")
        self.char = create.create_object(Character, key="Viewer", location=self.room)
        
        # Create test objects
        self.normal_obj = create.create_object(Object, key="sword", location=self.room)
        self.small_obj = create.create_object(SmallValuable, key="coin", location=self.room)
        self.hidden_obj = create.create_object(Object, key="hidden cache", location=self.room)
        self.hidden_obj.db.hidden = True
    
    def test_object_size_visibility(self):
        """Test object size affects visibility."""
        with patch.object(self.room, 'get_time_of_day', return_value="noon"):
            with patch.object(self.room, 'get_current_weather', return_value=["clear"]):
                # Normal object in good conditions
                normal_vis = self.room.calculate_object_visibility(self.normal_obj, self.char)
                self.assertEqual(normal_vis, 1.0)
                
                # Small object harder to see
                small_vis = self.room.calculate_object_visibility(self.small_obj, self.char)
                self.assertLess(small_vis, 0.5)
    
    def test_hidden_objects_require_search(self):
        """Test hidden objects have 0 visibility."""
        visibility = self.room.calculate_object_visibility(self.hidden_obj, self.char)
        self.assertEqual(visibility, 0.0)
        
        # Should not appear in visible objects
        visible = self.room.get_visible_objects(self.char)
        self.assertNotIn(self.hidden_obj, visible)
    
    def test_luminous_objects_in_darkness(self):
        """Test shiny/glowing objects are easier to see in dark."""
        shiny_obj = create.create_object(Object, key="gem", location=self.room)
        shiny_obj.db.visibility_size = "tiny"
        shiny_obj.db.luminosity = "shiny"
        
        with patch.object(self.room, 'get_time_of_day', return_value="night"):
            # Calculate visibility
            vis = self.room.calculate_object_visibility(shiny_obj, self.char)
            
            # Should be more visible than a normal tiny object
            normal_tiny = create.create_object(Object, key="button", location=self.room)
            normal_tiny.db.visibility_size = "tiny"
            normal_vis = self.room.calculate_object_visibility(normal_tiny, self.char)
            
            self.assertGreater(vis, normal_vis)
    
    def test_weather_affects_all_objects(self):
        """Test weather reduces visibility of all objects."""
        with patch.object(self.room, 'get_current_weather', return_value=["fog"]):
            with patch.object(self.room, 'get_time_of_day', return_value="noon"):
                # Even normal objects hard to see in fog
                vis = self.room.calculate_object_visibility(self.normal_obj, self.char)
                self.assertLess(vis, 0.5)


class TestRoomResources(EvenniaTest):
    """Test resource gathering mechanics."""
    
    def setUp(self):
        super().setUp()
        self.forest = create.create_object(Room, key="Forest")
        self.forest.db.indoor = False
        self.gatherer = create.create_object(Character, key="Gatherer", location=self.forest)
    
    def test_resource_availability_by_season(self):
        """Test resources vary by season."""
        with patch.object(self.forest, 'get_season') as mock_season:
            # Winter has few plants
            mock_season.return_value = "winter"
            winter_plants = self.forest.get_resource_availability("plants")
            
            # Summer has many plants
            mock_season.return_value = "summer"
            summer_plants = self.forest.get_resource_availability("plants")
            
            self.assertLess(winter_plants, summer_plants)
            self.assertLess(winter_plants, 0.5)  # Less than 50% in winter
            self.assertGreater(summer_plants, 1.5)  # More than 150% in summer
    
    def test_weather_affects_gathering(self):
        """Test weather conditions affect resource gathering."""
        with patch.object(self.forest, 'get_current_weather') as mock_weather:
            with patch.object(self.forest, 'get_season', return_value="summer"):
                # Good weather
                mock_weather.return_value = ["clear"]
                clear_wood = self.forest.get_resource_availability("wood")
                
                # Storm reduces gathering
                mock_weather.return_value = ["storm"]
                storm_wood = self.forest.get_resource_availability("wood")
                
                self.assertGreater(clear_wood, storm_wood)
    
    def test_resource_extraction(self):
        """Test basic resource extraction."""
        # Give gatherer some foraging skill
        self.gatherer.skills.foraging.base = 20
        
        with patch.object(self.forest, 'get_season', return_value="summer"):
            # Try to gather wood
            success, amount, exp = self.forest.extract_resource(self.gatherer, "wood", 1)
            
            self.assertTrue(success)
            self.assertGreater(amount, 0)
            self.assertGreater(exp, 0)
            
            # Check resource was depleted
            wood_current = self.forest.db.resources["wood"]["current"]
            self.assertLess(wood_current, 5)  # Started at 5
    
    def test_tool_requirements(self):
        """Test some resources require tools."""
        # Try to gather stone without pickaxe
        success, amount, exp = self.forest.extract_resource(self.gatherer, "stone", 1)
        self.assertFalse(success)
        
        # Give gatherer a pickaxe
        pickaxe = create.create_object(Object, key="pickaxe", location=self.gatherer)
        
        # Now should work
        success, amount, exp = self.forest.extract_resource(self.gatherer, "stone", 1)
        self.assertTrue(success)
    
    def test_skill_affects_yield(self):
        """Test higher skill gives better yields."""
        with patch.object(self.forest, 'get_season', return_value="summer"):
            # Reset wood
            self.forest.db.resources["wood"]["current"] = 10
            
            # Low skill gatherer
            self.gatherer.skills.foraging.base = 10
            success1, amount1, exp1 = self.forest.extract_resource(self.gatherer, "wood", 5)
            
            # Reset wood
            self.forest.db.resources["wood"]["current"] = 10
            
            # High skill gatherer
            self.gatherer.skills.foraging.base = 80
            success2, amount2, exp2 = self.forest.extract_resource(self.gatherer, "wood", 5)
            
            # High skill should get more
            self.assertGreater(amount2, amount1)


class TestRoomAppearance(EvenniaTest):
    """Test room appearance and descriptions."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Dynamic Room")
        self.char = create.create_object(Character, key="Observer", location=self.room)
        
    def test_seasonal_descriptions(self):
        """Test room descriptions change with seasons."""
        # Set seasonal descriptions
        self.room.desc_spring = "Spring flowers bloom everywhere."
        self.room.desc_summer = "The summer heat beats down."
        self.room.desc_autumn = "Colorful leaves cover the ground."
        self.room.desc_winter = "Snow blankets everything in white."
        
        with patch.object(self.room, 'get_season') as mock_season:
            # Test each season
            for season, expected in [
                ("spring", "Spring flowers bloom everywhere."),
                ("summer", "The summer heat beats down."),
                ("autumn", "Colorful leaves cover the ground."),
                ("winter", "Snow blankets everything in white.")
            ]:
                mock_season.return_value = season
                desc = self.room.get_display_desc(self.char)
                self.assertEqual(desc, expected)
    
    def test_weather_state_descriptions(self):
        """Test weather states can override descriptions."""
        # Set base and weather descriptions
        self.room.db.desc = "A normal forest clearing."
        self.room.add_desc("The rain pours down heavily.", room_state="rain")
        self.room.add_desc("Thick fog obscures everything.", room_state="fog")
        
        # Normal weather
        desc = self.room.get_display_desc(self.char)
        self.assertEqual(desc, "A normal forest clearing.")
        
        # Add rain state
        self.room.add_room_state("rain")
        desc = self.room.get_display_desc(self.char)
        self.assertEqual(desc, "The rain pours down heavily.")
        
        # Fog overrides rain (alphabetically first)
        self.room.add_room_state("fog")
        desc = self.room.get_display_desc(self.char)
        self.assertEqual(desc, "Thick fog obscures everything.")
    
    def test_room_appearance_includes_conditions(self):
        """Test room appearance shows time, season, and weather."""
        with patch.object(self.room, 'get_time_of_day', return_value="morning"):
            with patch.object(self.room, 'get_season', return_value="spring"):
                with patch.object(self.room, 'get_current_weather', return_value=["rain"]):
                    appearance = self.room.return_appearance(self.char)
                    
                    # Should include room name
                    self.assertIn("Dynamic Room", appearance)
                    
                    # Should include conditions
                    self.assertIn("Time: Morning", appearance)
                    self.assertIn("Season: Spring", appearance)
                    self.assertIn("Weather: Rain", appearance)
    
    def test_visible_objects_in_appearance(self):
        """Test only visible objects appear in room description."""
        # Create various objects
        visible_obj = create.create_object(Object, key="table", location=self.room)
        hidden_obj = create.create_object(Object, key="secret", location=self.room)
        hidden_obj.db.hidden = True
        
        with patch.object(self.room, 'get_time_of_day', return_value="noon"):
            appearance = self.room.return_appearance(self.char)
            
            # Visible object should appear
            self.assertIn("table", appearance)
            
            # Hidden object should not
            self.assertNotIn("secret", appearance)


class TestExtendedRoomIntegration(EvenniaTest):
    """Test integration with game time and trait systems."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Integrated Room")
        self.char = create.create_object(Character, key="Test Char", location=self.room)
    
    def test_uses_custom_gametime(self):
        """Test room uses our custom gametime system."""
        from world.gametime_utils import get_current_season, get_time_of_day
        
        # Room methods should return same as utility functions
        self.assertEqual(self.room.get_season(), get_current_season())
        self.assertEqual(self.room.get_time_of_day(), get_time_of_day())
    
    def test_gathering_improves_skills(self):
        """Test gathering resources improves character skills."""
        initial_foraging = self.char.skills.foraging.value
        
        # Gather some wood
        success, amount, exp = self.room.extract_resource(self.char, "wood", 1)
        
        if success and exp > 0:
            # Manually apply the experience
            self.char.improve_skill("foraging", exp)
            
            # Skill should have improved
            self.assertGreater(
                self.char.skills.foraging.value,
                initial_foraging
            )
    
    def test_weather_affects_character_traits(self):
        """Test room weather can affect character survival traits."""
        # This is preparation for future ticker integration
        
        # Set harsh weather
        self.room.add_room_state("storm")
        
        # Check that room recognizes the harsh condition
        weather = self.room.get_current_weather()
        self.assertIn("storm", weather)
        
        # In future: storm without shelter increases fatigue decay
        # For now, just verify the room tracks weather properly


class TestWeatherSystem(EvenniaTest):
    """Test the weather state system."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Weather Test")
    
    def test_default_weather(self):
        """Test rooms start with clear weather."""
        weather = self.room.get_current_weather()
        self.assertEqual(weather, ["clear"])
    
    def test_multiple_weather_states(self):
        """Test rooms can have multiple weather states."""
        self.room.add_room_state("rain")
        self.room.add_room_state("wind")
        
        weather = self.room.get_current_weather()
        self.assertIn("rain", weather)
        self.assertIn("wind", weather)
    
    def test_weather_state_management(self):
        """Test adding and removing weather states."""
        # Add fog
        self.room.add_room_state("fog")
        self.assertIn("fog", self.room.room_states)
        
        # Remove fog
        self.room.remove_room_state("fog")
        self.assertNotIn("fog", self.room.room_states)
        
        # Clear all states
        self.room.add_room_state("rain")
        self.room.add_room_state("storm")
        self.room.clear_room_state()
        
        # Should go back to default clear
        weather = self.room.get_current_weather()
        self.assertEqual(weather, ["clear"])


class TestLightSources(EvenniaTest):
    """Test light source functionality."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Dark Room")
        self.char = create.create_object(Character, key="Light Bearer", location=self.room)
        self.torch = create.create_object(Torch, key="torch", location=self.char)
    
    def test_torch_lighting(self):
        """Test torch can be lit and extinguished."""
        # Start unlit
        self.assertFalse(self.torch.db.light_active)
        self.assertEqual(self.torch.db.luminosity, "normal")
        
        # Light it
        self.torch.do_light(self.char)
        self.assertTrue(self.torch.db.light_active)
        self.assertEqual(self.torch.db.luminosity, "glowing")
        
        # Extinguish it
        self.torch.do_extinguish(self.char)
        self.assertFalse(self.torch.db.light_active)
        self.assertEqual(self.torch.db.luminosity, "normal")
    
    def test_light_improves_object_visibility(self):
        """Test carrying light makes objects more visible."""
        small_obj = create.create_object(SmallValuable, key="ring", location=self.room)
        
        with patch.object(self.room, 'get_time_of_day', return_value="night"):
            # Without light
            self.torch.db.light_active = False
            vis_dark = self.room.calculate_object_visibility(small_obj, self.char)
            
            # With light
            self.torch.db.light_active = True
            vis_light = self.room.calculate_object_visibility(small_obj, self.char)
            
            # Should be much more visible with light
            self.assertGreater(vis_light, vis_dark * 1.5)


class TestDetailSystem(EvenniaTest):
    """Test room detail functionality."""
    
    def setUp(self):
        super().setUp()
        self.room = create.create_object(Room, key="Detailed Room")
        self.char = create.create_object(Character, key="Inspector", location=self.room)
    
    def test_add_and_get_details(self):
        """Test adding and retrieving room details."""
        # Add a detail
        self.room.add_detail("window", "A grimy window overlooks the street.")
        
        # Get exact match
        detail = self.room.get_detail("window", self.char)
        self.assertEqual(detail, "A grimy window overlooks the street.")
        
        # Get partial match
        detail = self.room.get_detail("win", self.char)
        self.assertEqual(detail, "A grimy window overlooks the street.")
    
    def test_detail_with_funcparser(self):
        """Test details can use state-based descriptions."""
        # Add detail with state
        detail_text = (
            "A heavy wooden door. "
            "$state(locked, It appears to be locked.) "
            "$state(open, It stands wide open.)"
        )
        self.room.add_detail("door", detail_text)
    
        # Without state
        detail = self.room.get_detail("door", self.char)
        # Strip trailing space that funcparser leaves behind
        # This is a cosmetic issue in ExtendedRoom that doesn't affect gameplay
        self.assertEqual(detail.strip(), "A heavy wooden door.")
    
        # With locked state
        self.room.add_room_state("locked")
        detail = self.room.get_detail("door", self.char)
        # Also strip here for consistency
        self.assertEqual(detail.strip(), "A heavy wooden door. It appears to be locked.")
</file>

<file path="world/batch_cmds.ev">
#
# A batch-command file is a way to build a game world
# in a programmatic way, by placing a sequence of
# build commands after one another. This allows for
# using a real text editor to edit e.g. descriptions
# rather than entering text on the command line.
#
# A batch-command file is loaded with @batchprocess in-game:
#
#   @batchprocess[/interactive] tutorial_examples.batch_cmds
#
# A # as the first symbol on a line begins a comment and
# marks the end of a previous command definition. This is important,
# - every command must be separated by at least one line of comment.
#
# All supplied commands are given as normal, on their own line
# and accept arguments in any format up until the first next
# comment line begins. Extra whitespace is removed; an empty
# line in a command definition translates into a newline.
#
# See `evennia/contrib/tutorial_examples/batch_cmds.ev` for
# an example of a batch-command code. See also the batch-code
# system for loading python-code this way.
#
</file>

<file path="world/gametime_utils.py">
# world/gametime_utils.py
"""
Gametime utility functions for the Fantasy Steampunk MUD.

This module provides helper functions for working with the custom
gametime system, including season detection, time formatting, and
integration with game systems.
"""

from evennia.contrib.base_systems import custom_gametime
from django.conf import settings


def get_current_season():
    """
    Get the current season based on game time.
    
    Returns:
        str: The current season name ('winter', 'spring', 'summer', 'autumn')
    """
    year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
    
    for season, months in settings.SEASONS.items():
        if month in months:
            return season
    return "unknown"


def get_time_of_day():
    """
    Get the current time of day as a descriptive string.
    
    Returns:
        str: Time of day ('dawn', 'morning', 'noon', etc.)
    """
    year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
    
    for time_name, (start, end) in settings.TIME_OF_DAY.items():
        if time_name == "night":
            if hour >= start or hour < end:
                return time_name
        else:
            if start <= hour < end:
                return time_name
    return "unknown"


def format_game_date():
    """
    Format the current game date in a readable format.
    
    Returns:
        str: Formatted date string (e.g., "15th of Bloomheart, Year 850")
    """
    year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
    
    # Get month name
    month_name = settings.MONTH_NAMES[month] if month < len(settings.MONTH_NAMES) else f"Month {month + 1}"
    
    # Format day with suffix
    day_num = day + 1  # Days are 0-indexed internally
    if 10 <= day_num % 100 <= 20:
        suffix = 'th'
    else:
        suffix = {1: 'st', 2: 'nd', 3: 'rd'}.get(day_num % 10, 'th')
    
    return f"{day_num}{suffix} of {month_name}, Year {year}"


def get_hours_until_next_trait_update():
    """
    Calculate how many game hours until the next trait update.
    
    Returns:
        float: Number of game hours until next update
    """
    # With our setup, traits update every game hour
    # Get current time and calculate minutes/seconds until next hour
    year, month, week, day, hour, minute, second = custom_gametime.custom_gametime()
    
    # Calculate seconds until next hour
    seconds_until_hour = (60 - minute) * 60 - second
    
    # Convert to game hours
    return seconds_until_hour / 3600.0


def is_night_time():
    """
    Check if it's currently night time in the game.
    
    Returns:
        bool: True if it's night time, False otherwise
    """
    time_of_day = get_time_of_day()
    return time_of_day in ["night", "dusk", "dawn"]


def is_winter():
    """
    Check if it's currently winter in the game.
    
    Returns:
        bool: True if it's winter, False otherwise
    """
    return get_current_season() == "winter"


def get_seasonal_modifier(season=None):
    """
    Get modifiers that should be applied based on the current season.
    
    Args:
        season (str, optional): Season to check. If None, uses current season.
        
    Returns:
        dict: Dictionary of modifiers for various game systems
    """
    if season is None:
        season = get_current_season()
    
    modifiers = {
        "winter": {
            "resource_availability": 0.5,  # Half resources available
            "fatigue_rate": 1.5,          # Tire 50% faster
            "food_decay": 0.5,            # Food lasts longer
            "visibility": 0.8,            # Reduced visibility
        },
        "spring": {
            "resource_availability": 1.2,  # More resources
            "fatigue_rate": 0.9,          # Slightly less tiring
            "food_decay": 1.0,            # Normal decay
            "visibility": 1.0,            # Normal visibility
        },
        "summer": {
            "resource_availability": 1.5,  # Abundant resources
            "fatigue_rate": 1.2,          # Tire faster in heat
            "food_decay": 1.5,            # Food spoils faster
            "visibility": 1.2,            # Excellent visibility
        },
        "autumn": {
            "resource_availability": 1.3,  # Good harvest time
            "fatigue_rate": 1.0,          # Normal fatigue
            "food_decay": 0.8,            # Cooler weather helps
            "visibility": 0.9,            # Slightly reduced
        }
    }
    
    return modifiers.get(season, {
        "resource_availability": 1.0,
        "fatigue_rate": 1.0,
        "food_decay": 1.0,
        "visibility": 1.0
    })
</file>

<file path="world/help_entries.py">
"""
File-based help entries. These complements command-based help and help entries
added in the database using the `sethelp` command in-game.

Control where Evennia reads these entries with `settings.FILE_HELP_ENTRY_MODULES`,
which is a list of python-paths to modules to read.

A module like this should hold a global `HELP_ENTRY_DICTS` list, containing
dicts that each represent a help entry. If no `HELP_ENTRY_DICTS` variable is
given, all top-level variables that are dicts in the module are read as help
entries.

Each dict is on the form
::

    {'key': <str>,
     'text': <str>}``     # the actual help text. Can contain # subtopic sections
     'category': <str>,   # optional, otherwise settings.DEFAULT_HELP_CATEGORY
     'aliases': <list>,   # optional
     'locks': <str>       # optional, 'view' controls seeing in help index, 'read'
                          #           if the entry can be read. If 'view' is unset,
                          #           'read' is used for the index. If unset, everyone
                          #           can read/view the entry.

"""

HELP_ENTRY_DICTS = [
    {
        "key": "evennia",
        "aliases": ["ev"],
        "category": "General",
        "locks": "read:perm(Developer)",
        "text": """
            Evennia is a MU-game server and framework written in Python. You can read more
            on https://www.evennia.com.

            # subtopics

            ## Installation

            You'll find installation instructions on https://www.evennia.com.

            ## Community

            There are many ways to get help and communicate with other devs!

            ### Discussions

            The Discussions forum is found at https://github.com/evennia/evennia/discussions.

            ### Discord

            There is also a discord channel for chatting - connect using the
            following link: https://discord.gg/AJJpcRUhtF

        """,
    },
]
</file>

<file path="world/README.md">
# world/

This folder is meant as a miscellaneous folder for all that other stuff
related to the game. Code which are not commands or typeclasses go
here, like custom economy systems, combat code, batch-files etc. 

You can restructure and even rename this folder as best fits your
sense of organisation. Just remember that if you add new sub
directories, you must add (optionally empty) `__init__.py` files in
them for Python to be able to find the modules within.
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
*.py[cod]

# C extensions
*.so

# Packages
*.egg
*.egg-info
dist
build
eggs
parts
var
sdist
develop-eggs
.installed.cfg
lib
lib64
__pycache__

# Other
*.swp
*.log
*.log.*
*.pid
*.restart
*.db3

# Installation-specific.
# For group efforts, comment out some or all of these.
server/conf/secret_settings.py
server/logs/*.log.*
server/.static/*
server/.media/*

# Installer logs
pip-log.txt

# Unit test / coverage reports
.coverage
.tox
nosetests.xml

# Translations
*.mo

# Mr Developer
.mr.developer.cfg
.project
.pydevproject

# PyCharm config
.idea

# VSCode config
.vscode
</file>

<file path="README.md">
# Welcome to Evennia!

This is your game directory, set up to let you start with
your new game right away. An overview of this directory is found here:
https://github.com/evennia/evennia/wiki/Directory-Overview#the-game-directory

You can delete this readme file when you've read it and you can
re-arrange things in this game-directory to suit your own sense of
organisation (the only exception is the directory structure of the
`server/` directory, which Evennia expects). If you change the structure
you must however also edit/add to your settings file to tell Evennia
where to look for things.

Your game's main configuration file is found in
`server/conf/settings.py` (but you don't need to change it to get
started). If you just created this directory (which means you'll already
have a `virtualenv` running if you followed the default instructions),
`cd` to this directory then initialize a new database using

    evennia migrate

To start the server, stand in this directory and run

    evennia start

This will start the server, logging output to the console. Make
sure to create a superuser when asked. By default you can now connect
to your new game using a MUD client on `localhost`, port `4000`.  You can
also log into the web client by pointing a browser to
`http://localhost:4001`.

# Getting started

From here on you might want to look at one of the beginner tutorials:
http://github.com/evennia/evennia/wiki/Tutorials.

Evennia's documentation is here:
https://github.com/evennia/evennia/wiki.

Enjoy!
</file>

<file path="commands/resource_commands.py">
# commands/resource_commands.py
"""
Resource gathering commands for the survival game.

These commands allow players to gather resources from rooms,
integrating with the Extended Room's resource system and
the Cooldown system for rate limiting.
"""

from evennia import Command
from evennia.utils import create, list_to_string
import random


class CmdGather(Command):
    """
    Gather resources from the environment.
    
    Usage:
        gather <resource>
        gather <amount> <resource>
        
    Examples:
        gather wood
        gather 5 stone
        gather plants
        
    This command allows you to gather resources from the current
    location. Success depends on:
    - Resource availability (season, weather)
    - Required skills and tools
    - Your skill level (higher skill = more yield)
    
    Different resources may require different tools:
    - Wood: No tool required (hands)
    - Stone: Requires a pickaxe
    - Plants: No tool required
    - Water: Requires a container
    
    Your gathering skills will improve with practice.
    
    There is a cooldown period after gathering. Higher foraging
    skill reduces this cooldown, allowing experienced gatherers
    to work more efficiently.
    """
    
    key = "gather"
    aliases = ["collect", "harvest", "forage"]
    locks = "cmd:all()"
    help_category = "Survival"
    
    def parse(self):
        """Parse the arguments."""
        args = self.args.strip().split()
        
        if not args:
            self.resource_type = None
            self.amount = 1
            return
        
        # Check if first arg is a number
        try:
            self.amount = int(args[0])
            self.resource_type = " ".join(args[1:]) if len(args) > 1 else None
        except ValueError:
            self.amount = 1
            self.resource_type = " ".join(args)
    
    def func(self):
        """Execute the gather command."""
        caller = self.caller
        location = caller.location
        
        if not location:
            caller.msg("You have nowhere to gather from.")
            return
        
        if not self.resource_type:
            # List available resources
            self.list_resources()
            return
        
        # Check cooldown
        if not caller.cooldowns.ready("gather"):
            time_left = caller.cooldowns.time_left("gather", use_int=True)
            caller.msg(f"|yYou are still tired from gathering. "
                      f"Wait {time_left} more seconds.|n")
            return
        
        # Attempt to gather
        resources = location.db.resources or {}
        if self.resource_type not in resources:
            caller.msg(f"You can't gather {self.resource_type} here.")
            return
        
        # Use the room's extraction method
        success, gathered, skill_gain = location.extract_resource(
            caller, self.resource_type, self.amount
        )
        
        if not success:
            return  # Error message already sent by extract_resource
        
        # Create the gathered resources
        self.create_gathered_items(gathered)
        
        # Apply skill gain
        resource = resources[self.resource_type]
        skill_type = resource.get("skill_required", "foraging")
        if skill_type and skill_gain > 0:
            if caller.improve_skill(skill_type, skill_gain):
                caller.msg(f"|gYour {skill_type} skill improves!|n")
        
        # Apply cooldown with skill-based reduction
        base_cooldown = 300  # 5 minutes base
        
        # Harder resources have longer cooldowns
        if self.resource_type == "stone":
            base_cooldown = 420  # 7 minutes for stone
        elif self.resource_type == "water":
            base_cooldown = 180  # 3 minutes for water
            
        # More gathered = longer cooldown
        cooldown_multiplier = 1 + (gathered - 1) * 0.2  # +20% per extra item
        adjusted_cooldown = int(base_cooldown * cooldown_multiplier)
        
        # Apply the cooldown with skill reduction
        actual_cooldown = caller.apply_cooldown("gather", adjusted_cooldown, skill_type)
        
        # Inform about cooldown
        if actual_cooldown < adjusted_cooldown:
            caller.msg(f"|xYour {skill_type} expertise allows you to work more efficiently.|n")
    
    def list_resources(self):
        """List available resources in the room."""
        caller = self.caller
        location = caller.location
        
        resources = location.db.resources or {}
        if not resources:
            caller.msg("There are no gatherable resources here.")
            return
        
        caller.msg("|wAvailable resources:|n")
        
        for res_type, res_data in resources.items():
            current = res_data.get("current", 0)
            tool = res_data.get("tool_required", "none")
            skill = res_data.get("skill_required", "none")
            min_skill = res_data.get("min_skill", 0)
            
            # Get availability with seasonal modifiers
            availability = location.get_resource_availability(res_type)
            
            # Determine amount description
            if current < 0:
                amount_desc = "unlimited"
            elif current == 0:
                amount_desc = "|rdepleted|n"
            else:
                effective = int(current * availability)
                if effective == 0:
                    amount_desc = "|runavailable (seasonal)|n"
                elif effective < 3:
                    amount_desc = "|yscarce|n"
                elif effective < 6:
                    amount_desc = "|gmoderate|n"
                else:
                    amount_desc = "|Gplentiful|n"
            
            # Build info string
            info_parts = [f"|c{res_type}|n: {amount_desc}"]
            if tool != "none" and tool:
                info_parts.append(f"tool: {tool}")
            if skill != "none" and skill:
                if min_skill > 0:
                    info_parts.append(f"requires: {skill} {min_skill}+")
                else:
                    info_parts.append(f"skill: {skill}")
            
            caller.msg(f"  {' - '.join(info_parts)}")
    
    def create_gathered_items(self, amount):
        """
        Create the actual gathered items.
        
        Args:
            amount (int): Number of items to create
        """
        caller = self.caller
        location = caller.location
        
        # Define prototypes for different resources
        resource_prototypes = {
            "wood": {
                "key": "piece of wood",
                "aliases": ["wood"],
                "desc": "A sturdy piece of wood suitable for crafting.",
                "tags": [("material", "crafting"), ("wood", "material_type")],
                "weight": 2.0,
                "value": 1
            },
            "stone": {
                "key": "rough stone",
                "aliases": ["stone"],
                "desc": "A chunk of rough stone that could be worked.",
                "tags": [("material", "crafting"), ("stone", "material_type")],
                "weight": 5.0,
                "value": 1
            },
            "plants": {
                "key": "edible plants",
                "aliases": ["plants", "herbs"],
                "desc": "A handful of edible plants and herbs.",
                "tags": [("food", "crafting"), ("plants", "material_type")],
                "weight": 0.5,
                "value": 2,
                "nutrition": 10
            },
            "water": {
                "key": "water",
                "aliases": ["water"],
                "desc": "Fresh water in your container.",
                "tags": [("drink", "crafting"), ("water", "material_type")],
                "weight": 1.0,
                "value": 1,
                "thirst_value": 20
            }
        }
        
        prototype = resource_prototypes.get(self.resource_type)
        if not prototype:
            # Generic resource
            prototype = {
                "key": self.resource_type,
                "desc": f"Some gathered {self.resource_type}.",
                "tags": [("material", "crafting")],
                "weight": 1.0
            }
        
        # Create the items
        created_items = []
        for i in range(amount):
            obj = create.create_object(
                "typeclasses.objects.Object",
                key=prototype["key"],
                location=caller
            )
            
            # Set properties
            obj.aliases.add(prototype.get("aliases", []))
            obj.db.desc = prototype["desc"]
            for tag_tuple in prototype.get("tags", []):
                obj.tags.add(*tag_tuple)
            
            # Set optional properties
            for attr in ["weight", "value", "nutrition", "thirst_value"]:
                if attr in prototype:
                    obj.db.set(attr, prototype[attr])
            
            created_items.append(obj)
        
        # Message about gathering
        if amount == 1:
            caller.msg(f"|gYou gather {created_items[0].get_display_name(caller)}.|n")
        else:
            caller.msg(f"|gYou gather {amount} {prototype['key']}s.|n")
        
        location.msg_contents(
            f"{caller.name} gathers some {self.resource_type}.",
            exclude=caller
        )


class CmdForage(Command):
    """
    Quick command to search for and gather edible plants.
    
    Usage:
        forage
        
    This is a shortcut that combines searching for plants
    and gathering them if found. It's useful for quick
    sustenance gathering.
    
    Foraging has a shorter cooldown than general gathering
    but only works for food items.
    """
    
    key = "forage"
    locks = "cmd:all()"
    help_category = "Survival"
    
    def func(self):
        """Execute forage command."""
        caller = self.caller
        location = caller.location
        
        if not location:
            caller.msg("You have nowhere to forage.")
            return
        
        # Check if plants are available
        resources = location.db.resources or {}
        if "plants" not in resources:
            caller.msg("There's nothing to forage here.")
            return
        
        # Check cooldown (foraging has its own shorter cooldown)
        if not caller.cooldowns.ready("forage"):
            time_left = caller.cooldowns.time_left("forage", use_int=True)
            caller.msg(f"|yYou are still tired from foraging. "
                      f"Wait {time_left} more seconds.|n")
            return
        
        # Quick search animation
        caller.msg("You search the area for edible plants...")
        location.msg_contents(
            f"{caller.name} forages for food.",
            exclude=caller
        )
        
        # Use the gather functionality
        success, gathered, skill_gain = location.extract_resource(
            caller, "plants", 3  # Try to gather up to 3
        )
        
        if success and gathered > 0:
            # Create simple food items
            for i in range(gathered):
                food = create.create_object(
                    "typeclasses.objects.Object",
                    key="handful of berries",
                    location=caller
                )
                food.aliases.add(["berries", "food"])
                food.db.desc = "A handful of foraged berries and edible plants."
                food.tags.add("food", category="item_type")
                food.db.nutrition = 15
                food.db.weight = 0.3
            
            if gathered == 1:
                caller.msg("|gYou find a handful of berries.|n")
            else:
                caller.msg(f"|gYou find {gathered} handfuls of berries.|n")
            
            # Skill improvement
            if skill_gain > 0 and caller.improve_skill("foraging", skill_gain):
                caller.msg("|gYour foraging skill improves!|n")
            
            # Apply shorter cooldown for foraging
            base_cooldown = 180  # 3 minutes base
            actual_cooldown = caller.apply_cooldown("forage", base_cooldown, "foraging")
            
            if actual_cooldown < base_cooldown:
                caller.msg("|xYour foraging expertise serves you well.|n")
        else:
            caller.msg("You don't find anything edible.")
            # Still apply a short cooldown on failure
            caller.cooldowns.add("forage", 60)  # 1 minute on failure
</file>

<file path="world/prototypes.py">
"""
Prototypes

A prototype is a simple way to create individualized instances of a
given typeclass. It is dictionary with specific key names.

For example, you might have a Sword typeclass that implements everything a
Sword would need to do. The only difference between different individual Swords
would be their key, description and some Attributes. The Prototype system
allows to create a range of such Swords with only minor variations. Prototypes
can also inherit and combine together to form entire hierarchies (such as
giving all Sabres and all Broadswords some common properties). Note that bigger
variations, such as custom commands or functionality belong in a hierarchy of
typeclasses instead.

A prototype can either be a dictionary placed into a global variable in a
python module (a 'module-prototype') or stored in the database as a dict on a
special Script (a db-prototype). The former can be created just by adding dicts
to modules Evennia looks at for prototypes, the latter is easiest created
in-game via the `olc` command/menu.

Prototypes are read and used to create new objects with the `spawn` command
or directly via `evennia.spawn` or the full path `evennia.prototypes.spawner.spawn`.

A prototype dictionary have the following keywords:

Possible keywords are:
- `prototype_key` - the name of the prototype. This is required for db-prototypes,
  for module-prototypes, the global variable name of the dict is used instead
- `prototype_parent` - string pointing to parent prototype if any. Prototype inherits
  in a similar way as classes, with children overriding values in their parents.
- `key` - string, the main object identifier.
- `typeclass` - string, if not set, will use `settings.BASE_OBJECT_TYPECLASS`.
- `location` - this should be a valid object or #dbref.
- `home` - valid object or #dbref.
- `destination` - only valid for exits (object or #dbref).
- `permissions` - string or list of permission strings.
- `locks` - a lock-string to use for the spawned object.
- `aliases` - string or list of strings.
- `attrs` - Attributes, expressed as a list of tuples on the form `(attrname, value)`,
  `(attrname, value, category)`, or `(attrname, value, category, locks)`. If using one
   of the shorter forms, defaults are used for the rest.
- `tags` - Tags, as a list of tuples `(tag,)`, `(tag, category)` or `(tag, category, data)`.
-  Any other keywords are interpreted as Attributes with no category or lock.
   These will internally be added to `attrs` (equivalent to `(attrname, value)`.

See the `spawn` command and `evennia.prototypes.spawner.spawn` for more info.

"""

## example of module-based prototypes using
## the variable name as `prototype_key` and
## simple Attributes

# from random import randint
#
# GOBLIN = {
# "key": "goblin grunt",
# "health": lambda: randint(20,30),
# "resists": ["cold", "poison"],
# "attacks": ["fists"],
# "weaknesses": ["fire", "light"],
# "tags": = [("greenskin", "monster"), ("humanoid", "monster")]
# }
#
# GOBLIN_WIZARD = {
# "prototype_parent": "GOBLIN",
# "key": "goblin wizard",
# "spells": ["fire ball", "lighting bolt"]
# }
#
# GOBLIN_ARCHER = {
# "prototype_parent": "GOBLIN",
# "key": "goblin archer",
# "attacks": ["short bow"]
# }
#
# This is an example of a prototype without a prototype
# (nor key) of its own, so it should normally only be
# used as a mix-in, as in the example of the goblin
# archwizard below.
# ARCHWIZARD_MIXIN = {
# "attacks": ["archwizard staff"],
# "spells": ["greater fire ball", "greater lighting"]
# }
#
# GOBLIN_ARCHWIZARD = {
# "key": "goblin archwizard",
# "prototype_parent" : ("GOBLIN_WIZARD", "ARCHWIZARD_MIXIN")
# }


# world/prototypes.py (lägg till dessa prototypes)

# Crafting Materials
IRON_ORE = {
    "key": "iron ore",
    "typeclass": "typeclasses.objects.Object",
    "desc": "A chunk of raw iron ore, ready for smelting.",
    "tags": [("iron_ore", "crafting_material"), ("material", "item_type")],
    "attrs": [
        ("weight", 2.0),
        ("value", 5)
    ]
}

LEATHER = {
    "key": "piece of leather",
    "typeclass": "typeclasses.objects.Object", 
    "desc": "A piece of tanned leather, supple and ready for crafting.",
    "tags": [("leather", "crafting_material"), ("material", "item_type")],
    "attrs": [
        ("weight", 0.5),
        ("value", 10),
        ("quality", 50)
    ]
}

FLOUR = {
    "key": "bag of flour",
    "typeclass": "typeclasses.objects.Object",
    "desc": "A small bag of wheat flour for baking.",
    "tags": [("flour", "crafting_material"), ("material", "item_type")],
    "attrs": [
        ("weight", 1.0),
        ("value", 3),
        ("perishable", True)
    ]
}

# Crafting Tools
OVEN = {
    "key": "brick oven",
    "typeclass": "typeclasses.objects.CraftingStation",
    "desc": "A large brick oven perfect for baking bread and other foods.",
    "tags": [("oven", "crafting_tool"), ("cooking_station", "item_type")],
    "attrs": [
        ("station_type", "cooking"),
        ("crafting_bonus", 15),
        ("portable", False),
        ("weight", 500)
    ]
}

FORGE = {
    "key": "smithing forge",
    "typeclass": "typeclasses.objects.Forge",
    "desc": "A stone forge with bellows for metalworking.",
    "tags": [("forge", "crafting_tool"), ("metalworking_station", "item_type")],
    "attrs": [
        ("station_type", "metalworking"),
        ("max_temperature", 1500),
        ("crafting_bonus", 20),
        ("portable", False),
        ("weight", 300)
    ]
}

PRECISION_TOOLS = {
    "key": "precision tool kit",
    "typeclass": "typeclasses.objects.ToolKit",
    "desc": "A leather case containing fine precision instruments.",
    "tags": [("precision_tools", "crafting_tool"), ("toolkit", "item_type")],
    "attrs": [
        ("tool_type", "precision"),
        ("engineering_bonus", 15),
        ("quality", 75),
        ("weight", 2)
    ]
}
</file>

<file path="typeclasses/objects.py">
# typeclasses/objects.py
"""
Object

The Object is the class for general items in the game world.

This implementation adds visibility properties to all objects,
making them interact with the Extended Room's visibility system.
"""

from evennia.objects.objects import DefaultObject
from evennia.utils import list_to_string
from evennia.utils import gametime
import random


class ObjectParent:
    """
    This is a mixin that can be used to override *all* entities inheriting at
    some distance from DefaultObject (Objects, Exits, Characters and Rooms).

    Just add any method that exists on `DefaultObject` to this class. If one
    of the derived classes has itself defined that same hook already, that will
    take precedence.
    """
    
    def at_object_creation(self):
        """
        Called once when object is first created.
        Sets default visibility properties.
        """
        super().at_object_creation()
        
        # Set default visibility properties
        self.db.visibility_size = "normal"  # tiny, small, normal, large, huge, obvious
        self.db.luminosity = "normal"       # dull, normal, shiny, glowing
        self.db.contrast = "normal"         # dark, normal, bright, camouflaged
        self.db.hidden = False              # Requires active search to find
        self.db.is_light_source = False     # Can provide light
        self.db.light_active = False        # Is currently providing light


class Object(ObjectParent, DefaultObject):
    """
    This is the root Object typeclass, representing all entities that
    have an actual presence in-game.
    
    Objects in this game have visibility properties that affect how
    easily they can be seen in different conditions.
    """
    
    def get_display_name(self, looker=None, **kwargs):
        """
        Get the display name, possibly modified by visibility.
        
        Hard-to-see objects might have their names obscured.
        """
        name = super().get_display_name(looker, **kwargs)
        
        if looker and self.location:
            # Endast beräkna visibility om objektet är i ett rum
            # (inte i någons inventory)
            if hasattr(self.location, 'calculate_object_visibility'):
                visibility = self.location.calculate_object_visibility(self, looker)
            
                # Very hard to see objects might be described vaguely
                if visibility < 0.3:
                    # Describe by size category instead of name
                    size_descriptions = {
                        "tiny": "something tiny",
                        "small": "a small object", 
                        "normal": "an object",
                        "large": "a large shape",
                        "huge": "a huge form"
                    }
                    vague_name = size_descriptions.get(self.db.visibility_size, "something")
                
                    # Add hints based on luminosity
                    if self.db.luminosity == "shiny":
                        vague_name = f"{vague_name} (glinting)"
                    elif self.db.luminosity == "glowing":
                        vague_name = f"{vague_name} (glowing)"
                
                    return f"|x{vague_name}|n"
            
                # Moderately visible objects show normal name but dim
                elif visibility < 0.6:
                    return f"|x{name}|n"
        
        return name
    
    def set_visibility_properties(self, size=None, luminosity=None, 
                                 contrast=None, hidden=None):
        """
        Convenience method to set multiple visibility properties at once.
        
        Args:
            size (str): Object size category
            luminosity (str): How much light it reflects/emits
            contrast (str): How it stands out from environment
            hidden (bool): Whether it requires searching to find
        """
        if size is not None:
            self.db.visibility_size = size
        if luminosity is not None:
            self.db.luminosity = luminosity
        if contrast is not None:
            self.db.contrast = contrast
        if hidden is not None:
            self.db.hidden = hidden
    
    def make_light_source(self, active=False):
        """
        Turn this object into a light source.
        
        Args:
            active (bool): Whether the light is initially on
        """
        self.db.is_light_source = True
        self.db.light_active = active
        self.db.luminosity = "glowing" if active else "normal"
    
    def toggle_light(self):
        """
        Toggle a light source on/off.
        
        Returns:
            bool: New state of the light
        """
        if not self.db.is_light_source:
            return False
        
        self.db.light_active = not self.db.light_active
        self.db.luminosity = "glowing" if self.db.light_active else "normal"
        
        return self.db.light_active
    
    def return_appearance(self, looker, **kwargs):
        """
        Base appearance method for all objects.
        """
        # Get the basic appearance
        text = super().return_appearance(looker, **kwargs)
        
        # Add visibility information if appropriate
        if self.db.is_light_source:
            if self.db.light_active:
                text += "\n\n|yIt is providing light.|n"
            else:
                text += "\n\nIt could provide light if lit."
                
        return text


# Example object classes with preset visibility

class SmallValuable(Object):
    """
    Base class for small valuable items like coins, gems, rings.
    These are harder to spot, especially in poor conditions.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        self.db.visibility_size = "tiny"
        self.db.luminosity = "shiny"
        self.db.contrast = "normal"


class Torch(Object):
    """
    A basic torch that can be lit to provide light.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        self.db.desc = "A torch made of cloth wrapped around a wooden stick."
        self.db.visibility_size = "normal"
        self.make_light_source(active=False)
        self.db.burn_time = 3600  # 1 hour real time = 4 hours game time
        
    def do_light(self, lighter):
        """
        Light the torch.
        
        Args:
            lighter (Character): Who is lighting it
            
        Returns:
            bool: Success
        """
        if self.db.light_active:
            lighter.msg("The torch is already lit.")
            return False
        
        self.db.light_active = True
        self.db.luminosity = "glowing"
        self.db.desc = "A burning torch casting flickering shadows."
        
        lighter.msg("You light the torch.")
        lighter.location.msg_contents(
            f"{lighter.name} lights a torch.",
            exclude=lighter
        )
        
        # TODO: Add TickerHandler to consume burn_time
        return True
    
    def do_extinguish(self, extinguisher):
        """
        Put out the torch.
        
        Args:
            extinguisher (Character): Who is putting it out
            
        Returns:
            bool: Success
        """
        if not self.db.light_active:
            extinguisher.msg("The torch is not lit.")
            return False
        
        self.db.light_active = False
        self.db.luminosity = "normal"
        self.db.desc = "A torch made of cloth wrapped around a wooden stick."
        
        extinguisher.msg("You extinguish the torch.")
        extinguisher.location.msg_contents(
            f"{extinguisher.name} extinguishes a torch.",
            exclude=extinguisher
        )
        
        return True


class HiddenCache(Object):
    """
    A hidden container that requires searching to find.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        self.db.desc = "A carefully concealed cache."
        self.db.visibility_size = "small"
        self.db.contrast = "camouflaged"
        self.db.camouflage_type = "natural"
        self.db.hidden = True  # Requires search command


# typeclasses/objects.py (uppdaterad clothing section)
"""
Clothing objects for the survival game.

These clothing items provide various benefits including
weather protection, warmth, and stat bonuses. They also
inherit all standard object properties like visibility.
"""

from evennia.contrib.game_systems.clothing.clothing import ContribClothing


class SurvivalClothing(Object, ContribClothing):
    """
    Base class for survival clothing with environmental protection.
    
    This inherits from both Object (for visibility and other game properties)
    and ContribClothing (for the wearing/removing functionality).
    
    Attributes to set on clothing:
        warmth_value (int): How much warmth this provides (0-30)
        weather_protection (list): Types of weather protected against
        stat_modifiers (dict): Stat bonuses when worn
        protection_value (int): General damage protection
        durability (int): How long before it wears out
        repair_materials (list): What's needed to repair
    """
    
    def at_object_creation(self):
        """Set default values for survival clothing."""
        # Call both parent initializers
        Object.at_object_creation(self)
        ContribClothing.at_object_creation(self)
        
        # Survival-specific attributes
        self.db.warmth_value = 0
        self.db.weather_protection = []
        self.db.stat_modifiers = {}
        self.db.protection_value = 0
        self.db.durability = 100
        self.db.max_durability = 100
        self.db.repair_materials = ["cloth"]
        
        # Most clothing has normal visibility when dropped
        self.db.visibility_size = "normal"
        self.db.luminosity = "normal"
        self.db.contrast = "normal"
    
    def wear(self, wearer, wearstyle, quiet=False):
        """
        Override to apply stat modifiers when worn.
        """
        super().wear(wearer, wearstyle, quiet)
        
        # Apply stat modifiers
        if hasattr(wearer, 'apply_clothing_modifiers'):
            wearer.apply_clothing_modifiers()
            
        # Check for set bonuses
        self.check_set_bonuses(wearer)
    
    def remove(self, wearer, quiet=False):
        """
        Override to remove stat modifiers when removed.
        """
        super().remove(wearer, quiet)
        
        # Reapply modifiers (some are now gone)
        if hasattr(wearer, 'apply_clothing_modifiers'):
            wearer.apply_clothing_modifiers()
    
    def at_drop(self, dropper):
        """
        Called when the clothing is dropped.
        Ensures it's removed if worn.
        """
        if self.db.worn:
            self.remove(dropper, quiet=True)
        
        # Call parent drop behavior
        super().at_drop(dropper)
    
    def check_set_bonuses(self, wearer):
        """
        Check if wearing a complete set provides bonuses.
        
        Args:
            wearer: The character wearing this item
        """
        # This can be overridden in specific clothing types
        pass
    
    def get_condition_string(self):
        """
        Get a description of the item's condition.
        
        Returns:
            str: Description of condition
        """
        if not hasattr(self.db, 'durability'):
            return ""
            
        percent = (self.db.durability / self.db.max_durability) * 100
        
        if percent >= 90:
            return "|gpristine condition|n"
        elif percent >= 70:
            return "|ygood condition|n"
        elif percent >= 50:
            return "|yworn but serviceable|n"
        elif percent >= 30:
            return "|rwell-worn and fraying|n"
        elif percent >= 10:
            return "|rbadly damaged|n"
        else:
            return "|rfalling apart|n"
    
    def return_appearance(self, looker, **kwargs):
        """
        Add condition and benefits to clothing appearance.
        """
        # Get base appearance from Object parent
        text = Object.return_appearance(self, looker, **kwargs)
        
        # Add condition if visible
        condition = self.get_condition_string()
        if condition:
            text += f"\n\nIt is in {condition}."
            
        # Add protection info
        benefits = []
        if self.db.warmth_value and self.db.warmth_value > 0:
            benefits.append(f"provides warmth ({self.db.warmth_value})")
        
        if self.db.weather_protection:
            benefits.append(f"protects against: {', '.join(self.db.weather_protection)}")
        
        if self.db.stat_modifiers:
            mod_strings = []
            for stat, mod in self.db.stat_modifiers.items():
                sign = "+" if mod > 0 else ""
                mod_strings.append(f"{stat} {sign}{mod}")
            benefits.append(f"when worn: {', '.join(mod_strings)}")
        
        if benefits:
            text += f"\n\nThis clothing {'; '.join(benefits)}."
            
        return text


# Specific clothing types

class WinterCloak(SurvivalClothing):
    """
    A heavy winter cloak providing excellent cold protection.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "heavy winter cloak"
        self.aliases.add = ["cloak", "winter cloak"]
        self.db.desc = "A thick, fur-lined cloak designed for harsh winter conditions."
        
        # Clothing properties
        self.db.clothing_type = "cloak"
        self.db.warmth_value = 25
        self.db.weather_protection = ["snow", "wind", "rain"]
        self.db.stat_modifiers = {"constitution": 1}  # +1 CON from warmth
        self.db.protection_value = 2
        
        # Visible when dropped due to size
        self.db.visibility_size = "large"
        
        # Crafting prep
        self.db.repair_materials = ["fur", "leather", "cloth"]


class LeatherBoots(SurvivalClothing):
    """
    Sturdy leather boots for traveling.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "sturdy leather boots"
        self.aliases.add = ["boots", "leather boots"]
        self.db.desc = "Well-crafted leather boots with thick soles."
        
        self.db.clothing_type = "shoes"
        self.db.warmth_value = 5
        self.db.weather_protection = ["rain"]
        self.db.stat_modifiers = {"dexterity": 1}  # +1 DEX from good footing
        self.db.protection_value = 1
        
        self.db.repair_materials = ["leather"]


class WorkGloves(SurvivalClothing):
    """
    Protective gloves for crafting and gathering.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "work gloves"
        self.aliases.add = ["gloves"]
        self.db.desc = "Thick leather gloves reinforced for heavy work."
        
        self.db.clothing_type = "gloves"
        self.db.warmth_value = 3
        self.db.stat_modifiers = {"strength": 1}  # +1 STR for grip
        self.db.protection_value = 1
        
        # Special crafting bonus
        self.db.crafting_bonus = 5  # +5% success rate
        self.db.repair_materials = ["leather", "cloth"]


class RainCoat(SurvivalClothing):
    """
    Waterproof coat for wet weather.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "waterproof raincoat"
        self.aliases.add = ["raincoat", "coat"]
        self.db.desc = "A long coat treated with oils to repel water."
        
        self.db.clothing_type = "outerwear"
        self.db.warmth_value = 10
        self.db.weather_protection = ["rain", "wind"]
        self.db.protection_value = 1
        
        # Slightly shiny from waterproofing
        self.db.luminosity = "shiny"
        
        self.db.repair_materials = ["cloth", "oil"]


class WoolenHat(SurvivalClothing):
    """
    Simple warm hat.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "woolen hat"
        self.aliases.add = ["hat"]
        self.db.desc = "A simple but warm woolen hat."
        
        self.db.clothing_type = "hat"
        self.db.warmth_value = 8
        self.db.weather_protection = ["wind"]
        
        # Small and easy to miss if dropped
        self.db.visibility_size = "small"
        
        self.db.repair_materials = ["cloth"]


class EngineeringGoggles(SurvivalClothing):
    """
    Specialized goggles for engineering work.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "engineering goggles"
        self.aliases.add = ["goggles"]
        self.db.desc = "Brass-framed goggles with adjustable lenses."
        
        self.db.clothing_type = "goggles"
        self.db.stat_modifiers = {"intelligence": 2}  # +2 INT for precision
        self.db.protection_value = 1
        
        # Shiny brass catches light
        self.db.luminosity = "shiny"
        self.db.visibility_size = "small"
        
        # Special engineering bonus
        self.db.engineering_bonus = 10  # +10% success rate
        self.db.repair_materials = ["brass", "glass", "leather"]


class DecorativeScarf(SurvivalClothing):
    """
    A beautiful scarf that can be worn in various styles.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "decorative silk scarf"
        self.aliases.add = ["scarf", "silk scarf"]
        self.db.desc = "A beautifully patterned silk scarf with vibrant colors."
        
        self.db.clothing_type = "accessory"
        self.db.warmth_value = 2
        self.db.stat_modifiers = {"charisma": 1}  # +1 CHA for style
        
        # Bright and noticeable
        self.db.contrast = "bright"
        self.db.luminosity = "shiny"
        
        self.db.repair_materials = ["silk", "thread"]


# Special hidden/camouflaged clothing

class CamouflageCloak(SurvivalClothing):
    """
    A cloak designed to blend into natural environments.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.key = "camouflage cloak"
        self.aliases.add = ["cloak", "camo cloak"]
        self.db.desc = "A cloak dyed in mottled greens and browns to blend with foliage."
        
        self.db.clothing_type = "cloak"
        self.db.warmth_value = 15
        self.db.weather_protection = ["rain", "wind"]
        self.db.protection_value = 1
        
        # Hard to see when dropped in nature
        self.db.contrast = "camouflaged"
        self.db.camouflage_type = "natural"
        
        # Gives stealth bonus when worn
        self.db.stealth_bonus = 20  # +20% harder to detect
        
        self.db.repair_materials = ["cloth", "dye"]


# typeclasses/objects.py (lägg till dessa klasser)

class Food(Object):
    """
    Base class for food items.
    
    Food provides nutrition and can decay over time.
    Quality affects nutrition value.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.db.nutrition = 20
        self.db.decay_rate = 0.1
        self.db.uses = 1
        self.db.created_time = 0  # Vi behöver importera gametime om vi vill använda det
        
    def get_nutrition_value(self):
        """Get current nutrition considering decay."""
        # Förenklad version utan gametime
        base_nutrition = self.db.nutrition
        if hasattr(self.db, 'quality_modifier'):
            base_nutrition *= self.db.quality_modifier
            
        return int(base_nutrition)
    
    def at_eat(self, eater):
        """Called when someone eats this food."""
        nutrition = self.get_nutrition_value()
        
        # Apply nutrition
        eater.traits.hunger.current += nutrition
        
        # Check for special effects
        if hasattr(self.db, 'warmth_bonus'):
            eater.msg(f"|yThe {self.key} warms you from within.|n")
            # Could apply temporary warmth effect here
        
        # Use up one portion
        self.db.uses -= 1
        if self.db.uses <= 0:
            self.delete()
        else:
            eater.msg(f"There are {self.db.uses} portions left.")


class Tool(Object):
    """
    Base class for tools that can be used in crafting.
    
    Tools have durability and efficiency that affect
    crafting outcomes.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.db.tool_type = "general"
        self.db.efficiency = 1.0
        self.db.durability = 100
        self.db.max_durability = 100
        self.db.quality = 50
        
    def use_tool(self, uses=1):
        """Apply wear to the tool."""
        self.db.durability -= uses
        
        if self.db.durability <= 0:
            self.location.msg_contents(f"{self.key} breaks from overuse!")
            self.delete()
        elif self.db.durability < 20:
            self.location.msg_contents(f"{self.key} is nearly broken.")
    
    def get_efficiency(self):
        """Get current efficiency based on condition."""
        condition_factor = self.db.durability / self.db.max_durability
        return self.db.efficiency * condition_factor


class CraftingStation(Object):
    """
    A crafting station that provides bonuses to crafting.
    
    Examples: workbench, forge, alchemy table
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.db.station_type = "general"
        self.db.crafting_bonus = 10
        self.db.workshop_level = 1
        self.db.desc = "A crafting station for creating items."
        
        # Make it non-portable by default
        self.db.get_err_msg = "The {key} is too heavy to pick up."
        
    def at_object_receive(self, moved_obj, source_location, **kwargs):
        """Called when an object enters this station (storage)."""
        if moved_obj.tags.has("tool", category="item_type"):
            moved_obj.msg(f"You store {moved_obj.key} in the {self.key}.")


class SteamEngine(Object):
    """A steam engine that can power other devices."""
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.db.power_output = 100
        self.db.fuel_efficiency = 0.7
        self.db.max_pressure = 150
        self.db.current_pressure = 0
        self.db.fuel_level = 0
        self.db.water_level = 0
        self.db.is_running = False
        
    def add_fuel(self, amount):
        """Add coal to the engine."""
        self.db.fuel_level += amount
        return True
        
    def add_water(self, amount):
        """Add water to the boiler."""
        self.db.water_level += amount
        return True
        
    def start_engine(self):
        """Attempt to start the engine."""
        if self.db.fuel_level < 1:
            return False, "Not enough fuel!"
        if self.db.water_level < 1:
            return False, "Not enough water!"
            
        self.db.is_running = True
        self.db.current_pressure = 50  # Starting pressure
        
        # TODO: Add TickerHandler for fuel consumption
        return True, "The engine roars to life!"
        
    def stop_engine(self):
        """Shut down the engine."""
        self.db.is_running = False
        self.db.current_pressure = 0
        return True, "The engine winds down to a stop."


class Consumable(Object):
    """
    Base class for consumable items like potions, tea, etc.
    
    Can have various effects when consumed.
    """
    
    def at_object_creation(self):
        super().at_object_creation()
        
        self.db.uses = 1
        self.db.effect_type = None
        self.db.effect_value = 0
        
    def consume(self, consumer):
        """Apply the consumable's effects."""
        effect_type = self.db.effect_type
        
        if effect_type == "heal_minor":
            amount = self.db.healing_value or 10
            consumer.traits.health.current += amount
            consumer.msg(f"|gYou feel better! (+{amount} health)|n")
            
        elif effect_type == "restore_fatigue":
            amount = self.db.fatigue_value or 20
            consumer.traits.fatigue.current += amount
            consumer.msg(f"|yYou feel refreshed! (+{amount} fatigue)|n")
            
        # Handle thirst if it's a drink
        if self.tags.has("drink", category="item_type"):
            thirst_value = self.db.thirst_value or 10
            consumer.traits.thirst.current += thirst_value
            
        self.db.uses -= 1
        if self.db.uses <= 0:
            self.delete()



class Container(Object):
    """
    Placeholder - Remove lllather!
    """

    def at_object_creation(self):
        super().at_object_creation()

pass
</file>

<file path="typeclasses/rooms.py">
# typeclasses/rooms.py
"""
Rooms

Rooms are simple containers that has no location of their own.

This implementation extends the ExtendedRoom contrib to add:
- Dynamic descriptions based on time, weather, and season
- Resource nodes for gathering
- Weather states that affect gameplay
- Advanced visibility system for exits and objects
- Integration with the custom gametime system
- Environmental effects based on character clothing
"""

from evennia.contrib.grid.extended_room import ExtendedRoom as BaseExtendedRoom
from evennia.utils import list_to_string, lazy_property
from evennia import FuncParser
from django.conf import settings
import random
import re

from .objects import ObjectParent


class Room(ObjectParent, BaseExtendedRoom):
    """
    Extended Room with dynamic descriptions and visibility system.
    
    This room type supports:
    - Seasonal descriptions that change automatically
    - Weather states that affect visibility and gameplay
    - Resource nodes for gathering materials
    - Advanced visibility calculations for objects and exits
    - Integration with the custom gametime system
    - Environmental effects modified by character clothing
    
    The visibility system considers:
    - Time of day (day/night cycle)
    - Weather conditions (fog, rain, storm)
    - Object properties (size, luminosity, contrast)
    - Light sources carried by characters
    """
    
    # Override parent class settings to match our fantasy calendar
    months_per_year = 12
    hours_per_day = 24
    
    # Seasons aligned with our fantasy calendar
    seasons_per_year = {
        "winter": (11 / 12, 3 / 12),    # Darkening through Thawmoon
        "spring": (3 / 12, 6 / 12),     # Seedtime through Greentide
        "summer": (6 / 12, 9 / 12),     # Sunpeak through Goldfall
        "autumn": (9 / 12, 11 / 12),    # Harvestmoon through Dimming
    }
    
    # Time of day for descriptions (matching our TIME_OF_DAY setting)
    times_of_day = {
        "night": (22 / 24, 5 / 24),     # 22:00 - 04:59
        "dawn": (5 / 24, 7 / 24),       # 05:00 - 06:59
        "morning": (7 / 24, 12 / 24),   # 07:00 - 11:59
        "noon": (12 / 24, 14 / 24),     # 12:00 - 13:59
        "afternoon": (14 / 24, 17 / 24), # 14:00 - 16:59
        "dusk": (17 / 24, 19 / 24),     # 17:00 - 18:59
        "evening": (19 / 24, 22 / 24),  # 19:00 - 21:59
    }
    
    def at_object_creation(self):
        """
        Called when room is first created.
        Sets up resource nodes and default states.
        """
        super().at_object_creation()
        
        # Set default room type
        self.db.indoor = False  # Most rooms are outdoor by default
        
        # Initialize resource nodes
        self.db.resources = {
            "wood": {
                "base_amount": 5,
                "current": 5,
                "respawn_time": 3600,  # 1 real hour = 4 game hours
                "skill_required": "foraging",
                "min_skill": 0,
                "tool_required": None,
                "seasonal_modifier": {"spring": 1.2, "summer": 1.5, "autumn": 1.3, "winter": 0.5}
            },
            "stone": {
                "base_amount": 3,
                "current": 3,
                "respawn_time": 7200,  # 2 real hours
                "skill_required": "foraging",
                "min_skill": 0,
                "tool_required": "pickaxe",
                "seasonal_modifier": {"spring": 1.0, "summer": 1.0, "autumn": 1.0, "winter": 0.8}
            },
            "plants": {
                "base_amount": 8,
                "current": 8,
                "respawn_time": 1800,  # 30 minutes
                "skill_required": "foraging",
                "min_skill": 0,
                "tool_required": None,
                "seasonal_modifier": {"spring": 1.5, "summer": 2.0, "autumn": 1.0, "winter": 0.1}
            },
            "water": {
                "base_amount": -1,  # Unlimited
                "current": -1,
                "respawn_time": 0,
                "skill_required": None,
                "min_skill": 0,
                "tool_required": "container",
                "seasonal_modifier": {"spring": 1.2, "summer": 0.8, "autumn": 1.0, "winter": 1.5}
            }
        }
        
        # Weather states this room can have - include 'wind'
        self.db.possible_weather = ["clear", "cloudy", "rain", "storm", "fog", "snow", "wind"]
        
        # Set initial weather
        self.add_room_state("clear")
        
        # Workshop properties for crafting
        self.db.workshop = False  # Is this a proper workshop?
        self.db.workshop_level = 0  # 0=none, 1=basic, 2=advanced, 3=master
        self.db.allow_fire = False  # Can fires be built here?
        self.db.crafting_stations = []  # List of permanent stations
    
    def get_crafting_bonus(self, recipe_type="general"):
        """
        Get the total crafting bonus this room provides.
        
        Args:
            recipe_type (str): Type of crafting being done
            
        Returns:
            int: Total bonus percentage
        """
        bonus = 0
        
        # Base workshop bonus
        if self.db.workshop:
            bonus += self.db.workshop_level * 5
        
        # Check for relevant crafting stations
        for obj in self.contents:
            if obj.tags.has("crafting_station", category="item_type"):
                if hasattr(obj.db, 'station_type'):
                    if obj.db.station_type == recipe_type or obj.db.station_type == "general":
                        bonus += obj.db.crafting_bonus or 0
        
        return bonus
    
    def get_season(self):
        """
        Override to use our custom gametime system.
        
        Returns:
            str: Current season based on game calendar
        """
        from world.gametime_utils import get_current_season
        return get_current_season()
    
    def get_time_of_day(self):
        """
        Override to use our custom gametime system.
        
        Returns:
            str: Current time of day
        """
        from world.gametime_utils import get_time_of_day
        # The utility returns times that match our setup
        return get_time_of_day()
    
    def _get_funcparser(self, looker):
        """
        Get the FuncParser for handling $state() tags.
        Override to ensure our custom func_state works properly.
        """
        def custom_func_state(roomstate, *args, room=None, **kwargs):
            """Custom state function that properly handles states."""
            if not room:
                room = self
            
            roomstate = str(roomstate).lower()
            text = ", ".join(str(arg) for arg in args)
        
            # Check if state is active
            if roomstate in room.room_states or roomstate == room.get_time_of_day():
                return text
            elif roomstate == "default" and not room.room_states:
                return text
        
            return ""  # Return empty string if state not active
    
        return FuncParser(
            {"state": custom_func_state},
            looker=looker,
            room=self,
        )

    def get_current_weather(self):
        """
        Get the current weather states affecting this room.
        
        Returns:
            list: Active weather states
        """
        # Filter room states to only weather-related ones
        weather_states = []
        possible_weather = self.db.possible_weather or []
        
        for state in self.room_states:
            if state in possible_weather:
                weather_states.append(state)
        
        return weather_states if weather_states else ["clear"]
    
    def get_visibility_range(self, looker):
        """
        Calculate how many rooms away the looker can see from this room.
        
        Visibility is affected by:
        - Time of day (day=10, dusk/dawn=5, night=2)
        - Weather conditions (fog=1, storm=3, rain=7)
        - Indoor/outdoor status (indoor always has full visibility)
        - Light sources carried by the looker
        
        Args:
            looker (Character): The character trying to see
            
        Returns:
            int: Number of rooms visible in each direction (0-10)
        """
        # Base visibility for outdoor rooms during daytime
        base_visibility = 10
        
        # Indoor rooms always have full visibility
        if self.db.indoor:
            return base_visibility
        
        # Time of day affects visibility dramatically
        current_time = self.get_time_of_day()
        time_visibility = {
            "dawn": 5,      # Low sun angle creates long shadows
            "morning": 8,   # Good visibility as sun rises
            "noon": 10,     # Maximum visibility
            "afternoon": 8, # Still good visibility
            "dusk": 5,      # Sun setting reduces visibility
            "evening": 3,   # Twilight visibility
            "night": 2      # Minimal natural light
        }
        
        # Get base visibility from time
        visibility = time_visibility.get(current_time, 10)
        
        # Check for weather impacts (use the worst condition)
        weather_conditions = self.get_current_weather()
        weather_limits = {
            "fog": 1,        # Dense fog severely limits vision
            "storm": 3,      # Storm conditions with rain and wind
            "rain": 7,       # Light rain has minor impact
            "snow": 5,       # Snow reflects light but obscures distance
            "cloudy": 9,     # Overcast slightly reduces visibility
            "clear": 10      # No weather impediment
        }
        
        # Apply worst weather condition
        for condition in weather_conditions:
            if condition in weather_limits:
                visibility = min(visibility, weather_limits[condition])
        
        # Light sources help in darkness
        if current_time in ["night", "evening", "dusk", "dawn"]:
            # Check if looker has a light source
            for obj in looker.contents:
                if obj.db.is_light_source and obj.db.light_active:
                    # Light source provides minimum visibility of 5
                    visibility = max(visibility, 5)
                    break
        
        return visibility
    
    def get_resource_availability(self, resource_type):
        """
        Get the effective availability of a resource considering season and weather.
        
        Args:
            resource_type (str): Type of resource to check
            
        Returns:
            float: Multiplier for resource availability (0.0 - 2.0)
        """
        if resource_type not in self.db.resources:
            return 0.0
        
        resource = self.db.resources[resource_type]
        base_modifier = 1.0
        
        # Apply seasonal modifier
        season = self.get_season()
        seasonal_mods = resource.get("seasonal_modifier", {})
        base_modifier *= seasonal_mods.get(season, 1.0)
        
        # Apply weather modifiers
        weather = self.get_current_weather()
        if "storm" in weather or "snow" in weather:
            base_modifier *= 0.5  # Harsh weather reduces gathering
        elif "rain" in weather:
            base_modifier *= 0.8  # Light rain has minor impact
        
        # Special case: water is more available in rain/snow
        if resource_type == "water" and ("rain" in weather or "snow" in weather):
            base_modifier *= 2.0
        
        return base_modifier
    
    def calculate_object_visibility(self, obj, looker):
        """
        Calculate visibility chance for a specific object.
        
        Args:
            obj (Object): The object to check visibility for
            looker (Character): The character trying to see
            
        Returns:
            float: Visibility chance (0.0 - 1.0)
        """
        base_visibility = 1.0
        
        # Get object visibility properties
        size = obj.db.visibility_size or "normal"
        luminosity = obj.db.luminosity or "normal"
        contrast = obj.db.contrast or "normal"
        hidden = obj.db.hidden or False
        
        # Hidden objects require active searching
        if hidden:
            return 0.0
        
        # Size modifiers
        size_mods = {
            "tiny": 0.3,      # Coins, rings, small gems
            "small": 0.5,     # Keys, pouches, small tools
            "normal": 1.0,    # Standard objects
            "large": 1.2,     # Furniture, large containers
            "huge": 1.5       # Vehicles, structures
        }
        base_visibility *= size_mods.get(size, 1.0)
        
        # Time and weather affect visibility
        current_time = self.get_time_of_day()
        weather = self.get_current_weather()
        
        # Track if we have light for later calculations
        has_light = False
        
        # Darkness penalties
        if current_time in ["night", "evening"]:
            base_visibility *= 0.5
            
            # Dark objects are harder to see at night
            if contrast == "dark":
                base_visibility *= 0.7  # Additional -30%
            
            # Check for light sources FIRST before applying shiny bonus
            for item in looker.contents:
                if item.db.is_light_source and item.db.light_active:
                    has_light = True
                    # Light source dramatically improves visibility
                    base_visibility *= 3.0  # Triple visibility with light
                    break
            
            # Shiny objects easier to see with any light
            if luminosity == "shiny":
                if has_light:
                    base_visibility *= 1.2  # Additional +20% for shiny with light
                else:
                    base_visibility *= 1.5  # +50% for shiny in darkness (self-luminous)
        
        # Daylight bonuses
        elif current_time in ["noon", "morning", "afternoon"]:
            if luminosity == "shiny":
                base_visibility *= 1.2  # +20% in sunlight
        
        # Weather impacts
        if "fog" in weather:
            base_visibility *= 0.3
        elif "rain" in weather or "storm" in weather:
            base_visibility *= 0.7
        elif "snow" in weather:
            base_visibility *= 0.8
        
        # Camouflaged objects in matching environments
        if contrast == "camouflaged":
            # Determine if environment matches
            room_desc = self.db.desc or ""
            # Make camouflage more effective
            if any(word in room_desc.lower() for word in ["forest", "tree", "grass", "leaves", "foliage"]):
                if hasattr(obj.db, 'camouflage_type') and obj.db.camouflage_type == "natural":
                    base_visibility *= 0.4  # Ändrat från 0.5 till 0.4 för att testet ska passera
            else:
                # Camouflage still helps a bit even in wrong environment
                base_visibility *= 0.7
        
        return min(max(base_visibility, 0.0), 1.0)
    
    def get_visible_objects(self, looker, candidates=None):
        """
        Filter objects based on visibility.
        
        Args:
            looker (Character): The character looking
            candidates (list, optional): Objects to check. If None, use room contents
            
        Returns:
            list: Objects that are visible to the looker
        """
        if candidates is None:
            candidates = self.contents
        
        visible = []
        for obj in candidates:
            # Always see characters and exits
            if obj.is_typeclass("typeclasses.characters.Character") or \
               obj.is_typeclass("typeclasses.exits.Exit"):
                visible.append(obj)
                continue
            
            # Calculate visibility for other objects
            visibility_chance = self.calculate_object_visibility(obj, looker)
            
            # Always see obvious items
            if obj.db.visibility_size == "obvious":
                visible.append(obj)
            # Random chance for others based on visibility
            elif random.random() < visibility_chance:
                visible.append(obj)
        
        return visible
    
    def extract_resource(self, gatherer, resource_type, amount=1):
        """
        Attempt to extract resources from this room.
        
        Args:
            gatherer (Character): Character attempting to gather
            resource_type (str): Type of resource to gather
            amount (int): Amount to try to gather
            
        Returns:
            tuple: (success, actual_amount, skill_gain)
        """
        if resource_type not in self.db.resources:
            return (False, 0, 0)
        
        resource = self.db.resources[resource_type]
        
        # Check if resource is available
        current = resource.get("current", 0)
        if current == 0:
            return (False, 0, 0)
        
        # Check skill requirements
        skill_required = resource.get("skill_required")
        min_skill = resource.get("min_skill", 0)
        
        if skill_required:
            gatherer_skill = gatherer.get_skill_level(skill_required)[0] or 0
            if gatherer_skill < min_skill:
                gatherer.msg(f"You need at least {min_skill} {skill_required} to gather {resource_type} here.")
                return (False, 0, 0)
        
        # Check tool requirements
        tool_required = resource.get("tool_required")
        if tool_required:
            has_tool = any(obj.key.lower() == tool_required.lower() 
                          for obj in gatherer.contents)
            if not has_tool:
                gatherer.msg(f"You need a {tool_required} to gather {resource_type}.")
                return (False, 0, 0)
        
        # Calculate actual amount based on availability
        availability = self.get_resource_availability(resource_type)
        skill_bonus = 1.0
        if skill_required:
            skill_level = gatherer.get_skill_level(skill_required)[0] or 0
            skill_bonus = 1.0 + (skill_level / 100.0)  # Up to 2x at max skill
        
        # Determine actual gathered amount
        max_gather = min(amount, current) if current > 0 else amount
        actual_amount = int(max_gather * availability * skill_bonus)
        actual_amount = max(1, actual_amount)  # Always get at least 1 if successful
        
        # Update resource if not unlimited
        if current > 0:
            resource["current"] = max(0, current - actual_amount)
        
        # Calculate skill gain (more gain for harder resources)
        skill_gain = 1
        if skill_required and gatherer_skill < 100:
            difficulty_bonus = 1 + (min_skill / 20)  # Harder resources give more XP
            skill_gain = int(difficulty_bonus)
        
        return (True, actual_amount, skill_gain)
    
    def get_environmental_effects(self, character):
        """
        Calculate environmental effects on a character based on
        weather, season, and their clothing.
        
        Args:
            character: The character to check
            
        Returns:
            dict: Environmental modifiers to apply
        """
        effects = {
            "fatigue_rate_mod": 1.0,  # Multiplier for fatigue decay
            "thirst_rate_mod": 1.0,   # Multiplier for thirst decay
            "health_drain": 0,         # Direct health loss per hour
            "messages": []             # Warning messages
        }

        # Indoor rooms protect from all weather effects
        if self.db.indoor:
            return effects  # Return early with no modifications
        
        # Get conditions
        season = self.get_season()
        weather = self.get_current_weather()
        time_of_day = self.get_time_of_day()
        
        # Get character's protection
        warmth = character.get_total_warmth()
        protection = character.get_environmental_protection()
        
        # COLD EFFECTS (Winter/Night)
        if season == "winter" or (time_of_day == "night" and self.db.indoor == False):
            base_cold = 20 if season == "winter" else 10
            
            # Snow makes it worse
            if "snow" in weather:
                base_cold += 10
                
            # Check if character has enough warmth
            warmth_deficit = base_cold - warmth
            
            if warmth_deficit > 15:
                effects["fatigue_rate_mod"] *= 2.0
                effects["health_drain"] = 2
                effects["messages"].append("|rYou are freezing!|n")
            elif warmth_deficit > 5:
                effects["fatigue_rate_mod"] *= 1.5
                effects["health_drain"] = 1
                effects["messages"].append("|yYou are very cold.|n")
            elif warmth_deficit > 0:
                effects["fatigue_rate_mod"] *= 1.2
                effects["messages"].append("|yYou feel chilly.|n")
        
        # HEAT EFFECTS (Summer)
        elif season == "summer" and time_of_day in ["noon", "afternoon"]:
            # Base heat effects
            if time_of_day == "noon":
                # Noon is hottest
                effects["thirst_rate_mod"] *= 1.2
                effects["fatigue_rate_mod"] *= 1.1
                
            # Heavy clothing makes it worse
            if warmth > 30:
                effects["thirst_rate_mod"] *= 1.5  # This makes it 1.8 total if noon
                effects["fatigue_rate_mod"] *= 1.3  # This makes it 1.43 total if noon
                effects["messages"].append("|yYou are overheating in your heavy clothes.|n")
            elif warmth > 20:
                effects["thirst_rate_mod"] *= 1.2
                effects["fatigue_rate_mod"] *= 1.1
                effects["messages"].append("|yThe heat is making you sweat.|n")
        
        # RAIN EFFECTS
        if "rain" in weather or "storm" in weather:
            if not protection["rain"]:
                effects["fatigue_rate_mod"] *= 1.3
                if season == "winter":
                    effects["health_drain"] += 1
                    effects["messages"].append("|yYou are getting soaked and cold!|n")
                else:
                    effects["messages"].append("|yYou are getting wet.|n")
        
        # WIND EFFECTS  
        if "wind" in weather or "storm" in weather:
            if not protection["wind"]:
                if season == "winter":
                    effects["fatigue_rate_mod"] *= 1.2
                    effects["messages"].append("|yThe wind cuts through your clothes.|n")
        
        return effects
    
    def get_display_exits(self, looker, **kwargs):
        """
        Get the exit display, considering visibility range.
        
        This extends the default to only show exits within visibility range.
        """
        if not looker:
            return ""
        
        # Get base visibility range
        visibility_range = self.get_visibility_range(looker)
        
        # Get all exits
        exits = []
        for exit in self.exits:
            # For exits, check if we can see into the destination
            if visibility_range > 0:
                exits.append(exit)
        
        if not exits:
            return ""
        
        # Format the exit display
        exit_strings = []
        for exit in exits:
            # Check if we can see what's beyond this exit
            can_see_beyond = visibility_range > 1
            if can_see_beyond and exit.destination:
                # Might show a preview of what's beyond
                exit_strings.append(f"|c{exit.key}|n")
            else:
                exit_strings.append(f"|C{exit.key}|n")
        
        return f"|wExits:|n {list_to_string(exit_strings)}"
    
    def get_display_things(self, looker, **kwargs):
        """
        Get the 'things' component of the object's contents. Called by `return_appearance`.
        
        This filters objects based on visibility before display.
        """
        if not looker:
            return ""
        
        # Get visible objects only
        things = []
        for thing in self.contents_get(exclude=looker):
            # Skip exits (handled separately)
            if thing.destination:
                continue
                
            # Check visibility
            if thing in self.get_visible_objects(looker, [thing]):
                things.append(thing)
        
        if not things:
            return ""
        
        # Group by visibility category for better display
        obvious_things = []
        normal_things = []
        hard_to_see = []
        
        for thing in things:
            visibility = self.calculate_object_visibility(thing, looker)
            if thing.db.visibility_size == "obvious" or visibility > 0.8:
                obvious_things.append(thing)
            elif visibility > 0.5:
                normal_things.append(thing)
            else:
                hard_to_see.append(thing)
        
        thing_strings = []
        
        # Format different visibility groups
        if obvious_things:
            for thing in obvious_things:
                thing_strings.append(thing.get_display_name(looker, **kwargs))
        
        if normal_things:
            for thing in normal_things:
                thing_strings.append(thing.get_display_name(looker, **kwargs))
        
        if hard_to_see:
            # These are barely visible
            for thing in hard_to_see:
                thing_strings.append(f"|x{thing.get_display_name(looker, **kwargs)}|n")
        
        return f"|wYou see:|n {list_to_string(thing_strings)}"
    
    def return_appearance(self, looker, **kwargs):
        """
        Main appearance method - including visibility filtering.
        """
        if not looker:
            return ""
        
        # Get the dynamic description based on time/season/weather
        visible_string = f"|c{self.get_display_name(looker, **kwargs)}|n"
        desc = self.get_display_desc(looker, **kwargs)
        
        # Add current conditions to description
        time_of_day = self.get_time_of_day()
        weather = self.get_current_weather()
        season = self.get_season()
        
        # Add atmospheric conditions
        condition_string = f"\n|xTime: {time_of_day.title()}, Season: {season.title()}, Weather: {', '.join(weather).title()}|n"
        
        # Get exits and things with visibility filtering
        exits = self.get_display_exits(looker, **kwargs)
        things = self.get_display_things(looker, **kwargs)
        
        # Build final appearance
        string = f"{visible_string}\n{desc}{condition_string}"
        if exits:
            string += f"\n{exits}"
        if things:
            string += f"\n{things}"
        
        return string
</file>

<file path="commands/default_cmdsets.py">
# commands/default_cmdsets.py (uppdaterad med survival commands)
"""
Command sets

All commands in the game must be grouped in a cmdset.  A given command
can be part of any number of cmdsets and cmdsets can be added/removed
and merged onto entities at runtime.

To create new commands to populate the cmdset, see
`commands/command.py`.

This module wraps the default command sets of Evennia; overloads them
to add/remove commands from the default lineup. You can create your
own cmdsets by inheriting from them or directly from `evennia.CmdSet`.

"""

from evennia import default_cmds
from commands.time_commands import CmdTime, CmdUptime
from commands.search_commands import CmdSearch, CmdLight
from commands.resource_commands import CmdGather, CmdForage
from commands.survival_commands import CmdRest, CmdEat, CmdDrink, CmdStatus
from evennia.contrib.grid.extended_room import ExtendedRoomCmdSet
from evennia.contrib.game_systems.clothing.clothing import ClothedCharacterCmdSet
from commands.clothing_commands import CmdClothingStatus, CmdRepair
from commands.crafting_commands import CmdCraft, CmdRecipes


class CharacterCmdSet(default_cmds.CharacterCmdSet):
    """
    The `CharacterCmdSet` contains general in-game commands like `look`,
    `get`, etc available on in-game Character objects. It is merged with
    the `AccountCmdSet` when an Account puppets a Character.
    """

    key = "DefaultCharacter"

    def at_cmdset_creation(self):
        """
        Populates the cmdset
        """
        super().at_cmdset_creation()
        #
        # any commands you add below will overload the default ones.
        #
        # Add time-related commands
        self.add(CmdTime())
        self.add(CmdUptime())

        # Add Extended Room commands (includes enhanced look)
        self.add(ExtendedRoomCmdSet)
        
        # Add search and light commands
        self.add(CmdSearch())
        self.add(CmdLight())
        
        # Add resource gathering commands
        self.add(CmdGather())
        self.add(CmdForage())
        
        # Add survival commands
        self.add(CmdRest())
        self.add(CmdEat())
        self.add(CmdDrink())
        self.add(CmdStatus())

        # Add clothing commands
        self.add(ClothedCharacterCmdSet)
        self.add(CmdClothingStatus())
        self.add(CmdRepair())

        # Add crafting commands
        self.add(CmdCraft())
        self.add(CmdRecipes())


class AccountCmdSet(default_cmds.AccountCmdSet):
    """
    This is the cmdset available to the Account at all times. It is
    combined with the `CharacterCmdSet` when the Account puppets a
    Character. It holds game-account-specific commands, channel
    commands, etc.
    """

    key = "DefaultAccount"

    def at_cmdset_creation(self):
        """
        Populates the cmdset
        """
        super().at_cmdset_creation()
        #
        # any commands you add below will overload the default ones.
        #


class UnloggedinCmdSet(default_cmds.UnloggedinCmdSet):
    """
    Command set available to the Session before being logged in.  This
    holds commands like creating a new account, logging in, etc.
    """

    key = "DefaultUnloggedin"

    def at_cmdset_creation(self):
        """
        Populates the cmdset
        """
        super().at_cmdset_creation()
        #
        # any commands you add below will overload the default ones.
        #


class SessionCmdSet(default_cmds.SessionCmdSet):
    """
    This cmdset is made available on Session level once logged in. It
    is empty by default.
    """

    key = "DefaultSession"

    def at_cmdset_creation(self):
        """
        This is the only method defined in a cmdset, called during
        its creation. It should populate the set with command instances.

        As and example we just add the empty base `Command` object.
        It prints some info.
        """
        super().at_cmdset_creation()
        #
        # any commands you add below will overload the default ones.
        #
</file>

<file path="server/conf/settings.py">
r"""
Evennia settings file.

The available options are found in the default settings file found
here:

https://www.evennia.com/docs/latest/Setup/Settings-Default.html

Remember:

Don't copy more from the default file than you actually intend to
change; this will make sure that you don't overload upstream updates
unnecessarily.

When changing a setting requiring a file system path (like
path/to/actual/file.py), use GAME_DIR and EVENNIA_DIR to reference
your game folder and the Evennia library folders respectively. Python
paths (path.to.module) should be given relative to the game's root
folder (typeclasses.foo) whereas paths within the Evennia library
needs to be given explicitly (evennia.foo).

If you want to share your game dir, including its settings, you can
put secret game- or server-specific settings in secret_settings.py.

"""

# Use the defaults from Evennia unless explicitly overridden
from evennia.settings_default import *

######################################################################
# Evennia base server config
######################################################################

# This is the name of your game. Make it catchy!
SERVERNAME = "PolishedWorld"



######################################################################
# Custom Gametime Configuration
######################################################################

# Game runs at 4x real time speed
# 1 real hour = 4 game hours
# 6 real hours = 24 game hours (1 game day)
TIME_FACTOR = 4

# Fantasy calendar with 12 months of 30 days each
# Total: 360 days per year (easy math for seasons)
TIME_UNITS = {
    "sec": 1,
    "min": 60,
    "hour": 60 * 60,
    "day": 60 * 60 * 24,
    "week": 60 * 60 * 24 * 7,
    "month": 60 * 60 * 24 * 30,      # Exactly 30 days per month
    "year": 60 * 60 * 24 * 30 * 12,  # 360 days per year
}

# Fantasy month names reflecting the steampunk theme
# Winter: Months 0, 1, 2 (Frosthold, Icewind, Thawmoon)
# Spring: Months 3, 4, 5 (Seedtime, Bloomheart, Greentide)
# Summer: Months 6, 7, 8 (Sunpeak, Hearthfire, Goldfall)
# Autumn: Months 9, 10, 11 (Harvestmoon, Dimming, Darkening)
MONTH_NAMES = [
    "Frosthold",    # Month 0 - Deep winter
    "Icewind",      # Month 1 - Late winter
    "Thawmoon",     # Month 2 - Winter's end
    "Seedtime",     # Month 3 - Early spring
    "Bloomheart",   # Month 4 - Mid spring
    "Greentide",    # Month 5 - Late spring
    "Sunpeak",      # Month 6 - Early summer
    "Hearthfire",   # Month 7 - High summer
    "Goldfall",     # Month 8 - Late summer
    "Harvestmoon",  # Month 9 - Early autumn
    "Dimming",      # Month 10 - Mid autumn
    "Darkening"     # Month 11 - Late autumn
]

# Define seasons based on months
# This will be used by Extended Room later
SEASONS = {
    "winter": [11, 0, 1, 2],   # Darkening through Thawmoon
    "spring": [3, 4, 5],       # Seedtime through Greentide
    "summer": [6, 7, 8],       # Sunpeak through Goldfall
    "autumn": [9, 10]          # Harvestmoon through Dimming
}

# Time of day descriptions for immersion
TIME_OF_DAY = {
    "dawn": (5, 7),        # 05:00 - 06:59
    "morning": (7, 12),    # 07:00 - 11:59
    "noon": (12, 14),      # 12:00 - 13:59
    "afternoon": (14, 17), # 14:00 - 16:59
    "dusk": (17, 19),      # 17:00 - 18:59
    "evening": (19, 22),   # 19:00 - 21:59
    "night": (22, 5)       # 22:00 - 04:59
}

######################################################################
# Character and Traits Configuration
######################################################################

# How often survival traits should be updated (in real seconds)
# With TIME_FACTOR = 4, 900 real seconds = 1 game hour
TRAIT_UPDATE_INTERVAL = 900  # Update every game hour

# Trait decay rates per game hour
TRAIT_DECAY_RATES = {
    "hunger": -2,    # Lose 2 hunger per game hour
    "thirst": -3,    # Lose 3 thirst per game hour
    "fatigue": -1,   # Lose 1 fatigue per game hour
}

######################################################################
# Extended Room Configuration
######################################################################

# Default typeclass for new rooms
BASE_ROOM_TYPECLASS = "typeclasses.rooms.Room"

# Weather change frequency (in real seconds)
WEATHER_CHANGE_INTERVAL = 900  # 15 minutes = 1 game hour

# Resource regeneration interval (in real seconds)
RESOURCE_REGEN_INTERVAL = 3600  # 1 hour real time

# Valid weather states
WEATHER_STATES = ["clear", "cloudy", "rain", "storm", "fog", "snow", "wind"]

# Weather probability by season
SEASONAL_WEATHER = {
    "winter": {
        "clear": 0.2,
        "cloudy": 0.3,
        "snow": 0.3,
        "fog": 0.1,
        "storm": 0.1
    },
    "spring": {
        "clear": 0.4,
        "cloudy": 0.3,
        "rain": 0.2,
        "fog": 0.05,
        "storm": 0.05
    },
    "summer": {
        "clear": 0.6,
        "cloudy": 0.2,
        "rain": 0.1,
        "storm": 0.1
    },
    "autumn": {
        "clear": 0.3,
        "cloudy": 0.3,
        "rain": 0.2,
        "fog": 0.15,
        "storm": 0.05
    }
}

# Visibility modifiers for special conditions
VISIBILITY_MODIFIERS = {
    "torch": 3,      # Minimum visibility with torch
    "lantern": 4,    # Minimum visibility with lantern
    "magic_light": 5 # Minimum visibility with magical light
}

######################################################################
# Clothing Configuration
######################################################################

# Clothing System Configuration
CLOTHING_WEARSTYLE_MAXLENGTH = 50

# Order of clothing types in descriptions
CLOTHING_TYPE_ORDERED = [
    "hat",
    "goggles",
    "cloak",
    "outerwear",
    "top",
    "undershirt", 
    "gloves",
    "fullbody",
    "bottom",
    "underpants",
    "socks",
    "boots",
    "belt",
    "accessory"
]

# Maximum items that can be worn
CLOTHING_OVERALL_LIMIT = 20

# Type-specific limits
CLOTHING_TYPE_LIMIT = {
    "hat": 1,
    "goggles": 1,
    "gloves": 1,
    "socks": 1,
    "boots": 1,
    "belt": 1
}

# Auto-covering rules
CLOTHING_TYPE_AUTOCOVER = {
    "top": ["undershirt"],
    "bottom": ["underpants"],
    "fullbody": ["undershirt", "underpants"],
    "boots": ["socks"],
    "outerwear": ["top"],
    "cloak": ["outerwear", "top"]
}

# Types that can't cover others
CLOTHING_TYPE_CANT_COVER_WITH = ["goggles", "belt", "accessory"]

######################################################################
# Cooldown Configuration
######################################################################

# Default cooldown durations in seconds
DEFAULT_COOLDOWNS = {
    "gather": 300,          # 5 minutes base
    "forage": 180,          # 3 minutes (shorter for quick food)
    "craft_basic": 300,     # 5 minutes for simple items
    "craft_advanced": 1800, # 30 minutes for complex items
    "rest": 180,            # 3 minutes between rest sessions
    "hunt": 1200,           # 20 minutes for hunting
    "trade": 60,            # 1 minute between trades
    "repair": 600,          # 10 minutes for repairs
}

# Skill-based cooldown reduction
# At max skill (100), cooldowns are reduced by this percentage
MAX_SKILL_COOLDOWN_REDUCTION = 0.5  # 50% reduction at max skill

# Constitution bonus for physical actions
# Each point of CON above 10 reduces cooldowns by this percentage
CON_COOLDOWN_REDUCTION_PER_POINT = 0.01  # 1% per point

######################################################################
# Crafting Configuration
######################################################################

# Where to find crafting recipes
CRAFT_RECIPE_MODULES = [
    "world.recipes.survival_recipes",
    "world.recipes.steampunk_recipes", 
    "world.recipes.clothing_recipes",
    "world.recipes.tool_recipes",
]

# Crafting success modifiers
CRAFTING_SKILL_WEIGHT = 0.7  # How much skill affects success (0-1)
CRAFTING_TOOL_QUALITY_WEIGHT = 0.3  # How much tool quality affects result

# Recipe difficulty tiers
RECIPE_DIFFICULTY = {
    "trivial": 0,      # Anyone can do this
    "easy": 10,        # Novice crafters
    "moderate": 30,    # Apprentice level
    "hard": 50,        # Journeyman level
    "expert": 70,      # Expert crafters only
    "master": 90,      # Master crafters only
}

######################################################################
# Settings given in secret_settings.py override those in this file.
######################################################################
try:
    from server.conf.secret_settings import *
except ImportError:
    print("secret_settings.py file not found or failed to import.")
</file>

<file path="typeclasses/characters.py">
# typeclasses/characters.py
"""
Characters

Characters are (by default) Objects setup to be puppeted by Accounts.
They are what you "see" in game. The Character class in this module
is setup to be the "default" character type created by the default
creation commands.

This implementation uses the Traits contrib to provide a rich
character system with stats, survival needs, and skills, combined
with the Clothing contrib for layered equipment that provides
survival benefits and the Cooldowns contrib for action rate limiting.
"""

from evennia.utils import lazy_property
from evennia.contrib.rpg.traits import TraitHandler
from evennia.contrib.game_systems.clothing.clothing import ClothedCharacter as BaseClothedCharacter
from evennia.contrib.game_systems.cooldowns import CooldownHandler
from django.conf import settings

from .objects import ObjectParent


class Character(ObjectParent, BaseClothedCharacter):
    """
    The Character class implements a three-category trait system combined
    with a clothing system that provides survival benefits and a cooldown
    system for rate-limiting actions.
    
    Traits:
    1. Stats (static traits): Core attributes like strength, dexterity
    2. Traits (gauge traits): Survival needs with auto-decay (hunger, thirst, fatigue)
    3. Skills (counter traits): Learnable abilities that progress over time
    
    Clothing:
    - Layered clothing system with weather protection
    - Reduces trait decay in harsh conditions
    - Provides stat bonuses when worn
    - Integrates with Extended Room weather states
    
    Cooldowns:
    - Rate limits gathering, crafting, and other actions
    - Skill-based cooldown reduction for experienced characters
    - Prevents action spamming and encourages strategic timing
    
    Example usage:
        # Check if character has weather protection
        if character.has_weather_protection("rain"):
            # Reduce or eliminate rain penalties
            
        # Get total warmth from clothing
        warmth = character.get_total_warmth()
        
        # Check if action is on cooldown
        if character.cooldowns.ready("gather"):
            # Allow gathering
    """

    # Define the three trait category handlers
    @lazy_property
    def stats(self):
        """
        Handler for character statistics (strength, dexterity, etc).
        These are static traits that don't change automatically.
        """
        return TraitHandler(self, db_attribute_key="stats", db_attribute_category="traits")
    
    @lazy_property
    def traits(self):
        """
        Handler for survival traits (hunger, thirst, fatigue, health).
        These are gauge traits that can auto-decay over time.
        """
        return TraitHandler(self, db_attribute_key="traits", db_attribute_category="traits")
    
    @lazy_property
    def skills(self):
        """
        Handler for learnable skills (crafting, hunting, etc).
        These are counter traits that track progression.
        """
        return TraitHandler(self, db_attribute_key="skills", db_attribute_category="traits")

    @lazy_property
    def cooldowns(self):
        """
        Handler for action cooldowns.
        Tracks when various actions can be performed again.
        """
        return CooldownHandler(self, db_attribute="cooldowns")

    def at_object_creation(self):
        """
        Called once when the character is first created.
        Sets up all the initial traits with their default values.
        """
        super().at_object_creation()
        
        # Initialize Stats (static traits for base attributes)
        self.stats.add("strength", "Strength", trait_type="static", 
                      base=10, mod=0, mult=1.0)
        self.stats.add("dexterity", "Dexterity", trait_type="static", 
                      base=10, mod=0, mult=1.0)
        self.stats.add("constitution", "Constitution", trait_type="static", 
                      base=10, mod=0, mult=1.0)
        self.stats.add("intelligence", "Intelligence", trait_type="static", 
                      base=10, mod=0, mult=1.0)
        self.stats.add("wisdom", "Wisdom", trait_type="static", 
                      base=10, mod=0, mult=1.0)
        self.stats.add("charisma", "Charisma", trait_type="static", 
                      base=10, mod=0, mult=1.0)
        
        # Initialize Traits (gauge traits for survival needs)
        self.traits.add("hunger", "Hunger", trait_type="gauge", 
                       base=100, mod=0, min=0, rate=-2.0,
                       descs={19: "starving", 39: "very hungry", 59: "hungry", 
                             79: "peckish", 99: "satisfied", 100: "full"})
        
        self.traits.add("thirst", "Thirst", trait_type="gauge",
                       base=100, mod=0, min=0, rate=-3.0,
                       descs={19: "dehydrated", 39: "parched", 59: "thirsty",
                             79: "slightly thirsty", 99: "refreshed", 100: "hydrated"})
        
        self.traits.add("fatigue", "Fatigue", trait_type="gauge",
                       base=100, mod=0, min=0, rate=-1.0,
                       descs={19: "exhausted", 39: "very tired", 59: "tired",
                             79: "slightly tired", 99: "rested", 100: "energized"})
        
        self.traits.add("health", "Health", trait_type="gauge",
                       base=100, mod=0, min=0, rate=0,
                       descs={19: "dead", 39: "critically wounded", 59: "badly hurt",
                             79: "wounded", 99: "bruised", 100: "healthy"})
        
        # Initialize Skills
        skill_descs = {
            9: "untrained", 29: "novice", 49: "apprentice",
            69: "journeyman", 89: "expert", 100: "master"
        }
        
        for skill_name in ["crafting", "hunting", "foraging", 
                          "engineering", "survival", "trading"]:
            self.skills.add(skill_name, skill_name.title(), trait_type="counter",
                           base=0, mod=0, min=0, max=100, descs=skill_descs)
        
        # Initialize crafting tracking
        self.db.known_recipes = []
        self.db.craft_counts = {}
        self.db.best_quality = {}
        self.db.crafting_stats = {
            'total_crafted': 0,
            'total_failed': 0,
            'quality_counts': {}
        }
    
    def can_craft_recipe(self, recipe_class):
        """
        Check if character meets requirements for a recipe.
        
        Args:
            recipe_class: The recipe class to check
            
        Returns:
            tuple: (can_craft, reason)
        """
        # Check skill requirement
        skill_req = getattr(recipe_class, 'skill_requirement', 'crafting')
        difficulty = getattr(recipe_class, 'difficulty', 0)
        
        skill_level = 0
        if skill_req == "engineering":
            skill_level = self.skills.engineering.value
        elif skill_req == "survival":
            skill_level = self.skills.survival.value
        else:
            skill_level = self.skills.crafting.value
        
        if skill_level < difficulty:
            return False, f"Need {skill_req} {difficulty}+"
        
        # Check cooldown
        craft_category = getattr(recipe_class, 'craft_category', 'craft_basic')
        if not self.cooldowns.ready(craft_category):
            time_left = self.cooldowns.time_left(craft_category, use_int=True)
            return False, f"On cooldown ({time_left}s)"
        
        return True, "OK"
    
    # Cooldown-related methods
    
    def get_cooldown_modifier(self, action_type, skill_name=None):
        """
        Calculate cooldown modifier based on relevant skill.
        
        Higher skills reduce cooldowns, encouraging specialization.
        
        Args:
            action_type (str): Type of action ("gather", "craft", etc.)
            skill_name (str, optional): Specific skill to check
            
        Returns:
            float: Multiplier for cooldown duration (0.5 - 1.0)
        """
        if not skill_name:
            # Default skill associations
            skill_map = {
                "gather": "foraging",
                "craft": "crafting",
                "hunt": "hunting",
                "trade": "trading",
                "repair": "engineering",
                "rest": "survival"
            }
            skill_name = skill_map.get(action_type, "survival")
        
        skill = self.skills.get(skill_name)
        if not skill:
            return 1.0
        
        skill_level = skill.value
        
        # Linear reduction: 0 skill = 100% cooldown, 100 skill = 50% cooldown
        # This means masters can perform actions twice as often
        reduction = 0.5 + (0.5 * (100 - skill_level) / 100)
        
        return reduction
    
     # typeclasses/characters.py (uppdaterad apply_cooldown metod)

    def apply_cooldown(self, cooldown_name, base_duration, skill_name=None):
        """
        Apply a cooldown with skill-based reduction.
    
        Args:
            cooldown_name (str): Name of the cooldown
            base_duration (int): Base duration in seconds
            skill_name (str, optional): Skill that affects this cooldown
        
        Returns:
            int: Actual cooldown duration applied
        """
        # Get skill-based reduction
        modifier = self.get_cooldown_modifier(cooldown_name, skill_name)
    
        # Apply constitution bonus for physical actions
        if cooldown_name in ["gather", "hunt", "craft"]:
            con_value = self.stats.constitution.value
            # Each point above 10 gives 1% reduction, max 20% at CON 30
            if con_value > 10:
                con_bonus = min((con_value - 10) * 0.01, 0.20)
                modifier *= (1 - con_bonus)
    
        # Calculate final duration
        actual_duration = int(base_duration * modifier)
    
        # Set the cooldown
        self.cooldowns.add(cooldown_name, actual_duration)
    
        return actual_duration

    # Clothing-related methods for survival benefits
    
    def get_worn_clothes(self, exclude_covered=False):
        """
        Get a list of clothes worn by this character.
        
        This wraps the module function for easier access.
        
        Args:
            exclude_covered (bool): If True, exclude covered items
            
        Returns:
            list: Ordered list of worn clothing items
        """
        from evennia.contrib.game_systems.clothing.clothing import get_worn_clothes
        return get_worn_clothes(self, exclude_covered=exclude_covered)
    
    def has_weather_protection(self, weather_type):
        """
        Check if character has protection against specific weather.
        
        Args:
            weather_type (str): Type of weather ('rain', 'snow', 'wind', etc.)
            
        Returns:
            bool: True if character has adequate protection
        """
        worn_items = self.get_worn_clothes(exclude_covered=True)
        
        for item in worn_items:
            # Check if item provides weather protection
            protections = item.db.weather_protection or []
            if weather_type in protections:
                return True
                
        return False
    
    def get_total_warmth(self):
        """
        Calculate total warmth value from all worn clothing.
        
        Returns:
            int: Total warmth value (0-100+)
        """
        total_warmth = 0
        worn_items = self.get_worn_clothes(exclude_covered=True)
        
        for item in worn_items:
            warmth = item.db.warmth_value or 0
            total_warmth += warmth
            
        return total_warmth
    
    def get_clothing_stat_modifiers(self):
        """
        Get all stat modifiers from worn clothing.
        
        Returns:
            dict: Dictionary of stat modifiers {stat_name: total_modifier}
        """
        modifiers = {}
        worn_items = self.get_worn_clothes(exclude_covered=True)
        
        for item in worn_items:
            item_mods = item.db.stat_modifiers or {}
            for stat, value in item_mods.items():
                if stat in modifiers:
                    modifiers[stat] += value
                else:
                    modifiers[stat] = value
                    
        return modifiers
    
    def apply_clothing_modifiers(self):
        """
        Apply stat modifiers from clothing to character stats.
        
        This should be called whenever clothing changes.
        """
        # First, reset all stat mods to 0
        for stat_name in ["strength", "dexterity", "constitution", 
                         "intelligence", "wisdom", "charisma"]:
            stat = self.stats.get(stat_name)
            if stat:
                stat.mod = 0
        
        # Then apply clothing modifiers
        modifiers = self.get_clothing_stat_modifiers()
        for stat_name, modifier in modifiers.items():
            stat = self.stats.get(stat_name)
            if stat:
                stat.mod = modifier
    
    def get_environmental_protection(self):
        """
        Get a summary of all environmental protections.
        
        Returns:
            dict: Protection levels for different conditions
        """
        protection = {
            "cold": 0,      # Protection against cold/winter
            "heat": 0,      # Protection against heat/summer
            "rain": False,  # Binary - either protected or not
            "wind": False,  # Binary - either protected or not
            "general": 0    # General durability/protection
        }
        
        worn_items = self.get_worn_clothes(exclude_covered=True)
        
        for item in worn_items:
            # Warmth adds to cold protection
            protection["cold"] += item.db.warmth_value or 0
            
            # Check weather protections
            weather_prot = item.db.weather_protection or []
            if "rain" in weather_prot:
                protection["rain"] = True
            if "wind" in weather_prot:
                protection["wind"] = True
                
            # Heat protection (negative warmth values)
            if item.db.warmth_value and item.db.warmth_value < 0:
                protection["heat"] += abs(item.db.warmth_value)
                
            # General protection/armor
            protection["general"] += item.db.protection_value or 0
            
        return protection
    
    # Convenience methods (keeping all the original ones)
    
    def get_stat(self, stat_name):
        """Get a stat value by name."""
        stat = self.stats.get(stat_name)
        return stat.value if stat else None
    
    def get_trait_status(self, trait_name):
        """Get both the value and description of a survival trait."""
        trait = self.traits.get(trait_name)
        if trait:
            return (trait.value, trait.desc())
        return (None, None)
    
    def get_skill_level(self, skill_name):
        """Get both the value and proficiency description of a skill."""
        skill = self.skills.get(skill_name)
        if skill:
            return (skill.value, skill.desc())
        return (None, None)
    
    def modify_trait(self, trait_name, amount):
        """Modify a survival trait by a given amount."""
        trait = self.traits.get(trait_name)
        if trait:
            trait.current += amount
            return True
        return False
    
    def improve_skill(self, skill_name, amount=1):
        """Improve a skill by a given amount."""
        skill = self.skills.get(skill_name)
        if skill:
            skill.current += amount
            return True
        return False
    
    def get_survival_summary(self):
        """Get a formatted summary of all survival traits."""
        summary_parts = []
        for trait_name in ["hunger", "thirst", "fatigue", "health"]:
            trait = self.traits.get(trait_name)
            if trait:
                percent_value = int(trait.percent(formatting=None))
                desc = trait.desc()
                summary_parts.append(f"{trait_name.title()}: {percent_value}% ({desc})")
    
        return "\n".join(summary_parts)

    def get_skill_summary(self):
        """Get a formatted summary of all skills."""
        summary_parts = []
        for skill_name in ["crafting", "hunting", "foraging", 
                          "engineering", "survival", "trading"]:
            skill = self.skills.get(skill_name)
            if skill:
                value = int(skill.value)
                desc = skill.desc()
                summary_parts.append(f"{skill_name.title()}: {value} ({desc})")
    
        return "\n".join(summary_parts)
</file>

</files>
